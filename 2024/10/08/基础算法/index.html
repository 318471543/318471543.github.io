<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="基础算法, 重生带我走">
    <meta name="description" content="前缀和一维前缀和
求区间[l,r]之间的和：$s[r] - s[l - 1]$

核心代码：
for(int i &amp;#x3D; 1; i&amp;lt;&amp;#x3D;n;i++)     s[i] &amp;#x3D; s[i-1]+ a[i];

一维异或">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>基础算法 | 重生带我走</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">重生带我走</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">重生带我走</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">基础算法</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">基础算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><blockquote>
<p>求区间[l,r]之间的和：$s[r] - s[l - 1]$</p>
</blockquote>
<p><mark>核心代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i&lt;&#x3D;n;i++)     s[i] &#x3D; s[i-1]+ a[i];</code></pre>

<h3 id="一维异或和"><a href="#一维异或和" class="headerlink" title="一维异或和"></a>一维异或和</h3><blockquote>
<p>求区间 $[l,r]$ 之间的异或和：$s[r]$ ^ $s[l - 1]$</p>
</blockquote>
<p><mark>核心代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1;i &lt;&#x3D; n;i++)	sum[i] &#x3D; sum[i - 1] ^ a[i];</code></pre>

<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto init &#x3D; [&amp;]() -&gt; void &#x2F;&#x2F; 初始化
&#123;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
            s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
&#125;;

auto get &#x3D; [&amp;](int x1, int y1, int x2, int y2) -&gt; ll &#x2F;&#x2F; 返回矩阵[x1, y1]~[x2, y2]的和
&#123;
    return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
&#125;;</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1010;
int a[N][N],s[N][N];

int main()
&#123;
    int n,m,q;
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
        &#123;
            scanf(&quot;%d&quot;,&amp;a[i][j]);
            s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
        &#125;
    &#125;
    while (q--)
    &#123;
        int x1,y1,x2,y2;
        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
        printf(&quot;%d\n&quot;,s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><blockquote>
<p><strong>核心代码：</strong></p>
<p>在区间 $[l,r]$ 加上一个数 $c$：$b[l] +&#x3D; c, b[r + 1] -&#x3D; c;$</p>
</blockquote>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto insert &#x3D; [&amp;](int l, int r, int c) -&gt; void &#x2F;&#x2F; 预处理
&#123;
    b[l] +&#x3D; c;
    b[r + 1] -&#x3D; c;
&#125;;

for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    b[i] +&#x3D; b[i - 1]; &#x2F;&#x2F; 求一遍前缀和即为现数组</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int N &#x3D; 1e5+10;
int a[N],b[N];
void insert(int l,int r,int c)
&#123;
    b[l] +&#x3D;c;
    b[r + 1] -&#x3D; c;
&#125;
int main()
&#123;
    int n,m;
    scanf(&quot;%d%d&quot;, &amp;n,&amp;m);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   insert(i,i,a[i]);
    while (m -- )
    &#123;
        int l,r,c;
        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);
        insert(l,r,c); 
    &#125;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   b[i] +&#x3D; b[i-1];
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   printf(&quot;%d &quot;,b[i]);
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/799/">差分</a></p>
<p><strong>$div3\ E$（具体应用，绝妙的思路）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1955/problem/E">E. Long Inversions</a></p>
<p><mark>Long Inversions 代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;
    s &#x3D; &quot; &quot; + s;

    int res &#x3D; 0;
    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)
    &#123;
        vector&lt;int&gt; d(n + 1);
        bool ok &#x3D; true;
        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
        &#123;
            d[j] +&#x3D; d[j - 1];
            d[j] &amp;&#x3D; 1;
            int c &#x3D; s[j] - &#39;0&#39;;
            if ((c ^ d[j]) &#x3D;&#x3D; 0)
            &#123;
                d[j]++;
                if (j + i &lt;&#x3D; n) d[j + i] --;
                if (j + i - 1 &gt; n)
                &#123;
                    ok &#x3D; false;
                    break;
                &#125;
            &#125;
        &#125;
        if (ok)
        &#123;
            res &#x3D; i;
            break;
        &#125;
    &#125;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;
    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto insert &#x3D; [&amp;](int x1, int y1, int x2, int y2, int c) -&gt; void &#x2F;&#x2F; 预处理
&#123;
    b[x1][y1] +&#x3D; c;
    b[x1][y2+1] -&#x3D; c;
    b[x2+1][y1] -&#x3D; c;
    b[x2+1][y2+1] +&#x3D; c;
&#125;;

for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#x2F;&#x2F; 求一遍前缀和,类似于二维前缀和的预处理操作,b[i][j] 即为现数组
    for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
        b[i][j] +&#x3D; b[i-1][j] + b[i][j-1] - b[i-1][j-1];</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cout.tie(nullptr);
    
    int n, m, q;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;

    vector&lt;vector&lt;int&gt;&gt; b(n + 2, vector&lt;int&gt;(m + 2));
    auto insert &#x3D; [&amp;](int x1, int y1, int x2, int y2, int c) -&gt; void &#x2F;&#x2F; 预处理
    &#123;
        b[x1][y1] +&#x3D; c;
        b[x1][y2+1] -&#x3D; c;
        b[x2+1][y1] -&#x3D; c;
        b[x2+1][y2+1] +&#x3D; c;
    &#125;;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        for(int j &#x3D; 1, x;j &lt;&#x3D; m;j++)
            cin &gt;&gt; x, insert(i, j, i, j, x);

    while (q--)
    &#123;
        int x1, y1, x2, y2, c;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
        insert(x1, y1, x2, y2, c);
    &#125;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#x2F;&#x2F; 求一遍前缀和,类似于二维前缀和的预处理操作,b[i][j] 即为现数组
        for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
            b[i][j] +&#x3D; b[i-1][j] + b[i][j-1] - b[i-1][j-1];

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; m];
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/800/">差分矩阵</a></p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分："><a href="#整数二分：" class="headerlink" title="整数二分："></a>整数二分：</h3><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第一种:
while(l &lt; r)
&#123;
	int mid &#x3D; l + r + 1 &gt;&gt; 1;
	if(check(mid))	l &#x3D; mid;
	else	r &#x3D; mid - 1;
&#125;
&#x2F;&#x2F;第二种:
while(l &lt; r)
&#123;
	int mid &#x3D; l + r &gt;&gt; 1;
	if(check(mid))	r &#x3D; mid;
	else	l &#x3D; mid + 1;
&#125;</code></pre>

<h3 id="浮点数二分："><a href="#浮点数二分：" class="headerlink" title="浮点数二分："></a>浮点数二分：</h3><pre class="language-c++" data-language="c++"><code class="language-c++">while(l + eps &lt; r)
&#123;
    double mid &#x3D; (l + r) &#x2F; 2;
    if(check(mid))	l &#x3D; mid;
    else	r &#x3D; mid;
&#125;</code></pre>

<h3 id="题单："><a href="#题单：" class="headerlink" title="题单："></a>题单：</h3><p><mark>推荐题单：</mark></p>
<p><strong>二分 + 双指针 &#x2F; 二分套二分：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1852/problem/A">A. Ntarsis’ Set</a></p>
<p><strong>考古做两遍的一道 $cf\ C$ 二分好题：二分 + 差分 + 前缀和</strong>  <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1795/problem/C">C. Tea Tasting</a></p>
<p><strong>又是一道考古出来的二分好题（待考古）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1853/problem/C">https://codeforces.com/contest/1853/problem/C</a></p>
<p><strong>$ 2023CCPC $ 桂林站二分签到题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/M">M. Flipping Cards</a></p>
<p><strong>$Codeforces\ div3\ D$（猜出是二分了，但是 check 跟贪心似的，感觉很难实现，也不太对的样子）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1907/problem/D">D. Jumping Through Segments</a></p>
<p><strong>$div3\ F$（以为是二分套个三分，结果是纯二分，因为不满足三分的条件）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1941/problem/F">F. Rudolf and Imbalance</a></p>
<p><strong>$2024$ 天梯赛 $L3-2$ 二分 + 前缀和：</strong><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388429&page=1">L3-2 工业园区建设</a></p>
<p><strong>$codeforces\ div2$（算是所有二分中难度比较高一点的了，也是猜到二分了，但没能进一步分析出本质）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1998/problem/C">C. Perform Operations to Maximize Score</a></p>
<p><strong>易错的二分（特点：爆 $ll$）：</strong></p>
<ul>
<li><strong>百度之星第三场（直接让我$wa\ 11$ 发）：</strong><a target="_blank" rel="noopener" href="https://www.matiji.net/exam/brushquestion/17/4498/F16DA07A4D99E21DFFEF46BD18FF68AD">BD202417数星星</a></li>
<li><strong>CCPC 山东邀请赛（签到题，但因爆 $ll$，不敢继续交了$qwq$）：</strong>链接暂无</li>
</ul>
<p><mark>细谈CCPC二分签到：</mark></p>
<p><strong>很签吗？？？不签啊！但从各方面来说，但经典卧槽！</strong></p>
<p>这题让我魂牵梦绕了好久好久。。。</p>
<p>接下来，我们将细细探讨：</p>
<ol>
<li>二分答案<ul>
<li>二分答案好说，但永远的问题就是如何 $check$ ？好，下面来谈！</li>
</ul>
</li>
<li>可以想到，如果可以保证 $\geq mid$ 的数的个数有 $\frac{n + 1}{2}$ 个，那么由于是 $\geq$ 符号，则第 $\frac{n+1}{2}$ 个一定就是答案。  而如果个数更多，即超过 $\frac{n+1}{2}$ 个，那么答案要么是 $mid$，要么就是更靠后的答案（即令 $l &#x3D; mid$）。<ul>
<li>那么怎么计算这样的数有多少个呢？毕竟还有连续区间翻转的情况？那好，下面谈！</li>
</ul>
</li>
<li>不翻转的情况下，我们统计 $a$ 数组中有多少个数 $\geq mid$，然后不够的话就得需要通过翻转来凑！怎么凑呢？<ul>
<li>如果该位置的 $a_i &lt; mid$，而 $b_i &gt;&#x3D; mid$，那么交换之后会贡献 $1$ 个答案；</li>
<li>如果该位置的 $a_i$ 和 $b_i$ 同时 $\geq$ 或 $&lt; mid$ ，则贡献为 $0$；</li>
<li>如果该位置的 $a_i \geq mid$，而 $b_i &lt; mid$，则交换后贡献 $-1$；</li>
</ul>
</li>
<li>因此，有了这种转换的想法后，我们只需看最大连续子段和是多少就可以知道翻转后能得到的 $1$ 贡献最多是多少了！</li>
<li>因此，最终判断只需看 $cnt_{初始1的个数} + cnt_{翻转后提供1贡献} \geq \frac{n+1}{2}$ 即可。</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

#define pii pair&lt;int, int&gt;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;pii&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i].first &gt;&gt; a[i].second;

    auto check &#x3D; [&amp;](int mid) -&gt; int
    &#123;
        vector&lt;int&gt; v(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            v[i] &#x3D; (a[i].second &gt;&#x3D; mid) - (a[i].first &gt;&#x3D; mid);
        &#125;

        int res &#x3D; 0, cur &#x3D; 0, cnt &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            if (a[i].first &gt;&#x3D; mid)  cnt++;
            cur &#x3D; max(v[i], cur + v[i]);
            res &#x3D; max(res, cur);
        &#125;

        if (res + cnt &gt;&#x3D; (n + 1) &#x2F; 2)    return true;
        return false;
    &#125;;

    int l &#x3D; 1, r &#x3D; 1e9;
    while (l &lt; r)
    &#123;
        int mid &#x3D; l + r + 1 &gt;&gt; 1;
        if (check(mid))   l &#x3D; mid;
        else    r &#x3D; mid - 1;
    &#125;
    
    cout &lt;&lt; l &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>细谈：C. Tea Tasting</mark></p>
<blockquote>
<p><strong>题意：</strong> 有 $n$ 个茶与 $n$ 个人，每个人每次可以喝 $b_i$ 容量的茶，茶也有一定的容量，当然如果茶容量低于某个人所能喝的容量时，这个人可以把剩下的茶全部喝完。喝茶的方式：第一轮，第 $i$ 个人喝第 $i$ 编号的茶；第二轮，第 $i$ 个人喝第 $i - 1$ 编号的茶，以此类推，当然，如果有人该轮喝的是编号为 $1$ 的茶，则之后的回合就停止喝茶了，求所有轮次结束后，每个人共喝了多少茶？</p>
<p><strong>吐槽（吐槽中带有题解）：</strong> 第一眼看这道题，感觉挺容易暴力的 $O(n^2)$，显然过不了。直来直去的话又想是用某种数据结构来维护？但也好复杂，根本想不清楚。于是无奈看了一眼题解，但只看了第一行！题解说：对于第 $i$ 杯茶，它影响到的就是 $i$ 到 $j$ 这个区间，第 $j$ 个人可能会喝剩下的（qwq）。然后突然我就会写了？对，是真的会写了。口胡一下大致就是给区间 $[l,r]$ 的每个人 $+1$，表示这杯茶他们都能喝到 $b_i$ 容量的茶，最后一个人只能喝剩下的。前者直接差分一下，最后一个人喝剩下了直接加到答案数组里面。$n$ 杯茶，因为具备单调性，每次找的话就用<strong>二分查找</strong>，并用前缀和 $O(1)$ 维护下，整体时间复杂度：$O(n logn)$。</p>
<p>由于是看了一眼题解才知道从哪入手的，但为什么想的时候没想到？这个着手点并非正面入手的，可以理解成侧面入手。不过当时我也想了从茶开始着手，但是我只想到了第 $i$ 杯茶会影响 $i$ 到 $n$ 这些人，但没有细想这些具体的影响效果。实际想一想可知，找到第一个大于 $a_i$ 容量的位置 $j$，那么从 $i$ 到 $j$ 每个人都会完整享用第 $i$ 杯茶 对应 $b$ 的容量，最后第 $j$ 这个人喝剩下的就行了。这么一想就会有二分的想法，顺带着差分还有前缀和的想法，最后这道题就能想清楚了。</p>
<p>最后不得不说，还是得从多角度去考虑问题，而且每个角度要分析到可行或不可行的原因！</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1), b(n + 1);
    vector&lt;ll&gt; sum(n + 2);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; b[i], sum[i] &#x3D; sum[i - 1] + b[i];
    sum[n + 1] &#x3D; 1e17;

    vector&lt;ll&gt; res(n + 2), ans(n + 2);
    auto add &#x3D; [&amp;](int l, int r) -&gt; void
    &#123;
        if (l &gt; r)  return;
        res[l] +&#x3D; 1, res[r + 1] -&#x3D; 1;
    &#125;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int l &#x3D; i, r &#x3D; n + 1;
        while (l &lt; r)
        &#123;
            int mid &#x3D; l + r &gt;&gt; 1;
            if (sum[mid] - sum[i - 1] &gt; a[i])   r &#x3D; mid;
            else    l &#x3D; mid + 1;
        &#125;
        add(i, l - 1);
        ans[l] +&#x3D; a[i] - (sum[l - 1] - sum[i - 1]);
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        res[i] +&#x3D; res[i - 1];
        ans[i] +&#x3D; (ll)res[i] * b[i];
        cout &lt;&lt; ans[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>$Codeforces\ div3\  D. Jumping\ Through\ Segments$ 讲解：</mark></p>
<p><strong>未看答案或想到做法前：</strong><br>        刚开始以为贪心，虽然感觉不太对，但是还是去实现了，直到被某一个样例卡到了。然后就想到了用二分，但是现在写的时候想一想的话，用二分，因为它具有单调性的性质，但最容易卡死自己（也是每次二分最不会的 $check$）的地方，就是 $check$ 起来像个贪心，而且针对本题，假设 $check$ 的 $mid$ 是最大的步数，预测了下一步同样是向右移动的话，我是该向右先移到左边界，还是移动了 $mid$ ？还是得再讨论如果 mid 越过了下一个的右边界，又该何去何从？向右亦是如此，那如果下一步不用动，就在线段里面呢？那么是不移动好呢，还是略微移动？这些想法令我不知该如何下手！</p>
<p>​		</p>
<p>由于不能直接看题解！因为直接看了，那么这道题就不属于你了！这是一道比较经典的（至少对于自己来说）check 啊！</p>
<p>事后在前往杭州的高铁上，想到了check方法：每次前往一个线段，就是以一种区域的方式移过去，之前好像是想的这么移动，会让一个线段分成两个线段，但事实上并不会。区域转移还是一个连续的线段，只用处理两个区域之间的移动就可以啦（因有期末考试，待补…）。</p>
<h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><blockquote>
<p>三分时间复杂度：$O(logn)$</p>
<p>三分与二分的思想类似，也是通过不断缩小答案可能的区间范围，来找到最终答案所在的位置。</p>
<p>三分一般被用来查找某类单峰函数的峰值。</p>
<p>三分需要找三等分点：M1 &#x3D; (R - L) &#x2F; 3 + L,M2 &#x3D; (R - L) &#x2F; 3 + 2L。</p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>但也有某类单峰函数不能用三分！</p>
<p>某些问题的函数可能是单峰的，但峰值两边并非严格递增（递减）的，即有可能出现”平台“（）一条与x轴平行的直线。</p>
</blockquote>
<p><img src="/images/2.png"></p>
<blockquote>
<p>什么时候使用三分？</p>
<p>​	即一个函数，在考虑的范围[l,r]内是单峰的，并且从峰值往左右两边都是要<strong>严格</strong>单调递增或<strong>严格</strong>单调递减的。</p>
</blockquote>
<h3 id="整数三分"><a href="#整数三分" class="headerlink" title="整数三分"></a>整数三分</h3><blockquote>
<p>$while(l + 2 &lt; r)$ 需要区间可以分成三段！</p>
<p>最后暴力枚举 $l$ ~ $r$ 之间的结果即可！</p>
</blockquote>
<p><mark>整数三分凸函数模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int l &#x3D; 0,r &#x3D; 1e9;
while (l + 2 &lt; r)
&#123;
    int m1 &#x3D; l + (r - l) &#x2F; 3;
    int m2 &#x3D; l + (r - l) &#x2F; 3 * 2;
    if(f(m1) &gt; f(m2))   r &#x3D; m2;
    else    l &#x3D; m1;
&#125;

ll res &#x3D; l;
for(int i &#x3D; l + 1; i &lt;&#x3D; r;i ++)
    if(f(i) &gt; f(res))   res &#x3D; i;&#x2F;&#x2F;遍历一遍，获取最终答案</code></pre>

<p><mark>整数三分凹函数模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int l &#x3D; 0,r &#x3D; 1e9;
while (l + 2 &lt; r)
&#123;
    int m1 &#x3D; l + (r - l) &#x2F; 3;
    int m2 &#x3D; l + (r - l) &#x2F; 3 * 2;
    if(f(m1) &lt; f(m2))   r &#x3D; m2;
    else    l &#x3D; m1;
&#125;

ll res &#x3D; f(l);
for(int i &#x3D; l + 1;i &lt;&#x3D; r;i++)   res &#x3D; min(res,f(i));&#x2F;&#x2F;遍历一遍，获取最终答案</code></pre>

<p><mark>推荐题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5 + 10;

int n,A,R,M;
int a[N];

ll f(int x)
&#123;
    ll y &#x3D; 0,z &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        if(a[i] &lt; x)    y +&#x3D; x - a[i];
        else    z +&#x3D; a[i] - x;
    &#125;

    ll res &#x3D; min(y,z) * M; 
    if(y &gt; z)   res +&#x3D; (y - z) * A;
    else    res +&#x3D; (z - y) * R;
    return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; A &gt;&gt; R &gt;&gt; M;
    M &#x3D; min(M,A + R);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i];

    int l &#x3D; 0,r &#x3D; 1e9;
    while (l + 2 &lt; r)
    &#123;
        int m1 &#x3D; (r - l) &#x2F; 3 + l;
        int m2 &#x3D; (r - l) &#x2F; 3 * 2 + l;
        if(f(m1) &gt; f(m2))   l &#x3D; m1;
        else    r &#x3D; m2;
    &#125;
    
    ll res &#x3D; f(l);
    for(int i &#x3D; l + 1;i &lt;&#x3D; r;i++)   res &#x3D; min(res,f(i));

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>整数三分求凹函数</strong>：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1355/problem/E">E. Restorer Distance</a></p>
<h3 id="浮点数三分"><a href="#浮点数三分" class="headerlink" title="浮点数三分"></a>浮点数三分</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3382">【模板】三分法</a></p>
<blockquote>
<p>模板记忆口诀：哪个情况更糟就删去哪一部分（每次会删去三分之一的区间）：</p>
<p>比如要求最大值，就要把小的那一部分给删去；</p>
<p>要求最小值，则把大的那一部分删去。</p>
</blockquote>
<p><mark>浮点三分凸函数模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto f &#x3D; [&amp;](double x) -&gt; double
&#123;
    double res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        res +&#x3D; a[i] * pow(x,n - i + 1);
    return res;
&#125;;

while (l + eps &lt; r)
&#123;
    double m1 &#x3D; (r - l) &#x2F; 3 + l;
    double m2 &#x3D; (r - l) &#x2F; 3 * 2 + l;
    if(f(m1) &gt; f(m2))    r &#x3D; m2;
    else    l &#x3D; m1;
&#125;
cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; l &lt;&lt; &quot;\n&quot;;</code></pre>

<p><mark>浮点三分凹函数模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto f &#x3D; [&amp;](double x) -&gt; double
&#123;
    double res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        res +&#x3D; a[i] * pow(x,n - i + 1);
    return res;
&#125;;

while (l + eps &lt; r)
&#123;
    double m1 &#x3D; (r - l) &#x2F; 3 + l;
    double m2 &#x3D; (r - l) &#x2F; 3 * 2 + l;
    if(f(m1) &lt; f(m2))    r &#x3D; m2;
    else    l &#x3D; m1;
&#125;

cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; l &lt;&lt; &quot;\n&quot;;</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

constexpr double eps &#x3D; 1e-7;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    double l,r;
    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;

    vector&lt;double&gt; a(n + 1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i];
    double c;
    cin &gt;&gt; c;

    auto f &#x3D; [&amp;](double x) -&gt; double
    &#123;
        double res &#x3D; 0;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
            res +&#x3D; a[i] * pow(x,n - i + 1);
        return res + c;
    &#125;;

    while (l + eps &lt; r)
    &#123;
        double m1 &#x3D; (r - l) &#x2F; 3 + l;
        double m2 &#x3D; (r - l) &#x2F; 3 * 2 + l;
        if(f(m1) &gt; f(m2))    r &#x3D; m2;
        else    l &#x3D; m1;
    &#125;
    
    cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; l &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题（浮点三分求凸函数）：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3382">【模板】三分法</a></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6+10;

int n;
int a[N];

void quick_sort(int l,int r)
&#123;
    if(l &gt;&#x3D; r)  return;
    int x &#x3D; a[l + r &gt;&gt; 1],i &#x3D; l - 1,j &#x3D; r + 1;
    while (i &lt; j)
    &#123;
        do i++; while(a[i] &lt; x);
        do j--;while(a[j] &gt; x);
        if(i &lt; j)   swap(a[i],a[j]); 
    &#125;
    quick_sort(l,j);
    quick_sort(j + 1,r);
&#125;

int main()
&#123;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)    scanf(&quot;%d&quot;,&amp;a[i]);
    
    quick_sort(1,n);
    
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)    printf(&quot;%d &quot;,a[i]);
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/787/">快速排序</a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5+10;
int n;
int a[N],t[N];

void merge_sort(int l,int r)
&#123;
    if(l &gt;&#x3D; r)   return;
    int mid &#x3D; l + r &gt;&gt; 1;
    merge_sort(l,mid),merge_sort(mid + 1,r);
    int k &#x3D; 0,i &#x3D; l,j &#x3D; mid + 1;
    while(i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)
    &#123;
        if(a[i] &lt;&#x3D; a[j])    t[k++] &#x3D; a[i++];
        else    t[k++] &#x3D; a[j++];
    &#125;
    while(i &lt;&#x3D; mid) t[k++] &#x3D; a[i++];
    while(j &lt;&#x3D; r)   t[k++] &#x3D; a[j++];
    for(int i &#x3D; l,j &#x3D; 0;i &lt;&#x3D; r;)  a[i++] &#x3D; t[j++];
&#125;

int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i &#x3D; 0;i &lt; n;i++)    scanf(&quot;%d&quot;,&amp;a[i]);
    merge_sort(0,n - 1);
    for(int i &#x3D; 0;i &lt; n;i++)    printf(&quot;%d &quot;,a[i]);
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/789/">归并排序</a>	<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p>
<p><strong>$2023 \ ICPC$ 区域赛西安站（归并排序思想）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/476283/problem/H">H. Elimination Series Once More</a></p>
<p><strong>$2023\ CCPC$ 深圳铜牌题（分治思想，但不能分块）：</strong> <a target="_blank" rel="noopener" href="https://vjudge.net/contest/594105#problem/A">A - 一道好题 </a></p>
<hr>
<p><mark>西安站铜牌题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);
	cout.tie(nullptr);

	int n, k;
	cin &gt;&gt; n &gt;&gt; k;

	vector&lt;pii&gt; a(1 &lt;&lt; n + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; 1 &lt;&lt; n; i++)	cin &gt;&gt; a[i].first, a[i].second &#x3D; i;

	vector&lt;int&gt; res((1 &lt;&lt; n) + 1);
	function&lt;void(int, int, int)&gt; dfs &#x3D; [&amp;](int win, int l, int r) -&gt; void
	&#123;
		if (l &gt;&#x3D; r)	return;
		int mid &#x3D; l + r &gt;&gt; 1;
		dfs(win - 1, l, mid), dfs(win - 1, mid + 1, r);
		
		vector&lt;pii&gt; temp(r - l + 2);
		int idx &#x3D; 1, i &#x3D; l, j &#x3D; mid + 1;
		while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)
		&#123;
			if (a[i].first &lt; a[j].first)    temp[idx++] &#x3D; a[i++];
			else    temp[idx++] &#x3D; a[j++];
		&#125;
		while(i &lt;&#x3D; mid) temp[idx++] &#x3D; a[i++];
    	while(j &lt;&#x3D; r)   temp[idx++] &#x3D; a[j++];

		for(i &#x3D; l, j &#x3D; 1; i &lt;&#x3D; r; i++, j++) 
        &#123;
            a[i] &#x3D; temp[j];
            int id &#x3D; temp[j].second, x &#x3D; temp[j].first, len &#x3D; r - l + 1;
			int greater &#x3D; len - j; &#x2F;&#x2F; 里面比我大的
			int less &#x3D; x - 1 - (j - 1); &#x2F;&#x2F; 外面比我小的
			if (less &gt;&#x3D; greater &amp;&amp; k &gt;&#x3D; greater)
			&#123;
				res[id] &#x3D; max(res[id], win);
			&#125;
        &#125;
	&#125;;

	dfs(n, 1, 1 &lt;&lt; n);
	for (int i &#x3D; 1; i &lt;&#x3D; 1 &lt;&lt; n; i++)	cout &lt;&lt; res[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; (1 &lt;&lt; n)];

	return 0;
&#125;</code></pre>

<p><mark>深圳站铜牌题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

using pii &#x3D; pair&lt;int, int&gt;;

constexpr int N &#x3D; 1010;

vector&lt;int&gt; gb[N];

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n;
	cin &gt;&gt; n;

	vector&lt;pii&gt; b(n + 1);
	int mx &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	
	&#123;
		cin &gt;&gt; b[i].first;
		b[i].second &#x3D; 0;
		mx &#x3D; max(mx, b[i].first);
		gb[b[i].first].push_back(i);
	&#125;
	
	vector&lt;pii&gt; res;
	function&lt;void(int, int)&gt; dfs &#x3D; [&amp;](int l, int r) -&gt; void
	&#123;
		if (l &gt; r)	return;

		int mid &#x3D; l + r &gt;&gt; 1, cur &#x3D; -1;
		for (int i &#x3D; mid; i &lt;&#x3D; r; i++) &#x2F;&#x2F; 将大于等于mid的全部提升到mid
		&#123;
			for (auto x : gb[i])
			&#123;
				if (b[x].second &gt;&#x3D; mid)	continue;
				res.push_back(&#123;2, x&#125;);
				b[x].second++;
				cur &#x3D; b[x].second;
			&#125;
		&#125;

		if (cur !&#x3D; -1)
		&#123;
			int len &#x3D; mid - cur;
			for (int i &#x3D; 1, num &#x3D; cur; i &lt;&#x3D; len; i++, num++)
			&#123;
				res.push_back(&#123;1, num&#125;);
			&#125;
			for (int i &#x3D; mid; i &lt;&#x3D; r; i++)
			&#123;
				for (auto x : gb[i])
				&#123;
					b[x].second +&#x3D; len;
				&#125;
			&#125;
		&#125;

		dfs(l, mid - 1);
		dfs(mid + 1, r);
	&#125;;

	dfs(0, mx);

	cout &lt;&lt; res.size() &lt;&lt; &quot;\n&quot;;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	assert(b[i].first &#x3D;&#x3D; b[i].second);
	assert(res.size() &lt;&#x3D; 20000);
	for (auto [x, y] : res)	
		cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;

	return 0;
&#125;</code></pre>



<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788 【模板】单调栈</a></p>
<p><mark>1、每个数左边第一个比它小的数：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    stack&lt;int&gt; stk;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        while (stk.size() &amp;&amp; stk.top() &gt;&#x3D; a[i])    stk.pop();
        if (stk.size()) cout &lt;&lt; stk.top() &lt;&lt; &quot; &quot;;
        else    cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;
        stk.push(a[i]);
    &#125;

    return 0;
&#125;</code></pre>

<p><mark>2、每个数右边第一个比它大的下标：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    stack&lt;int&gt; stk;
    vector&lt;int&gt; ans;
    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)
    &#123;
        while (stk.size() &amp;&amp; a[stk.top()] &lt;&#x3D; a[i])    stk.pop();
        if (stk.size()) ans.push_back(stk.top());
        else    ans.push_back(0);
        stk.push(i);
    &#125;

    for (int i &#x3D; ans.size() - 1; i &gt;&#x3D; 0; i--)
        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;</code></pre>



<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><blockquote>
<p>实在是太经典了，必须入典！</p>
</blockquote>
<p><mark>思路：</mark></p>
<ul>
<li><p>每次的队头就是答案位置；</p>
</li>
<li><p>队列存的是下标；</p>
</li>
<li><p>如果当前枚举的位置 $i$ 比 (队头元素的下标 + 滑动窗口) 的位置大，则弹出队头；</p>
</li>
<li><p>队列中的元素满足单调性，如果队尾与当前需要插入的数进行比较，发现不满足想要的单调性，则弹出队尾；</p>
</li>
<li><p>因此，需要一个双端队列实现。</p>
</li>
</ul>
<p><mark>模板代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    deque&lt;int&gt; dq;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (dq.size() &amp;&amp; i &gt; dq.front() + k - 1)   dq.pop_front();
        while (dq.size() &amp;&amp; a[dq.back()] &gt;&#x3D; a[i])    dq.pop_back();
        dq.push_back(i);
        if (i &gt;&#x3D; k) cout &lt;&lt; a[dq.front()] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; &quot;\n&quot;;

    dq.clear();
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (dq.size() &amp;&amp; i &gt; dq.front() + k - 1)   dq.pop_front();
        while (dq.size() &amp;&amp; a[dq.back()] &lt;&#x3D; a[i])    dq.pop_back();
        dq.push_back(i);
        if (i &gt;&#x3D; k) cout &lt;&lt; a[dq.front()] &lt;&lt; &quot; &quot;;
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列</a></p>
<p><strong>单调队列优化的简单DP题（非常经典，必须配合着单调队列食用！）：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a></p>
<p><strong>同样是单调队列优化的 $DP$ 题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1941/problem/E">E. Rudolf and k Bridges</a></p>
<p><mark>std with E. Rudolf and k Bridges：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        int n, m, k, d;
        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;

        vector&lt;vector&lt;int&gt;&gt; g(n + 1, vector&lt;int&gt;(m + 1));
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)   
            for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
                cin &gt;&gt; g[i][j];
        
        vector&lt;ll&gt; res(n + 1);
        
        auto solve &#x3D; [&amp;](int pos) -&gt; void
        &#123;
            vector&lt;ll&gt; f(m + 1);
            f[1] &#x3D; 1;
            deque&lt;int&gt; dq;
            for (int i &#x3D; 2; i &lt;&#x3D; m; i++)
            &#123;
                if (dq.size() &amp;&amp; i &gt; dq.front() + d + 1)    dq.pop_front();
                while (dq.size() &amp;&amp; f[dq.back()] &gt;&#x3D; f[i - 1])   dq.pop_back();
                dq.push_back(i - 1);
                f[i] &#x3D; f[dq.front()] + g[pos][i] + 1;
            &#125;
            res[pos] &#x3D; f[m];
            &#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cout &lt;&lt; f[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; m];
        &#125;;
        ll ans &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    solve(i);

        vector&lt;ll&gt; sum(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    sum[i] &#x3D; sum[i - 1] + res[i];

        ans &#x3D; sum[k];
        for (int i &#x3D; 2; i &lt;&#x3D; n - k + 1; i++)
            ans &#x3D; min(ans, sum[k + i - 1] - sum[i - 1]);

        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57359/G">Go to Play Maimai DX</a></p>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7314">Simple Set Problem</a></p>
<p><strong>$2022$ 蓝桥杯省赛真题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4408/">统计子矩阵</a></p>
<p><mark>Simple Set Problem 代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;pii&gt; v;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        int cnt;
        cin &gt;&gt; cnt;
        for(int j &#x3D; 1,x;j &lt;&#x3D; cnt;j++)
        &#123;
            cin &gt;&gt; x;
            v.emplace_back(x,i);
        &#125;
    &#125;

    sort(v.begin(),v.end());

    vector&lt;int&gt; st(n + 1);
    int res &#x3D; 2e9,cnt &#x3D; 0;
    for(int i &#x3D; 0,j &#x3D; 0;i &lt; v.size() &amp;&amp; j &lt; v.size();)
    &#123;
        while(j &lt; v.size() &amp;&amp; cnt &lt; n)    
        &#123;
            if(++st[v[j].second] &#x3D;&#x3D; 1)  cnt++;
            j++;
        &#125;
        while(cnt &#x3D;&#x3D; n)
        &#123;
            res &#x3D; min(res,v[j - 1].first - v[i].first);
            if(--st[v[i].second] &#x3D;&#x3D; 0)  cnt--;
            i++;
        &#125;
    &#125;

    if(res &#x3D;&#x3D; 2e9)  res &#x3D; 0;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    IOS;

    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>封装了一个双链表的模板，其同时可以解决单链表的问题！</p>
</blockquote>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n;
	cin &gt;&gt; n;

	int head &#x3D; -1;
	int idx &#x3D; 0;


	vector&lt;int&gt; e(n + 10), ne(n + 10);

	auto add_head &#x3D; [&amp;](int x) -&gt; void
	&#123;
		e[idx] &#x3D; x, ne[idx] &#x3D; head, head &#x3D; idx++;
	&#125;;
	auto add &#x3D; [&amp;](int pos, int x) -&gt; void
	&#123;
		e[idx] &#x3D; x, ne[idx] &#x3D; ne[pos], ne[pos] &#x3D; idx++;
	&#125;;

	auto del &#x3D; [&amp;](int x) -&gt; void
	&#123;
		ne[x] &#x3D; ne[ne[x]];
	&#125;;

	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		char op;
		cin &gt;&gt; op;
		if (op &#x3D;&#x3D; &#39;H&#39;)
		&#123;
			int x;
			cin &gt;&gt; x;
			add_head(x);
		&#125;
		else if (op &#x3D;&#x3D; &#39;D&#39;)
		&#123;
			int x;
			cin &gt;&gt; x;
			if (!x)	head &#x3D; ne[head];
			else	del(x - 1);
		&#125;
		else
		&#123;
			int p, x;
			cin &gt;&gt; p &gt;&gt; x;
			add(p - 1, x);
		&#125;
	&#125;

	for (int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i])
		cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;
	return 0;
&#125;</code></pre>

<p><mark>双链表模板实现单链表：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10;
struct DoubleLinkList
&#123;
    int e[N]; &#x2F;&#x2F; 存结点对应的值; (如果结点存的值比较多, 可以用Node存储)
    int head, tail, idx, l[N], r[N];&#x2F;&#x2F; head:头指针; tail: 尾指针;
    map&lt;int, int&gt; mp; &#x2F;&#x2F; 存该值对应的在链表中的下标
    DoubleLinkList () &#123; &#x2F;&#x2F; 自动初始化
        init();
    &#125;
    void init() &#123; &#x2F;&#x2F; 初始化
        head &#x3D; 0;
        tail &#x3D; N - 1;
        r[head] &#x3D; tail;
        l[tail] &#x3D; head;
        idx &#x3D; 1;
    &#125;
    void add(int k, int x) &#123; &#x2F;&#x2F; 在第k个数的后面插入一个数
        mp[x] &#x3D; idx;
        e[idx] &#x3D; x;
        r[idx] &#x3D; r[k];
        l[idx] &#x3D; k;
        l[r[k]] &#x3D; idx;
        r[k] &#x3D; idx;
        idx++;
    &#125;
    void del(int k, bool keep &#x3D; false) &#123; &#x2F;&#x2F; 功能:删除第几个(插入的)数; keep: 是否保留
        r[l[k]] &#x3D; r[k];
        l[r[k]] &#x3D; l[k];
        if (!keep)  mp.erase(e[k]);
    &#125;
    bool isEmpty() &#123; &#x2F;&#x2F; 判断链表是否为空
        return l[tail] &#x3D;&#x3D; head;
    &#125;
    void print() &#123; &#x2F;&#x2F; 打印双链表
        for (int i &#x3D; r[head]; i !&#x3D; tail; i &#x3D; r[i])
            cout &lt;&lt; e[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; tail];
    &#125;

    void solve() &#123;
        int n;
        cin &gt;&gt; n;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            string op;
            cin &gt;&gt; op;
            if (op &#x3D;&#x3D; &quot;H&quot;)
            &#123;
                int x;
                cin &gt;&gt; x;
                add(head, x);
            &#125;
            else if (op &#x3D;&#x3D; &quot;D&quot;)
            &#123;
                int k;
                cin &gt;&gt; k;
                if (!k) del(r[head]);
                else    del(r[k]);
            &#125;
            else
            &#123;
                int k, x;
                cin &gt;&gt; k &gt;&gt; x;
                add(k, x);
            &#125;
        &#125;
        print();
    &#125;
&#125;lis;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    lis.solve();
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/828/">826. 单链表</a></p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Node
&#123;
    string data;
&#125;;

const int N &#x3D; 1e6 + 10;
struct DoubleLinkList
&#123;
    string e[N]; &#x2F;&#x2F; 存结点对应的值; (如果结点存的值比较多, 可以用Node存储)
    int head, tail, idx, l[N], r[N];&#x2F;&#x2F; head:头指针; tail: 尾指针;
    map&lt;string, int&gt; mp; &#x2F;&#x2F; 存该值对应的在链表中的下标
    DoubleLinkList () &#123; &#x2F;&#x2F; 自动初始化
        init();
    &#125;
    void init() &#123; &#x2F;&#x2F; 初始化
        head &#x3D; 0;
        tail &#x3D; N - 1;
        r[head] &#x3D; tail;
        l[tail] &#x3D; head;
        idx &#x3D; 1;
    &#125;
    void add(int k, string s) &#123; &#x2F;&#x2F; 在第k个数的后面插入一个数
        mp[s] &#x3D; idx;
        e[idx] &#x3D; s;
        r[idx] &#x3D; r[k];
        l[idx] &#x3D; k;
        l[r[k]] &#x3D; idx;
        r[k] &#x3D; idx;
        idx++;
    &#125;
    void del(int k, bool keep &#x3D; false) &#123; &#x2F;&#x2F; 功能:删除第几个(插入的)数; keep: 是否保留
        r[l[k]] &#x3D; r[k];
        l[r[k]] &#x3D; l[k];
        if (!keep)  mp.erase(e[k]);
    &#125;
    bool isEmpty() &#123; &#x2F;&#x2F; 判断链表是否为空
        return l[tail] &#x3D;&#x3D; head;
    &#125;
    void print() &#123; &#x2F;&#x2F; 打印双链表
        for (int i &#x3D; r[head]; i !&#x3D; tail; i &#x3D; r[i])
            cout &lt;&lt; e[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; tail];
    &#125;
&#125;lis;</code></pre>

<p><mark>模板题代码：</mark></p>
<ul>
<li><strong>个人封装版：</strong></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10;
struct DoubleLinkList
&#123;
    int e[N]; &#x2F;&#x2F; 存结点对应的值; (如果结点存的值比较多, 可以用Node存储)
    int head, tail, idx, l[N], r[N];&#x2F;&#x2F; head:头指针; tail: 尾指针;
    map&lt;int, int&gt; mp; &#x2F;&#x2F; 存该值对应的在链表中的下标
    DoubleLinkList () &#123; &#x2F;&#x2F; 自动初始化
        init();
    &#125;
    void init() &#123; &#x2F;&#x2F; 初始化
        head &#x3D; 0;
        tail &#x3D; N - 1;
        r[head] &#x3D; tail;
        l[tail] &#x3D; head;
        idx &#x3D; 1;
    &#125;
    void add(int k, int x) &#123; &#x2F;&#x2F; 在第k个数的后面插入一个数
        mp[x] &#x3D; idx;
        e[idx] &#x3D; x;
        r[idx] &#x3D; r[k];
        l[idx] &#x3D; k;
        l[r[k]] &#x3D; idx;
        r[k] &#x3D; idx;
        idx++;
    &#125;
    void del(int k, bool keep &#x3D; false) &#123;&#x2F;&#x2F;keep: 是否保留
        r[l[k]] &#x3D; r[k];
        l[r[k]] &#x3D; l[k];
        if (!keep)  mp.erase(e[k]);
    &#125;
    bool isEmpty() &#123; &#x2F;&#x2F; 判断链表是否为空
        return l[tail] &#x3D;&#x3D; head;
    &#125;
    void print() &#123; &#x2F;&#x2F; 打印双链表
        for (int i &#x3D; r[head]; i !&#x3D; tail; i &#x3D; r[i])
            cout &lt;&lt; e[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; tail];
    &#125;

    void solve() &#123;
        int n;
        cin &gt;&gt; n;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            string op;
            cin &gt;&gt; op;
            if (op &#x3D;&#x3D; &quot;L&quot;)
            &#123;
                int x;
                cin &gt;&gt; x;
                add(head, x);
            &#125;
            else if (op &#x3D;&#x3D; &quot;R&quot;)
            &#123;
                int x;
                cin &gt;&gt; x;
                add(l[tail], x);
            &#125;
            else if (op &#x3D;&#x3D; &quot;D&quot;)
            &#123;
                int k;
                cin &gt;&gt; k;
                del(k);
            &#125;
            else if (op &#x3D;&#x3D; &quot;IL&quot;)
            &#123;
                int k, x;
                cin &gt;&gt; k &gt;&gt; x;
                add(l[k], x);
            &#125;
            else
            &#123;
                int k, x;
                cin &gt;&gt; k &gt;&gt; x;
                add(k, x);
            &#125;
        &#125;
        print();
    &#125;
&#125;lis;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    lis.solve();
    return 0;
&#125;</code></pre>

<ul>
<li>$yxc$ 版：</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int N &#x3D; 1e5+10;
int e[N],l[N],r[N],idx;
&#x2F;&#x2F;初始化
void init()
&#123;
    &#x2F;&#x2F;0表示左端点，1表示右端点
    r[0] &#x3D; 1,l[1] &#x3D; 0;
    idx &#x3D; 2;
&#125;
&#x2F;&#x2F;在下标是k的点的右边，插入x
void add(int k,int x)&#x2F;&#x2F;因为下面用一个函数实现多种功能，因此需注意下方向
&#123;
    e[idx] &#x3D; x;
    r[idx] &#x3D; r[k];
    l[idx] &#x3D; k;
    l[r[k]] &#x3D; idx;&#x2F;&#x2F;不可颠倒顺序呦
    r[k] &#x3D; idx++;
&#125;
void remove(int k)
&#123;
    r[l[k]] &#x3D; r[k];&#x2F;&#x2F;我左边的右边等于我的右边
    l[r[k]] &#x3D; l[k];&#x2F;&#x2F;我右边的左边等于我的左边
&#125;
int main()
&#123;
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    init();
    int m;
    cin &gt;&gt; m;
    while (m--)
    &#123;
        string op;
        cin &gt;&gt; op;&#x2F;&#x2F;cin读取字符串
        int k,x;
        if(op&#x3D;&#x3D;&quot;L&quot;)
        &#123;
            cin &gt;&gt; x;
            add(0,x);&#x2F;&#x2F;在0后面插入一个数
        &#125;
        else if(op&#x3D;&#x3D;&quot;R&quot;)
        &#123;
            cin &gt;&gt; x;
            add(l[1],x);&#x2F;&#x2F;经过了转换
        &#125;
        else if(op&#x3D;&#x3D;&quot;D&quot;)
        &#123;
            cin &gt;&gt; k;
            remove(k+1);
        &#125;
        else if(op&#x3D;&#x3D;&quot;IL&quot;)
        &#123;
            cin &gt;&gt; k &gt;&gt; x;
            add(l[k+1],x);&#x2F;&#x2F;经过了转换
        &#125;
        else if(op&#x3D;&#x3D;&quot;IR&quot;)
        &#123;
            cin &gt;&gt; k &gt;&gt; x;
            add(k+1,x);
        &#125;
    &#125;
    for (int i &#x3D; r[0]; i !&#x3D; 1; i&#x3D;r[i])
    &#123;
        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/829/">827. 双链表</a></p>
<p><strong>链表是核心，但更重要的思想是优化：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1922/problem/D">D. Berserk Monsters</a></p>
<p><strong>$2023$ 蓝桥杯真题（双链表 + 优先队列）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4964/">整数删除</a></p>
<p><strong>一道双链表的大模拟：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/77922/G">排队</a></p>
<p><strong>力扣用双链表解决 $LRU$：</strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存</a></p>
<p><mark>排队代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

array&lt;string, 2&gt; arr;

const int N &#x3D; 3e5 + 10;

struct DoubleLinkList
&#123;
    string e[N];
    int head, tail, idx, l[N], r[N];
    map&lt;string, int&gt; mp;
    void init() &#123;
        head &#x3D; 0;
        tail &#x3D; N - 1;
        r[head] &#x3D; tail;
        l[tail] &#x3D; head;
        idx &#x3D; 1;
    &#125;
    void add(int k, string s) &#123; &#x2F;&#x2F; 在第k个数的后面插入一个数
        mp[s] &#x3D; idx;
        e[idx] &#x3D; s;
        r[idx] &#x3D; r[k];
        l[idx] &#x3D; k;
        l[r[k]] &#x3D; idx;
        r[k] &#x3D; idx;
        idx++;
    &#125;
    void del(int k, bool keep) &#123;&#x2F;&#x2F;keep: 是否保留
        r[l[k]] &#x3D; r[k];
        l[r[k]] &#x3D; l[k];
        if (!keep)  mp.erase(e[k]);
    &#125;
    bool isEmpty() &#123; &#x2F;&#x2F; 判断链表是否为空
        return l[tail] &#x3D;&#x3D; head;
    &#125;
    void print() &#123; &#x2F;&#x2F; 打印双链表
        for (int i &#x3D; r[head]; i !&#x3D; tail; i &#x3D; r[i])
            cout &lt;&lt; e[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; tail];
    &#125;
    bool checkInQueue(string s) &#123;
        return mp.count(s);
    &#125;
    bool checkInQueueButNotplay(string s) &#123;
        return mp.count(s) &amp;&amp; arr[0] !&#x3D; s &amp;&amp; arr[1] !&#x3D; s;
    &#125;

    void solve() &#123;
        init();

        int n;
        cin &gt;&gt; n;

        arr[0] &#x3D; arr[1] &#x3D; &quot;&quot;;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            string op, name;
            cin &gt;&gt; op;

            if (op[0] &#x3D;&#x3D; &#39;s&#39;)
            &#123;
                if (arr[0] &#x3D;&#x3D; &quot;&quot;)&#x2F;&#x2F; 是第一局
                &#123;
                    &#x2F;&#x2F; 判断当前是否有人上场
                    if (!(r[head] &#x3D;&#x3D; tail)) &#x2F;&#x2F; 有人上场
                    &#123;
                        &#x2F;&#x2F; 输出人名
                        arr[0] &#x3D; e[r[head]];
                        int nxt &#x3D; r[r[head]];
                        if (nxt !&#x3D; tail)
                        &#123;
                            arr[1] &#x3D; e[nxt];
                            cout &lt;&lt; arr[0] &lt;&lt; &quot; &quot; &lt;&lt; arr[1] &lt;&lt;  &quot;\n&quot;;
                        &#125;
                        else
                        &#123;
                            cout &lt;&lt; arr[0] &lt;&lt; &quot;\n&quot;;
                        &#125;
                    &#125;
                    else &#x2F;&#x2F; 无人上场
                    &#123;
                        cout &lt;&lt; &quot;Error\n&quot;;
                    &#125;
                &#125;
                else
                &#123;
                    &#x2F;&#x2F; 将当前玩家放入队列中
                    if (arr[1] &#x3D;&#x3D; &quot;&quot;) &#x2F;&#x2F; 将前1个玩家放入队尾
                    &#123;
                        &#x2F;&#x2F; 并删除队列中前1元素
                        add(l[tail], arr[0]); 
                        del(r[head], true);
                    &#125;
                    else &#x2F;&#x2F; 将前2个玩家放入队尾
                    &#123;
                        &#x2F;&#x2F; 并删除队列中前2元素
                        add(l[tail], arr[0]);
                        add(l[tail], arr[1]);
                        del(r[head], true);
                        del(r[head], true);
                    &#125;


                    &#x2F;&#x2F; 从队列中取出前 1 &#x2F; 2名选手
                    &#x2F;&#x2F; 输出人名
                    arr[0] &#x3D; e[r[head]];
                    int nxt &#x3D; r[r[head]];
                    if (nxt !&#x3D; tail)
                    &#123;
                        arr[1] &#x3D; e[nxt];
                        cout &lt;&lt; arr[0] &lt;&lt; &quot; &quot; &lt;&lt; arr[1] &lt;&lt;  &quot;\n&quot;;
                    &#125;
                    else
                    &#123;
                        cout &lt;&lt; arr[0] &lt;&lt; &quot;\n&quot;;
                    &#125;
                &#125;
            &#125;
            else if (op[0] &#x3D;&#x3D; &#39;a&#39;)
            &#123;
                cin &gt;&gt; name;
                &#x2F;&#x2F; cout &lt;&lt; &quot;arrive:&quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; mp.count(name) &lt;&lt; &quot; &quot; &lt;&lt; checkInQueue(name) &lt;&lt; &quot;\n&quot;;
                if (checkInQueue(name)) &#x2F;&#x2F; 如果这个人在排队, 输出
                &#123;
                    cout &lt;&lt; &quot;Error\n&quot;;
                &#125;
                else &#x2F;&#x2F; 加入队尾
                &#123;
                    add(l[tail], name);
                    cout &lt;&lt; &quot;OK\n&quot;;
                &#125;
            &#125;
            else
            &#123;
                cin &gt;&gt; name;
                if (checkInQueueButNotplay(name)) &#x2F;&#x2F; 如果在排队并且不在游完
                &#123;
                    cout &lt;&lt; &quot;OK\n&quot;;
                    int this_pos &#x3D; mp[name];
                    del(this_pos, false);
                &#125;
                else
                &#123;
                    cout &lt;&lt; &quot;Error\n&quot;;
                &#125;
            &#125;
        &#125;
    &#125;
    
&#125;lis;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    lis.solve();

    return 0;
&#125;</code></pre>

<p><mark>力扣题：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

struct Node
&#123;
    int key, value;
&#125;;

class LRUCache &#123;
public:
    int n, head, tail, idx, cnt;
    vector&lt;int&gt; l, r, mp;
    vector&lt;Node&gt; e;
    void add(int k, int key, int value) &#123; &#x2F;&#x2F; 在第k个数的后面插入一个数
        mp[key] &#x3D; idx;
        e[idx] &#x3D; &#123;key, value&#125;;
        r[idx] &#x3D; r[k];
        l[idx] &#x3D; k;
        l[r[k]] &#x3D; idx;
        r[k] &#x3D; idx;
        idx++;
        cnt++;
    &#125;
    void del(int k, bool keep &#x3D; false) &#123;&#x2F;&#x2F;keep: 是否保留
        r[l[k]] &#x3D; r[k];
        l[r[k]] &#x3D; l[k];
        if (!keep)  
        &#123;
            mp[e[k].key] &#x3D; 0;
        &#125;
        cnt--;
    &#125;
    void print () &#123;
        for (int i &#x3D; r[head]; i !&#x3D; tail; i &#x3D; r[i])
            cout &lt;&lt; e[i].key &lt;&lt; &quot; &quot; &lt;&lt; e[i].value &lt;&lt; &quot;\n&quot;;
    &#125;
    LRUCache(int capacity) &#123;
        n &#x3D; capacity;
        l.resize(2e5 + 10), r.resize(2e5 + 10), e.resize(2e5 + 10), mp.resize(2e5 + 10);
        head &#x3D; 0, cnt &#x3D; 0;
        tail &#x3D; 2e5;
        r[head] &#x3D; tail;
        l[tail] &#x3D; head;
        idx &#x3D; 1;
    &#125;
    
    int get(int key) &#123;
        if (mp[key]) &#123; &#x2F;&#x2F; 存在, 访问一下, 并将其放在尾部
            int tkey &#x3D; key, tvalue &#x3D; e[mp[key]].value;
            del(mp[key]);
            add(l[tail], tkey, tvalue);
            return tvalue;
        &#125; else &#123;
            return -1;
        &#125;
    &#125;
    
    void put(int key, int value) &#123;
        if (mp[key]) &#123; &#x2F;&#x2F; 已存在, 修改该值，并将其放入尾部
            del(mp[key]);
            add(l[tail], key, value);
        &#125; else &#123;
            if (cnt &lt; n) &#123; &#x2F;&#x2F; 不存在，空间足够，则直接插入到尾部
                add(l[tail], key, value);
            &#125; else &#123; &#x2F;&#x2F; 空间不够，删除头部，再插入到尾部
                del(r[head]);
                add(l[tail], key, value);
            &#125;
        &#125;
    &#125;
&#125;;</code></pre>



<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int N &#x3D; 1e6 + 10;
vector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)
&#123;
    vector&lt;int&gt; C;
    int t &#x3D; 0;
    for (int i &#x3D; 0; i &lt; A.size()|| i &lt; B.size(); i++)
    &#123;
        if(i &lt; A.size())    t +&#x3D; A[i];
        if(i &lt; B.size())    t +&#x3D; B[i];
        C.push_back(t%10);
        t &#x2F;&#x3D; 10;
    &#125;
    if(t) C.push_back(1);
    return C;
&#125;

int main()
&#123;
    string a,b;
    vector&lt;int&gt;A,B;
    cin &gt;&gt; a &gt;&gt; b;
    for(int i &#x3D; a.size()-1;i &gt;&#x3D; 0;i--)  A.push_back(a[i]-&#39;0&#39;);
    for(int i &#x3D; b.size()-1;i &gt;&#x3D; 0;i--)  B.push_back(b[i]-&#39;0&#39;);
    auto C &#x3D; add(A,B);
    for (int i &#x3D; C.size() - 1; i &gt;&#x3D; 0; i--) printf(&quot;%d&quot;,C[i]);
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/793/">高精度加法</a></p>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
bool cmp(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)
&#123;
    if(A.size()!&#x3D; B.size()) return A.size() &gt; B.size();
    for(int i &#x3D; A.size() - 1;i &gt;&#x3D; 0;i--)
    &#123;
        if(A[i] !&#x3D; B[i])    return A[i] &gt; B[i];
    &#125;
    return true;
&#125;
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    for(int i &#x3D; 0,t &#x3D; 0;i &lt; A.size();i++)
    &#123;
        t &#x3D; A[i] - t;
        if(i &lt; B.size())    t -&#x3D;B[i];
        C.push_back((t+10)%10);
        if(t &lt; 0)   t &#x3D; 1;
        else    t &#x3D; 0;
    &#125;
    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0)    C.pop_back();
    return C;
&#125;
int main()
&#123;
    string a,b;
    vector&lt;int&gt; A,B;
    cin &gt;&gt; a &gt;&gt; b;
    for(int i &#x3D; a.size()-1;i &gt;&#x3D; 0;i--) A.push_back(a[i]-&#39;0&#39;);
    for(int i &#x3D; b.size()-1;i &gt;&#x3D; 0;i--) B.push_back(b[i]-&#39;0&#39;);
    if(cmp(A,B))
    &#123;
        auto C &#x3D; sub(A,B);
        for(int i &#x3D; C.size()-1;i &gt;&#x3D;0;i--)   printf(&quot;%d&quot;,C[i]);
    &#125;
    else
    &#123;
        auto C &#x3D; sub(B,A);
        printf(&quot;-&quot;);
        for(int i &#x3D; C.size()-1;i &gt;&#x3D;0;i--)   printf(&quot;%d&quot;,C[i]);
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/794/">高精度减法</a></p>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b)
&#123;
    vector&lt;int&gt;C;
    int t &#x3D; 0;
    for(int i &#x3D; 0; i &lt; A.size() || t;i++)
    &#123;
        if(i &lt; A.size())    t +&#x3D; A[i] * b;
        C.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;
    while(C.size()&gt;1 &amp;&amp; C.back()&#x3D;&#x3D;0)    C.pop_back();
    return C;
&#125;
int main()
&#123;
    string a;
    int b;
    cin &gt;&gt; a &gt;&gt; b;
    vector&lt;int&gt;A;
    for(int i &#x3D; a.size() - 1;i &gt;&#x3D; 0;i--)    A.push_back(a[i]-&#39;0&#39;);
    auto C &#x3D; mul(A,b);
    for(int i &#x3D; C.size()-1;i &gt;&#x3D; 0;i--)  printf(&quot;%d&quot;,C[i]);
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/795/">高精度乘法</a></p>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b,int &amp;r)
&#123;
    vector&lt;int&gt;C;
    r &#x3D; 0;
    for(int i &#x3D; A.size() - 1;i &gt;&#x3D; 0; i--)
    &#123;
        r &#x3D; r*10+A[i];
        C.push_back(r&#x2F;b);
        r %&#x3D; b;
    &#125;
    reverse(C.begin(),C.end());
    while(C.size() &gt; 1 &amp;&amp; C.back()&#x3D;&#x3D;0)  C.pop_back();
    return C;
&#125;
int main()
&#123;
    string a;
    int b;
    cin &gt;&gt; a &gt;&gt; b;
    vector&lt;int&gt;A;
    for(int i &#x3D; a.size() -1;i&gt;&#x3D;0;i--)   A.push_back(a[i]-&#39;0&#39;);
    int r;
    auto C &#x3D; div(A,b,r);
    for(int i &#x3D; C.size() - 1;i &gt;&#x3D; 0;i--)    printf(&quot;%d&quot;,C[i]);
    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/796/">高精度除法</a></p>
<h3 id="高精度封装模板"><a href="#高精度封装模板" class="headerlink" title="高精度封装模板"></a>高精度封装模板</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int base &#x3D; 1000000000;
const int base_digits &#x3D; 9;

struct bigint &#123;
	std::vector&lt;int&gt; z;
	int sign;

	bigint() :
		sign(1) &#123;
	&#125;

	bigint(long long v) &#123;
		*this &#x3D; v;
	&#125;

	bigint(const std::string &amp;s) &#123;
		read(s);
	&#125;

	void operator&#x3D;(const bigint &amp;v) &#123;
		sign &#x3D; v.sign;
		z &#x3D; v.z;
	&#125;

	void operator&#x3D;(long long v) &#123;
		sign &#x3D; 1;
		if (v &lt; 0)
			sign &#x3D; -1, v &#x3D; -v;
		z.clear();
		for (; v &gt; 0; v &#x3D; v &#x2F; base)
			z.push_back(v % base);
	&#125;

	bigint operator+(const bigint &amp;v) const &#123;
		if (sign &#x3D;&#x3D; v.sign) &#123;
			bigint res &#x3D; v;

			for (int i &#x3D; 0, carry &#x3D; 0; i &lt; (int) std::max(z.size(), v.z.size()) || carry; ++i) &#123;
				if (i &#x3D;&#x3D; (int) res.z.size())
					res.z.push_back(0);
				res.z[i] +&#x3D; carry + (i &lt; (int) z.size() ? z[i] : 0);
				carry &#x3D; res.z[i] &gt;&#x3D; base;
				if (carry)
					res.z[i] -&#x3D; base;
			&#125;
			return res;
		&#125;
		return *this - (-v);
	&#125;

	bigint operator-(const bigint &amp;v) const &#123;
		if (sign &#x3D;&#x3D; v.sign) &#123;
			if (abs() &gt;&#x3D; v.abs()) &#123;
				bigint res &#x3D; *this;
				for (int i &#x3D; 0, carry &#x3D; 0; i &lt; (int) v.z.size() || carry; ++i) &#123;
					res.z[i] -&#x3D; carry + (i &lt; (int) v.z.size() ? v.z[i] : 0);
					carry &#x3D; res.z[i] &lt; 0;
					if (carry)
						res.z[i] +&#x3D; base;
				&#125;
				res.trim();
				return res;
			&#125;
			return -(v - *this);
		&#125;
		return *this + (-v);
	&#125;

	void operator*&#x3D;(int v) &#123;
		if (v &lt; 0)
			sign &#x3D; -sign, v &#x3D; -v;
		for (int i &#x3D; 0, carry &#x3D; 0; i &lt; (int) z.size() || carry; ++i) &#123;
			if (i &#x3D;&#x3D; (int) z.size())
				z.push_back(0);
			long long cur &#x3D; z[i] * (long long) v + carry;
			carry &#x3D; (int) (cur &#x2F; base);
			z[i] &#x3D; (int) (cur % base);
			&#x2F;&#x2F;asm(&quot;divl %%ecx&quot; : &quot;&#x3D;a&quot;(carry), &quot;&#x3D;d&quot;(a[i]) : &quot;A&quot;(cur), &quot;c&quot;(base));
		&#125;
		trim();
	&#125;

	bigint operator*(int v) const &#123;
		bigint res &#x3D; *this;
		res *&#x3D; v;
		return res;
	&#125;

	friend std::pair&lt;bigint, bigint&gt; divmod(const bigint &amp;a1, const bigint &amp;b1) &#123;
		int norm &#x3D; base &#x2F; (b1.z.back() + 1);
		bigint a &#x3D; a1.abs() * norm;
		bigint b &#x3D; b1.abs() * norm;
		bigint q, r;
		q.z.resize(a.z.size());

		for (int i &#x3D; a.z.size() - 1; i &gt;&#x3D; 0; i--) &#123;
			r *&#x3D; base;
			r +&#x3D; a.z[i];
			int s1 &#x3D; b.z.size() &lt; r.z.size() ? r.z[b.z.size()] : 0;
			int s2 &#x3D; b.z.size() - 1 &lt; r.z.size() ? r.z[b.z.size() - 1] : 0;
			int d &#x3D; ((long long) s1 * base + s2) &#x2F; b.z.back();
			r -&#x3D; b * d;
			while (r &lt; 0)
				r +&#x3D; b, --d;
			q.z[i] &#x3D; d;
		&#125;

		q.sign &#x3D; a1.sign * b1.sign;
		r.sign &#x3D; a1.sign;
		q.trim();
		r.trim();
		return std::make_pair(q, r &#x2F; norm);
	&#125;

	friend bigint sqrt(const bigint &amp;a1) &#123;
		bigint a &#x3D; a1;
		while (a.z.empty() || a.z.size() % 2 &#x3D;&#x3D; 1)
			a.z.push_back(0);

		int n &#x3D; a.z.size();
		
		int firstDigit &#x3D; (int) sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
		int norm &#x3D; base &#x2F; (firstDigit + 1);
		a *&#x3D; norm;
		a *&#x3D; norm;
		while (a.z.empty() || a.z.size() % 2 &#x3D;&#x3D; 1)
			a.z.push_back(0);
		
		bigint r &#x3D; (long long) a.z[n - 1] * base + a.z[n - 2];
		firstDigit &#x3D; (int) sqrt((double) a.z[n - 1] * base + a.z[n - 2]);
		int q &#x3D; firstDigit;
		bigint res;
 
		for(int j &#x3D; n &#x2F; 2 - 1; j &gt;&#x3D; 0; j--) &#123;
			for(; ; --q) &#123;
				bigint r1 &#x3D; (r - (res * 2 * base + q) * q) * base * base + (j &gt; 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);
				if (r1 &gt;&#x3D; 0) &#123;
					r &#x3D; r1;
					break;
				&#125;
			&#125;
			res *&#x3D; base;
			res +&#x3D; q;

			if (j &gt; 0) &#123;
				int d1 &#x3D; res.z.size() + 2 &lt; r.z.size() ? r.z[res.z.size() + 2] : 0;
				int d2 &#x3D; res.z.size() + 1 &lt; r.z.size() ? r.z[res.z.size() + 1] : 0;
				int d3 &#x3D; res.z.size() &lt; r.z.size() ? r.z[res.z.size()] : 0;
				q &#x3D; ((long long) d1 * base * base + (long long) d2 * base + d3) &#x2F; (firstDigit * 2);
			&#125;		   
		&#125;
		
		res.trim();
		return res &#x2F; norm;
	&#125;

	bigint operator&#x2F;(const bigint &amp;v) const &#123;
		return divmod(*this, v).first;
	&#125;

	bigint operator%(const bigint &amp;v) const &#123;
		return divmod(*this, v).second;
	&#125;

	void operator&#x2F;&#x3D;(int v) &#123;
		if (v &lt; 0)
			sign &#x3D; -sign, v &#x3D; -v;
		for (int i &#x3D; (int) z.size() - 1, rem &#x3D; 0; i &gt;&#x3D; 0; --i) &#123;
			long long cur &#x3D; z[i] + rem * (long long) base;
			z[i] &#x3D; (int) (cur &#x2F; v);
			rem &#x3D; (int) (cur % v);
		&#125;
		trim();
	&#125;

	bigint operator&#x2F;(int v) const &#123;
		bigint res &#x3D; *this;
		res &#x2F;&#x3D; v;
		return res;
	&#125;

	int operator%(int v) const &#123;
		if (v &lt; 0)
			v &#x3D; -v;
		int m &#x3D; 0;
		for (int i &#x3D; z.size() - 1; i &gt;&#x3D; 0; --i)
			m &#x3D; (z[i] + m * (long long) base) % v;
		return m * sign;
	&#125;

	void operator+&#x3D;(const bigint &amp;v) &#123;
		*this &#x3D; *this + v;
	&#125;
	void operator-&#x3D;(const bigint &amp;v) &#123;
		*this &#x3D; *this - v;
	&#125;
	void operator*&#x3D;(const bigint &amp;v) &#123;
		*this &#x3D; *this * v;
	&#125;
	void operator&#x2F;&#x3D;(const bigint &amp;v) &#123;
		*this &#x3D; *this &#x2F; v;
	&#125;

	bool operator&lt;(const bigint &amp;v) const &#123;
		if (sign !&#x3D; v.sign)
			return sign &lt; v.sign;
		if (z.size() !&#x3D; v.z.size())
			return z.size() * sign &lt; v.z.size() * v.sign;
		for (int i &#x3D; z.size() - 1; i &gt;&#x3D; 0; i--)
			if (z[i] !&#x3D; v.z[i])
				return z[i] * sign &lt; v.z[i] * sign;
		return false;
	&#125;

	bool operator&gt;(const bigint &amp;v) const &#123;
		return v &lt; *this;
	&#125;
	bool operator&lt;&#x3D;(const bigint &amp;v) const &#123;
		return !(v &lt; *this);
	&#125;
	bool operator&gt;&#x3D;(const bigint &amp;v) const &#123;
		return !(*this &lt; v);
	&#125;
	bool operator&#x3D;&#x3D;(const bigint &amp;v) const &#123;
		return !(*this &lt; v) &amp;&amp; !(v &lt; *this);
	&#125;
	bool operator!&#x3D;(const bigint &amp;v) const &#123;
		return *this &lt; v || v &lt; *this;
	&#125;

	void trim() &#123;
		while (!z.empty() &amp;&amp; z.back() &#x3D;&#x3D; 0)
			z.pop_back();
		if (z.empty())
			sign &#x3D; 1;
	&#125;

	bool isZero() const &#123;
		return z.empty() || (z.size() &#x3D;&#x3D; 1 &amp;&amp; !z[0]);
	&#125;

	bigint operator-() const &#123;
		bigint res &#x3D; *this;
		res.sign &#x3D; -sign;
		return res;
	&#125;

	bigint abs() const &#123;
		bigint res &#x3D; *this;
		res.sign *&#x3D; res.sign;
		return res;
	&#125;

	long long longValue() const &#123;
		long long res &#x3D; 0;
		for (int i &#x3D; z.size() - 1; i &gt;&#x3D; 0; i--)
			res &#x3D; res * base + z[i];
		return res * sign;
	&#125;

	friend bigint gcd(const bigint &amp;a, const bigint &amp;b) &#123;
		return b.isZero() ? a : gcd(b, a % b);
	&#125;
	friend bigint lcm(const bigint &amp;a, const bigint &amp;b) &#123;
		return a &#x2F; gcd(a, b) * b;
	&#125;

	void read(const std::string &amp;s) &#123;
		sign &#x3D; 1;
		z.clear();
		int pos &#x3D; 0;
		while (pos &lt; (int) s.size() &amp;&amp; (s[pos] &#x3D;&#x3D; &#39;-&#39; || s[pos] &#x3D;&#x3D; &#39;+&#39;)) &#123;
			if (s[pos] &#x3D;&#x3D; &#39;-&#39;)
				sign &#x3D; -sign;
			++pos;
		&#125;
		for (int i &#x3D; s.size() - 1; i &gt;&#x3D; pos; i -&#x3D; base_digits) &#123;
			int x &#x3D; 0;
			for (int j &#x3D; std::max(pos, i - base_digits + 1); j &lt;&#x3D; i; j++)
				x &#x3D; x * 10 + s[j] - &#39;0&#39;;
			z.push_back(x);
		&#125;
		trim();
	&#125;

	friend std::istream&amp; operator&gt;&gt;(std::istream &amp;stream, bigint &amp;v) &#123;
		std::string s;
		stream &gt;&gt; s;
		v.read(s);
		return stream;
	&#125;

	friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const bigint &amp;v) &#123;
		if (v.sign &#x3D;&#x3D; -1)
			stream &lt;&lt; &#39;-&#39;;
		stream &lt;&lt; (v.z.empty() ? 0 : v.z.back());
		for (int i &#x3D; (int) v.z.size() - 2; i &gt;&#x3D; 0; --i)
			stream &lt;&lt; std::setw(base_digits) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; v.z[i];
		return stream;
	&#125;

	static std::vector&lt;int&gt; convert_base(const std::vector&lt;int&gt; &amp;a, int old_digits, int new_digits) &#123;
		std::vector&lt;long long&gt; p(std::max(old_digits, new_digits) + 1);
		p[0] &#x3D; 1;
		for (int i &#x3D; 1; i &lt; (int) p.size(); i++)
			p[i] &#x3D; p[i - 1] * 10;
		std::vector&lt;int&gt; res;
		long long cur &#x3D; 0;
		int cur_digits &#x3D; 0;
		for (int i &#x3D; 0; i &lt; (int) a.size(); i++) &#123;
			cur +&#x3D; a[i] * p[cur_digits];
			cur_digits +&#x3D; old_digits;
			while (cur_digits &gt;&#x3D; new_digits) &#123;
				res.push_back(int(cur % p[new_digits]));
				cur &#x2F;&#x3D; p[new_digits];
				cur_digits -&#x3D; new_digits;
			&#125;
		&#125;
		res.push_back((int) cur);
		while (!res.empty() &amp;&amp; res.back() &#x3D;&#x3D; 0)
			res.pop_back();
		return res;
	&#125;

	typedef std::vector&lt;long long&gt; vll;

	static vll karatsubaMultiply(const vll &amp;a, const vll &amp;b) &#123;
		int n &#x3D; a.size();
		vll res(n + n);
		if (n &lt;&#x3D; 32) &#123;
			for (int i &#x3D; 0; i &lt; n; i++)
				for (int j &#x3D; 0; j &lt; n; j++)
					res[i + j] +&#x3D; a[i] * b[j];
			return res;
		&#125;

		int k &#x3D; n &gt;&gt; 1;
		vll a1(a.begin(), a.begin() + k);
		vll a2(a.begin() + k, a.end());
		vll b1(b.begin(), b.begin() + k);
		vll b2(b.begin() + k, b.end());

		vll a1b1 &#x3D; karatsubaMultiply(a1, b1);
		vll a2b2 &#x3D; karatsubaMultiply(a2, b2);

		for (int i &#x3D; 0; i &lt; k; i++)
			a2[i] +&#x3D; a1[i];
		for (int i &#x3D; 0; i &lt; k; i++)
			b2[i] +&#x3D; b1[i];

		vll r &#x3D; karatsubaMultiply(a2, b2);
		for (int i &#x3D; 0; i &lt; (int) a1b1.size(); i++)
			r[i] -&#x3D; a1b1[i];
		for (int i &#x3D; 0; i &lt; (int) a2b2.size(); i++)
			r[i] -&#x3D; a2b2[i];

		for (int i &#x3D; 0; i &lt; (int) r.size(); i++)
			res[i + k] +&#x3D; r[i];
		for (int i &#x3D; 0; i &lt; (int) a1b1.size(); i++)
			res[i] +&#x3D; a1b1[i];
		for (int i &#x3D; 0; i &lt; (int) a2b2.size(); i++)
			res[i + n] +&#x3D; a2b2[i];
		return res;
	&#125;

	bigint operator*(const bigint &amp;v) const &#123;
		std::vector&lt;int&gt; a6 &#x3D; convert_base(this-&gt;z, base_digits, 6);
		std::vector&lt;int&gt; b6 &#x3D; convert_base(v.z, base_digits, 6);
		vll a(a6.begin(), a6.end());
		vll b(b6.begin(), b6.end());
		while (a.size() &lt; b.size())
			a.push_back(0);
		while (b.size() &lt; a.size())
			b.push_back(0);
		while (a.size() &amp; (a.size() - 1))
			a.push_back(0), b.push_back(0);
		vll c &#x3D; karatsubaMultiply(a, b);
		bigint res;
		res.sign &#x3D; sign * v.sign;
		for (int i &#x3D; 0, carry &#x3D; 0; i &lt; (int) c.size(); i++) &#123;
			long long cur &#x3D; c[i] + carry;
			res.z.push_back((int) (cur % 1000000));
			carry &#x3D; (int) (cur &#x2F; 1000000);
		&#125;
		res.z &#x3D; convert_base(res.z, 6, base_digits);
		res.trim();
		return res;
	&#125;
&#125;;

int main() &#123;
    bigint a,b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a + b &lt;&lt; endl;
    cout &lt;&lt; a - b &lt;&lt; endl;
    cout &lt;&lt; a * b &lt;&lt; endl;
    cout &lt;&lt; a &#x2F; b &lt;&lt; endl;
    cout &lt;&lt; a % b &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><blockquote>
<p><strong>默认大根堆：</strong> $priority$_$queue\lt int \gt heap$，堆顶元素是最大的；</p>
</blockquote>
<p><mark>排序：</mark></p>
<p><strong>一、$priority$_$queue$ 自带排序方式：</strong></p>
<ol>
<li>默认是大根堆（堆顶元素是最大的），等价于下面写法：</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; heap;</code></pre>

<ol start="2">
<li>小根堆实现方式：</li>
</ol>
<pre class="language-c++" data-language="c++"><code class="language-c++">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;</code></pre>

<p><strong>二、$priority$_$queue$ 自定义排序方式：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Node
&#123;
    int x,y;
&#125;;

struct cmp
&#123;
    bool operator()(Node a, Node b) &#123; &#x2F;&#x2F; 返回true表示a的优先级小于b的优先级
        if (a.x &#x3D;&#x3D; b.x) return a.y &lt; b.y;
        return a.x &lt; b.x;
    &#125;
&#125;;
priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; heap;</code></pre>

<p><strong>测试代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;

struct Node
&#123;
    int x,y;
&#125;;

struct cmp
&#123;
    bool operator()(Node a, Node b) &#123; &#x2F;&#x2F; 返回true表示a的优先级小于b的优先级
        if (a.x &#x3D;&#x3D; b.x) return a.y &lt; b.y;
        return a.x &lt; b.x;
    &#125;
&#125;;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; heap;
    for (int i &#x3D; 1; i &lt; 10; i++)
    &#123;
        heap.push(&#123;rnd(10), rnd(10)&#125;);
    &#125;

    while (heap.size())
    &#123;
        auto t &#x3D; heap.top();
        heap.pop();
        cout &lt;&lt; t.x &lt;&lt; &quot; &quot; &lt;&lt; t.y &lt;&lt; &#39;\n&#39;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>$2023$ 蓝桥杯真题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4964/">整数删除</a></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>一、 $map$ 默认排序方式：</strong></p>
<p>1、默认按 $key$ 从小到大排序，等价于：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">map&lt;int, int, less&lt;int&gt;&gt; mp;</code></pre>

<p>2、若想按照 $key$ 从大到小排序，则实现代码如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">map&lt;int, int, greater&lt;int&gt;&gt; mp;</code></pre>

<p><strong>二、$map$ 自定义 $key$ 排序：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct cmp
&#123;
    bool operator() (string const &amp;a, string const &amp;b) const &#123;
        if (a.size() !&#x3D; b.size())   return a.size() &lt; b.size();
        return a &lt; b;
    &#125;
&#125;;
map&lt;string, int, cmp&gt; mp;</code></pre>

<p><strong>测试代码如下</strong>（<strong>注：</strong>如果只按 $a.size() &lt; b.size()$ 排序会对字符串的长度判重！）：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

struct cmp
&#123;
    bool operator() (const string &amp;a, const string &amp;b) const &#123;
        if (a.size() !&#x3D; b.size())   return a.size() &lt; b.size();
        return a &lt; b;
    &#125;
&#125;;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    map&lt;string, int, cmp&gt; mp;
    mp[&quot;1&quot;] &#x3D; 2;
    mp[&quot;12&quot;] &#x3D; 3;
    mp[&quot;13&quot;] &#x3D; 1;
    mp[&quot;sas&quot;] &#x3D; 2;
    mp[&quot;sas&quot;] &#x3D; 3;
    mp[&quot;sa2s&quot;] &#x3D; 2;
    mp[&quot;as&quot;] &#x3D; 3;
    cout &lt;&lt; mp.size() &lt;&lt; &quot;\n&quot;;

    for (auto [x, y] : mp)
        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p>有很多类型的题目，需要用：$map&lt;int, vector&gt; mp;$ 这种方式配合优化算法时间复杂度，比如：</p>
<p><strong>div2 D𝑑𝑖𝑣2 𝐷 经典括号序列（这题 map𝑚𝑎𝑝 并不是很亮点，最大亮点是优化）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1976/problem/D">D. Invertible Bracket Sequences</a></p>
<h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p><strong>删除元素：</strong></p>
<ul>
<li>$erase(x)$ 函数：删除集合中所有 $x$ 的值；<ul>
<li>$erase(S.find(x))$：删除集合中第一个 $x$ 的值（就是仅删除 $1$ 个 $x$）；</li>
</ul>
</li>
</ul>
<p><mark>推荐题单：</mark></p>
<p><strong>从多重集中删除一个元素：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1883/problem/D">D. In Love</a></p>
<p><strong>$2023CCPC$ 桂林银牌模拟贪心题（$multiset + map$）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/B">B. The Game</a></p>
<p><strong>蓝桥杯 20242024 省赛最后一题（multiset𝑚𝑢𝑙𝑡𝑖𝑠𝑒𝑡 优化）：</strong><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/problem3214.html">拔河</a></p>
<p><strong>百度之星第三题（离散化 + 差分，map实现）：</strong><a target="_blank" rel="noopener" href="https://www.matiji.net/exam/brushquestion/18/4498/F16DA07A4D99E21DFFEF46BD18FF68AD">BD202418激光控制器</a></p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><blockquote>
<p>__builtin_popcount(x)；&#x2F;&#x2F; x 二进制中 1 的个数（$x$ 为 $unsigned\ int$ 类型）</p>
<p>__builtin_popcountll(x)；&#x2F;&#x2F; x 二进制中 1 的个数（$x$ 为 $unsigned\ long\ long$ 类型）</p>
<br>

<p>__builtin_parity(x)；&#x2F;&#x2F; $x$ 二进制中 $1$ 的个数的奇偶性（$x$ 为 $unsigned\ int$ 类型）</p>
<p>__builtin_parityll(x)；&#x2F;&#x2F; $x$ 二进制中 $1$ 的个数的奇偶性（$x$ 为 $unsigned\ long\ long$ 类型）</p>
<br>

<p>__builtin_ctz(2)；&#x2F;&#x2F; $x$ 末尾 $0$ 的个数（$x$ 为 $unsigned\ int$ 类型）</p>
<p>__builtin_ctzll(4)；&#x2F;&#x2F; $x$ 末尾 $0$ 的个数（$x$ 为 $unsigned\ long\ long$ 类型）</p>
<br>

<p>__builtin_clz(3)；&#x2F;&#x2F; $x$ 开头 $0$ 的个数（$x$ 为 $unsigned\ int$ 类型）</p>
<p>__builtin_clzll(3)；&#x2F;&#x2F; $x$ 开头 $0$ 的个数（$x$ 为 $unsigned\ long\ long$ 类型）</p>
<br>

<p>31 - __builtin_clz(x) &#x3D; log2(x)；&#x2F;&#x2F;如果没有log2函数，可以用前面的公式获取其log2向下取整（log2 函数有bug，当 $x$ 为 $562949953421311$ ，答案应该是 $48$，但函数输出却是 $49$。），因此求 $\lfloor log2(x)\rfloor$ 应使用：<mark>$ __bit_width(i) - 1$</mark>.</p>
<p><strong>时间复杂度：</strong>$O(1)$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cout &lt;&lt; __builtin_popcount(3) &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; __builtin_popcountll(2) &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; __builtin_parity(3) &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; __builtin_parityll(2) &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; __builtin_ctz(2) &lt;&lt; &quot;\n&quot;;&#x2F;&#x2F; x 末尾 0 的个数
    cout &lt;&lt; __builtin_ctzll(4) &lt;&lt; &quot;\n&quot;;
    cout &lt;&lt; __builtin_clz(3) &lt;&lt; &quot;\n&quot;;&#x2F;&#x2F; x 开头 0 的个数
    cout &lt;&lt; __builtin_clzll(3) &lt;&lt; &quot;\n&quot;;

    cout &lt;&lt; log2(4) &lt;&lt; &quot; &quot; &lt;&lt; 31 - __builtin_clz(4);
    return 0;
&#125;</code></pre>

<blockquote>
<p>$bitset$&lt;$N$&gt; $b$；&#x2F;&#x2F;N为常数</p>
<p>$b[i] &#x3D; 1$;&#x2F;&#x2F;可以直接通过数组赋值</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    bitset&lt;1000&gt; b;
    b[1] &#x3D; 1;
    b[2] &#x3D; 0;
    b[3] &#x3D; 1;
    cout &lt;&lt; b[1] &lt;&lt; &quot; &quot; &lt;&lt; b[2] &lt;&lt; &quot; &quot; &lt;&lt; b[3];
    return 0;
&#125;</code></pre>



<blockquote>
<p><strong>常用函数：</strong></p>
<p>$b.any() $</p>
<p>$b.none()$</p>
<p>$b.count()$</p>
<p><strong>时间复杂度：</strong>$O(\frac{n}{w})$，$w$ 一般为 $64$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bitset&lt;1000&gt; b;
cout &lt;&lt; b.any() &lt;&lt; &quot;\n&quot;;
cout &lt;&lt; b.none() &lt;&lt; &#39;\n&#39;;
b[1] &#x3D; 1;
cout &lt;&lt; b.count() &lt;&lt; &quot;\n&quot;;</code></pre>



<blockquote>
<p><strong>位运算：</strong></p>
<p>&amp; , | , ^ , ~ , &lt;&lt; , &gt;&gt;</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bitset&lt;32&gt; a,b;
a[1] &#x3D; 1;
b[2] &#x3D; 1;
a &#x3D; a | b;
a &#x3D; a &lt;&lt; 2;
cout &lt;&lt; a.to_string();</code></pre>



<blockquote>
<p>$a.set(x)$ &#x2F;&#x2F;将 $x$ 位赋值为 $1$</p>
<p>$a.set()$ &#x2F;&#x2F;将每一位都赋值为 $1$</p>
<p>$a.reset(x)$ &#x2F;&#x2F;将 $x$ 位赋值为 $0$</p>
<p>$a.reset()$ &#x2F;&#x2F;将每一位都赋值为 $0$</p>
<p>$a.flip(x)$ &#x2F;&#x2F;将 $x$ 位翻转（即 $0$ 变 $1$，$1$ 变 $0$）</p>
<p>$a.flip()$ &#x2F;&#x2F;将每一位都翻转</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bitset&lt;32&gt; a,b;
a.set(2);
a.set();
cout &lt;&lt; a.to_string() &lt;&lt; &quot;\n&quot;;
a.reset(1);
a.reset();
cout &lt;&lt; a.to_string() &lt;&lt; &quot;\n&quot;;</code></pre>



<blockquote>
<p>$a.to$_$string()$ &#x2F;&#x2F;将 $bitset$ 用字符串的形式输出</p>
<p>$bitset$&lt;$64$&gt; $b(s)$ &#x2F;&#x2F;把字符串当成参数，放入 $bitset$ 中</p>
<p>$a.to$_$ullong()$ &#x2F;&#x2F;返回 $bitset$ 对应的 $unsigned\ long\ long$ 数值</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">string s &#x3D; &quot;1011&quot;;
bitset&lt;64&gt; b(s);
cout &lt;&lt; b.to_string() &lt;&lt; &#39;\n&#39;;
cout &lt;&lt; b.to_ullong() &lt;&lt; &quot;\n&quot;;</code></pre>



<blockquote>
<p>$a$._Find_first()；从低位开始找第一个等于 $1$ 的位置</p>
<p>a._Find_next(i)；从 $i$ 后面找第一个等于 $1$ 的位置，找不到就返回 $a.size()$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bitset&lt;32&gt; a,b;
for(int i &#x3D; a._Find_first();i !&#x3D; a.size();i &#x3D; a._Find_next(i))
&#123;
	cout &lt;&lt; i &lt;&lt; &quot; &quot;;
&#125;</code></pre>



<blockquote>
<p>auto pa &#x3D; (unsigned long long*)&a;</p>
<p>解释：$0$ ~ $63$ 为低位置，$64$ ~ $127$ 为下一位置，$\cdots$</p>
<p>因此：$pa[0]$ 即为低 $64$ 位的无符号整型数，$pa[1]$ 为 $64$ ~ $127$ 位的无符号整型数，$\cdots$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bitset&lt;1280&gt; a,b;
a[2] &#x3D; 1;
auto pa &#x3D; (unsigned long long*)&a;
a[65] &#x3D; 1;
cout &lt;&lt; pa[0] &lt;&lt; &quot; &quot; &lt;&lt; pa[1];</code></pre>

<p><mark>推荐题单：</mark></p>
<p>**$bitset$ 优化常数： ** <a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/contest/problem?cid=1095&pid=1007">foreverlasting and fried-chicken</a></p>
<p><strong>$div3\ E$ （正解并不是 $bitset$，但可以卡过去，算是可以练习下 $bitset$ 叭）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1955/problem/E">E. Long Inversions</a></p>
<p><strong>20242024 西安邀请赛金牌题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10554">ICPC2024 Xi’an I] Turn Off The Lights</a></p>
<p><mark>foreverlasting and fried-chicken 代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1010,mod &#x3D; 1000000007;

ll C2[N],C4[N];

void init()
&#123;
    for(ll i &#x3D; 4;i &lt; N;i++)
        C4[i] &#x3D; (i * (i - 3) * (i - 2) * (i - 1) &#x2F; 24) % mod;

    for(ll i &#x3D; 2;i &lt; N;i++)
        C2[i] &#x3D; (i * (i - 1) &#x2F; 2) % mod;
&#125;

void solve()
&#123;
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    bitset&lt;1100&gt; bit[1100];
    while(m--)
    &#123;
        int a,b;
        cin &gt;&gt; a &gt;&gt; b;
        bit[a][b] &#x3D; bit[b][a] &#x3D; 1;
    &#125;

    ll res&#x3D;0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; i+1; j &lt;&#x3D; n; j++)
        &#123;
            ll cnt &#x3D; (bit[i] &amp; bit[j]).count();
            int t &#x3D; bit[i][j];
            if(cnt &lt; 4 || t + cnt &lt; 4) continue;
            res &#x3D; (res + C4[cnt] * (C2[bit[i].count() - 4 - t] + C2[bit[j].count() - 4 - t]) % mod) % mod;
        &#125;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    
    init();
    
    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">重生带我走</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://318471543.github.io/2024/10/08/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">https://318471543.github.io/2024/10/08/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">重生带我走</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">基础算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/08/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="好题精选">
                        
                        <span class="card-title">好题精选</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                        <span class="chip bg-color">好题精选</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/08/%E5%9B%BE%E8%AE%BA/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="图论">
                        
                        <span class="card-title">图论</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9B%BE%E8%AE%BA/">
                        <span class="chip bg-color">图论</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">重生带我走</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/318471543" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:318471543@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=318471543" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 318471543" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5545924159" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5545924159" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/shen-mu-yi-35" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/shen-mu-yi-35" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
