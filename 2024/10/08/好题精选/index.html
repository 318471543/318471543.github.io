<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="好题精选, 重生带我走">
    <meta name="description" content="根据数据范围，探索写法题单推荐：

三角形重心
C. Vampiric Powers, anyone?

讲解——三角形重心：题意：给了 $n$ 个点，问是否有 $2$ 个三角形，满足重心相等。即重心为$(\frac{x_1 + x_2 +">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>好题精选 | 重生带我走</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">重生带我走</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">重生带我走</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">好题精选</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                                <span class="chip bg-color">好题精选</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="根据数据范围，探索写法"><a href="#根据数据范围，探索写法" class="headerlink" title="根据数据范围，探索写法"></a>根据数据范围，探索写法</h2><p><mark>题单推荐：</mark></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/60254/F">三角形重心</a></li>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1847/problem/C">C. Vampiric Powers, anyone?</a></li>
</ul>
<h3 id="讲解——三角形重心："><a href="#讲解——三角形重心：" class="headerlink" title="讲解——三角形重心："></a>讲解——三角形重心：</h3><p><strong>题意：</strong>给了 $n$ 个点，问是否有 $2$ 个三角形，满足重心相等。即重心为$(\frac{x_1 + x_2 + x_3}{3},\frac{y_1 + y_2 + y_3}{3})$ 。如果找到的话，请输出对应三角形三点的下标。</p>
<p><strong>数据范围：</strong>$ 1 \le n\le 10^5, -1000 \le x_i,y_i \le 1000$ 。</p>
<p><mark>思路：</mark> 单从 $n$ 的数据范围来看的话，很难做出来。但<strong>一定</strong>请注意到坐标的数据范围。这个数据范围可以 $O(n^2)$，因此可以进一步思考（需要一定的理论分析）：重心一共有 $10^6$ 个，虽然看着枚举三个点的时间复杂度很高，但是如果时间复杂度真的到了 $10^6$ 的时候，是不是答案已经出来了呢？（具体来讲，如果枚举的时间复杂度小于 $10^6$，那么时间够用，不用额外考虑；反正如果时间复杂度已经到了 $10^6$ 还没找到，那是不可能的，因为重心已经基本被遍历完一遍了，一定会出答案。 ）因此，这道题被很多人称为了“<strong>一眼丁真题</strong>”。</p>
<p><mark>参考代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

const int N &#x3D; 1e5 + 10;

int n;
pii a[N];
vector&lt;int&gt; v;
map&lt;int,vector&lt;int&gt;&gt; mp[6010];

void dfs(int cnt,int cur)
&#123;
    if(cnt &#x3D;&#x3D; 3)
    &#123;
        int x &#x3D; a[v[0]].first + a[v[1]].first + a[v[2]].first + 3000;
        int y &#x3D; a[v[0]].second + a[v[1]].second + a[v[2]].second + 3000;
        if(mp[x][y].size())
        &#123;
            cout &lt;&lt; &quot;YES\n&quot;;
            cout &lt;&lt; mp[x][y][0] &lt;&lt; &quot; &quot; &lt;&lt; mp[x][y][1] &lt;&lt; &quot; &quot; &lt;&lt; mp[x][y][2] &lt;&lt; &quot;\n&quot;;
            cout &lt;&lt; v[0] &lt;&lt; &quot; &quot; &lt;&lt; v[1] &lt;&lt; &quot; &quot; &lt;&lt; v[2] &lt;&lt; &quot;\n&quot;;
            exit(0);
        &#125;
        else    
        &#123;
            for(int i &#x3D; 0;i &lt; v.size();i++)
            &#123;
                mp[x][y].push_back(v[i]);
            &#125;
        &#125;
        return;
    &#125;

    for(int i &#x3D; cur;i &lt;&#x3D; n;i++)
    &#123;
        v.push_back(i);
        dfs(cnt + 1,i + 1);
        v.pop_back();
    &#125;
&#125;

int main()
&#123;
    IOS;
    cin &gt;&gt; n;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i].first &gt;&gt; a[i].second;

    dfs(0,1);

    cout &lt;&lt; &quot;NO&quot; &lt;&lt; &quot;\n&quot;;
    
    return 0;
&#125;</code></pre>

<h3 id="讲解——Vampiric-Powers-anyone-："><a href="#讲解——Vampiric-Powers-anyone-：" class="headerlink" title="讲解——Vampiric Powers, anyone?："></a>讲解——Vampiric Powers, anyone?：</h3><p><strong>题意转化：</strong>给 $n$ 个数和对应的 $a_i$ ，求 $1$ ~ $n$ 区间中连续异或的最大值是多少？（子段连续异或和的最大值）</p>
<p><strong>数据范围：</strong> $n \le 10^5$， $0 \le a_i &lt; 2^8$ 。</p>
<p><mark>清除误区：</mark> <strong>区间异或和的最大值不能用线段树做！</strong>因为类比区间连续子段和的最大值来说：最大值与最大值的和结果是最大值，但是异或的最大值和异或的最大值合起来（异或）不一定就是最大值了！</p>
<p><mark>思路1：</mark> 需要仔细看到数据范围是 $2^8$，即256，不要以为是 $2^{28}$！看到数值这么小，可以想到枚举数值，但可能有点不太好想怎么枚举数值（有点思维在里面）。这里就直接说结论了：每次存储当前所有的前缀，对于当下枚举到的前缀，我们枚举数值！（这里的数值是已经存在过的前缀异或值），这样的效果等价于 $sum[r]$ ^ $sum[l-1]$，其中 $sum[l - 1]$ 是要枚举的数值！，这样得到的就是所有的子区间的异或值，然后取个 $max$ 即可。</p>
<p><mark>思路2：</mark> 其实思路1是偏向于思维的，可能不太容易想到，trie这种数据结构可能会想被想到！如果理解了第一个思路的公式，那么显然，我们每次插入的就是前缀和，然后对于当前点进行询问即可。</p>
<p><mark>思路 1 参考代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

int main()
&#123;
    IOS;
    cf(_)
    &#123;
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; a(n + 1),sum(n + 1);
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i],sum[i] &#x3D; sum[i - 1] ^ a[i];

        map&lt;int,int&gt; mp;
        int res &#x3D; 0;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        &#123;
            res &#x3D; max(res,sum[i]);
            for(int j &#x3D; 0;j &lt; (1 &lt;&lt; 8);j++)
            &#123;
                if(mp.count(j)) res &#x3D; max(res,sum[i] ^ j); 
            &#125;
            mp[sum[i]]++;
        &#125;

        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>思路 2 参考代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10,M &#x3D; N * 8;

int n;
int a[N],sum[N];
int idx,son[M][2];

void insert(int x)
&#123;
    int p &#x3D; 0;
    for(int i &#x3D; 7;i &gt;&#x3D; 0;i--)
    &#123;
        int u &#x3D; x &gt;&gt; i &amp; 1;
        if(!son[p][u])  son[p][u] &#x3D; ++idx;
        p &#x3D; son[p][u];   
    &#125;
&#125;

int query(int x)
&#123;
    int p &#x3D; 0,res &#x3D; 0;
    for(int i &#x3D; 7;i &gt;&#x3D; 0;i--)
    &#123;
        int u &#x3D; x &gt;&gt; i &amp; 1;
        if(son[p][!u])   p &#x3D; son[p][u ^ 1],res &#x3D; res * 2 + !u;
        else    p &#x3D; son[p][u],res &#x3D; res * 2 + u;
    &#125;
    return res;
&#125;

void init()
&#123;
    for(int i &#x3D; 0;i &lt;&#x3D; idx;i++)
        for(int j &#x3D; 0;j &lt;&#x3D; 1;j++)
            son[i][j] &#x3D; 0;
    idx &#x3D; 0;
&#125;

void solve()
&#123;
    cin &gt;&gt; n;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i],sum[i] &#x3D; sum[i - 1] ^ a[i];

    init();

    int res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        insert(sum[i - 1]);
        int t &#x3D; query(sum[i]);
        res &#x3D; max(res,sum[i] ^ t);
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

<h3 id="暴力不行，但发现：字母种类只有26种！"><a href="#暴力不行，但发现：字母种类只有26种！" class="headerlink" title="暴力不行，但发现：字母种类只有26种！"></a>暴力不行，但发现：字母种类只有26种！</h3><p><strong>难度等级：</strong>$easy$</p>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104493/problem/K">K. Sam-Oh, the funny coach</a></p>
<blockquote>
<p>每个字符串都是递增的顺序，因此题目要求比较两两字符串对应下标相同的数量，只需要预处理出相同字符对应的区间，复杂度就可以从 $O(mq)$ 优化到 $O(26q)$。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

struct Seg
&#123;
	int l, r;
	char c;
&#125;;

void solve()
&#123;
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;

	vector&lt;vector&lt;char&gt;&gt; g(n + 1, vector&lt;char&gt;(m + 1));
	vector&lt;vector&lt;Seg&gt;&gt; ycl(n + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		for (int j &#x3D; 1; j &lt;&#x3D; m; j++)	cin &gt;&gt; g[i][j];
		int pos &#x3D; 1;
		for (int j &#x3D; 2; j &lt;&#x3D; m; j++)
		&#123;
			if (g[i][j] !&#x3D; g[i][j - 1])
			&#123;
				ycl[i].push_back(&#123;pos, j - 1, g[i][j - 1]&#125;);
				pos &#x3D; j;
			&#125;
		&#125;
		ycl[i].push_back(&#123;pos, m, g[i][m]&#125;);
	&#125;

	&#x2F;&#x2F; for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#x2F;&#x2F; 	for (auto [x, y, z] : ycl[i])
	&#x2F;&#x2F; 		cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; &quot;\n&quot;;
	int q;
	cin &gt;&gt; q;

	auto cal &#x3D; [&amp;](int x, int y) -&gt; void
	&#123;
		auto v1 &#x3D; ycl[x], v2 &#x3D; ycl[y];
		int i &#x3D; 0, j &#x3D; 0, n &#x3D; ycl[x].size(), m &#x3D; ycl[y].size();

		int res &#x3D; 0;
		while (i &lt; n &amp;&amp; j &lt; m)
		&#123;
			int to_r &#x3D; min(v1[i].r, v2[j].r);
			int to_l &#x3D; max(v1[i].l, v2[j].l);
			char c1 &#x3D; v1[i].c, c2 &#x3D; v2[j].c;
			if (c1 &#x3D;&#x3D; c2)	res +&#x3D; to_r - to_l + 1;
			&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; v1[i].r &lt;&lt; &quot; &quot; &lt;&lt; v2[j].r &lt;&lt; &quot;\n&quot;;
			if (v1[i].r &#x3D;&#x3D; v2[j].r)	i++, j++;
			else if (v1[i].r &lt; v2[j].r)	i++;
			else	j++;
		&#125;
		cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
	&#125;;

	while (q--)
	&#123;
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;

		cal(x, y);
	&#125;
	
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	solve();
	
	return 0;
&#125;</code></pre>

<h3 id="2023-哈尔滨-CCPC-签到题之数据范围诈骗题：M-Painter"><a href="#2023-哈尔滨-CCPC-签到题之数据范围诈骗题：M-Painter" class="headerlink" title="2023 哈尔滨 CCPC 签到题之数据范围诈骗题：M. Painter"></a>2023 哈尔滨 CCPC 签到题之数据范围诈骗题：<a target="_blank" rel="noopener" href="https://codeforces.com/gym/104813/problem/M">M. Painter</a></h3><p><strong>收藏原因：</strong>坐标值 $x_i,y_i \le 10^9$ 很大，但是数据范围的 $n$ 只有 $2000$，因此暴力枚举即可。</p>
<h2 id="经典永不过时"><a href="#经典永不过时" class="headerlink" title="经典永不过时"></a>经典永不过时</h2><h3 id="map-存直线：G-The-Morning-Star"><a href="#map-存直线：G-The-Morning-Star" class="headerlink" title="$map$ 存直线：G. The Morning Star"></a>$map$ 存直线：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1850/problem/G">G. The Morning Star</a></h3><p><strong>题意：</strong></p>
<p>​		给定 $n(n \le 10^5)$ 个点，问有多少个点对，在四条直线上。</p>
<p><strong>思路：</strong></p>
<p>​		对于每个点，根据直线方程： $y - y_0 &#x3D; k(x - x_0)$，即 $y &#x3D; kx + b$，可以确定这个点在哪四条直线上。用map存四条直线即可（$first$：$k$, $second$：$b$）。最后统计答案就是：对于一条 $\ge 2$ 的点数（假设为 $n$）的直线，对答案的贡献为 $n × (n - 1)$。</p>
<p><mark>代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

int main()
&#123;
    IOS;
    cf(_)
    &#123;
        int n;
        cin &gt;&gt; n;

        map&lt;pair&lt;int,int&gt;,ll&gt; mp;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        &#123;
            int x,y;
            cin &gt;&gt; x &gt;&gt; y;
            mp[&#123;0,y&#125;]++;
            mp[&#123;1,-x + y&#125;]++;
            mp[&#123;-2,x&#125;]++;    &#x2F;&#x2F;k不存在
            mp[&#123;-1,x + y&#125;]++;
        &#125;

        ll res &#x3D; 0;
        for(auto [x,y] : mp)
        &#123;
            if(y &gt; 1)	res +&#x3D; (y - 1) * y;
        &#125;

        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐类似题单：</mark></p>
<p><strong>预处理方式基本一样，但怎么枚举是重点，枚举方式决定了代码量的大小！：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1895/problem/C">C. Torn Lucky Ticket</a></p>
<p><strong>给定 $n$ 个点，求直线个数：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/78309/I">fumo 星</a></p>
<p><mark>$Torn\ Lucky\ Ticket$ 代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;string&gt; str(n + 1);
    map&lt;pii, int&gt; mp;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        cin &gt;&gt; str[i];
        int sum &#x3D; 0;
        for (auto c : str[i])  sum +&#x3D; c - &#39;0&#39;;
        mp[&#123;str[i].size(), sum&#125;]++; &#x2F;&#x2F; 预处理: 长度, 各数总和
    &#125;
    
    ll res &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        string s &#x3D; str[i];
        int len &#x3D; str[i].size();
        for (int k &#x3D; len; k &gt;&#x3D; (len + 1) &#x2F; 2; k--) &#x2F;&#x2F; 枚举将该串切割(作为左大串)
        &#123;
            int pre &#x3D; 0, suf &#x3D; 0;
            for (int p &#x3D; 0; p &lt; len; p++)
            &#123;
                if (p &lt; k)  pre +&#x3D; s[p] - &#39;0&#39;;
                else    suf +&#x3D; s[p] - &#39;0&#39;;
            &#125;
            if (pre &gt; suf)
            &#123;
                res +&#x3D; mp[&#123;2 * k - len, pre - suf&#125;];
            &#125;
        &#125;

        for (int k &#x3D; 1; k &lt; (len + 1) &#x2F; 2; k++) &#x2F;&#x2F; 作为右大串
        &#123;
            int pre &#x3D; 0, suf &#x3D; 0;
            for (int p &#x3D; 0; p &lt; len; p++)
            &#123;
                if (p &lt; k)  pre +&#x3D; s[p] - &#39;0&#39;;
                else    suf +&#x3D; s[p] - &#39;0&#39;;
            &#125;
            if (pre &lt; suf)
            &#123;
                res +&#x3D; mp[&#123;len - 2 * k, suf - pre&#125;];
            &#125;
        &#125;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<h3 id="药物合成之记忆化搜索：E-Nastya-and-Potions"><a href="#药物合成之记忆化搜索：E-Nastya-and-Potions" class="headerlink" title="药物合成之记忆化搜索：E. Nastya and Potions"></a>药物合成之记忆化搜索：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1851/problem/E">E. Nastya and Potions</a></h3><p><strong>题意：</strong></p>
<p>​		一个炼术师在炼药，一种药需要其他几种药物来合成获取或直接购买，问每个药物最少花多少钱？</p>
<p><strong>思路：</strong></p>
<p>​		记忆化搜索。一个药物需要其他药物合成获取，则递归获取其他药物，有根据题目要求，没有环的存在，所以记忆化搜索，递归子结点的情况，然后和购买取个 $min$ 即可。这题比较典吧，当时被给到了一个<mark>记忆化搜索</mark>的 $idea$，然后就会了，不过回过头来，自己想的话，怎样才能想到用这个算法呢？</p>
<p><mark>代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

int main()
&#123;
    IOS;
    cf(_)
    &#123;
        int n,k;
        cin &gt;&gt; n &gt;&gt; k;
    
        vector&lt;ll&gt; cost(n + 1);
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; cost[i];

        vector&lt;int&gt; f(n + 1,-1);
        for(int i &#x3D; 1,x;i &lt;&#x3D; k;i++)
        &#123;
            cin &gt;&gt; x;
            f[x] &#x3D; 0;
        &#125;

        vector&lt;vector&lt;int&gt;&gt; g(n + 1);
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        &#123;
            int cnt;
            cin &gt;&gt; cnt;
            if(!cnt)    continue;
            while(cnt--)
            &#123;
                int x;
                cin &gt;&gt; x;
                g[i].push_back(x);
            &#125;
        &#125;        
		&#x2F;&#x2F;记忆化搜索
        function&lt;ll(int)&gt; get &#x3D; [&amp;](int u) -&gt; ll
        &#123;
            if(f[u] !&#x3D; -1)  return f[u];

            if(g[u].size() &#x3D;&#x3D; 0)    return f[u] &#x3D; cost[u];

            ll res &#x3D; 0;
            for(auto v : g[u])
            &#123;
                res +&#x3D; get(v);
            &#125;

            return f[u] &#x3D; min(cost[u],res);
        &#125;;

        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cout &lt;&lt; get(i) &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    &#125;
    return 0;
&#125;</code></pre>

<h3 id="辗转相减：Puzzle-Square-Jam"><a href="#辗转相减：Puzzle-Square-Jam" class="headerlink" title="辗转相减：Puzzle: Square Jam"></a>辗转相减：<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57363/E">Puzzle: Square Jam</a></h3><p><strong>题目要求做法：</strong></p>
<p>​		将一个方格，每次用辗转相减法割去一个正方形，最终割法的方案（输出点的坐标和边长）。</p>
<p><strong>经典目的：</strong></p>
<p>​		比较典吧，但是做的比较少，需要对这类题有经验，提高对方格类型的题目的接受度。</p>
<p><strong>时间复杂度：</strong>$O(N)$</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

struct Point
&#123;
    int x,y,l;
&#125;;

void solve()
&#123;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    cout &lt;&lt; &quot;YES&quot; &lt;&lt; &quot;\n&quot;;
    vector&lt;Point&gt; v;
    function&lt;void(int, int, int, int)&gt; dfs &#x3D; [&amp;](int sx, int sy, int ex, int ey) -&gt; void
    &#123;
        int dx &#x3D; ex - sx, dy &#x3D; ey - sy;
        if(!dx &amp;&amp; !dy)  return ;
        v.push_back(&#123;sx, sy, min(dx, dy)&#125;);

        if(dx &#x3D;&#x3D; dy)    return;
        else if(dx &lt; dy)    dfs(sx, sy + dx, ex, ey);
        else    dfs(sx + dy, sy, ex, ey);
    &#125;;

    dfs(0, 0, n, m);
    cout &lt;&lt; v.size() &lt;&lt; &quot;\n&quot;;
    for(auto x : v) cout &lt;&lt; x.x &lt;&lt; &quot; &quot; &lt;&lt; x.y &lt;&lt; &quot; &quot; &lt;&lt; x.l &lt;&lt; &quot;\n&quot;;
&#125;


int main()
&#123;
    IOS;
    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>比较难读懂的题目（但感觉还好）：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/65439/B">Mask Allocation</a></p>
<h3 id="二维矩阵判环：同色环"><a href="#二维矩阵判环：同色环" class="headerlink" title="二维矩阵判环：同色环"></a>二维矩阵判环：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5148/">同色环</a></h3><p><strong>题意：</strong></p>
<p>​		问 $n × m$ 的地图中，相同颜色的连通块是否有环？</p>
<p><strong>解析：</strong></p>
<p>​		其实挺经典的吧，但当时做的时候 $1$ 个小时没写出来。。。明明挺简单的，建议多练，此外这题还有一个<strong>并查集</strong>的做法，建议思考出来！</p>
<p><mark> $dfs$ 解法：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;char&gt;&gt; g(n + 1, vector&lt;char&gt;(m + 1));

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
            cin &gt;&gt; g[i][j];

    int dx[] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[] &#x3D; &#123;0, 1, 0, -1&#125;;
    vector&lt;vector&lt;bool&gt;&gt; st(n + 1, vector&lt;bool&gt;(m + 1));
    function&lt;bool(int, int, int)&gt; dfs &#x3D; [&amp;](int x, int y, int fa) -&gt; bool
    &#123;
        st[x][y] &#x3D; true;
        for (int i &#x3D; 0; i &lt; 4; i++)
        &#123;
            if ((i ^ 2) &#x3D;&#x3D; fa)  continue;
            int nx &#x3D; x + dx[i], ny &#x3D; y + dy[i];
            if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m)   continue;
            if (g[nx][ny] !&#x3D; g[x][y])   continue;
            if (st[nx][ny]) return true;
            if(dfs(nx, ny, i))   return true;
        &#125;
        return false;
    &#125;;

    bool ok &#x3D; false;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
            if (!st[i][j])
                if (dfs(i, j, -1))
                    ok &#x3D; true;

    cout &lt;&lt; (ok ? &quot;Yes\n&quot; : &quot;No\n&quot;);
    return 0;
&#125;</code></pre>

<h3 id="转换为环的思想：D-Cyclic-Operations"><a href="#转换为环的思想：D-Cyclic-Operations" class="headerlink" title="转换为环的思想：D. Cyclic Operations"></a>转换为环的思想：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1867/problem/D">D. Cyclic Operations</a></h3><p>期待真正理解后，写下深刻的认识。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;int&gt; b(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; b[i];

    if (k &#x3D;&#x3D; 1)
    &#123;
        vector&lt;int&gt; a(n + 1);
        iota(a.begin(), a.end(), 0);
        if (a &#x3D;&#x3D; b) return cout &lt;&lt; &quot;YES\n&quot;, void();
        else    return cout &lt;&lt; &quot;NO\n&quot;, void();
    &#125;

    vector&lt;vector&lt;int&gt;&gt; g(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        g[i].push_back(b[i]);

    vector&lt;int&gt; st(n + 1);
    vector&lt;int&gt; fa(n + 1);
    bool ok &#x3D; true;
    function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
    &#123;
        st[u] &#x3D; 1;
        for (auto v : g[u])
        &#123;
            if (!st[v])
            &#123;
                fa[v] &#x3D; u;
                dfs(v);
            &#125;
            else if (st[v] &#x3D;&#x3D; 1)
            &#123;
                int cnt &#x3D; 1, x &#x3D; u;
                while (x !&#x3D; v)
                &#123;
                    cnt ++;
                    x &#x3D; fa[x];
                &#125;
                
                if (cnt !&#x3D; k)
                &#123;
                    ok &#x3D; false;
                &#125;
            &#125;
        &#125;
        st[u] &#x3D; 2;
    &#125;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        if (!st[i])
            dfs(i);

    return cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;), void();
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h3 id="几乎无限长字符串拼接-单调栈思想：C-Decreasing-String"><a href="#几乎无限长字符串拼接-单调栈思想：C-Decreasing-String" class="headerlink" title="几乎无限长字符串拼接 + 单调栈思想：C. Decreasing String"></a>几乎无限长字符串拼接 + 单调栈思想：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1886/problem/C#">C. Decreasing String</a></h3><blockquote>
<p><strong>思路：</strong></p>
<ul>
<li>二分 或 $O(n)$ 暴力先找到最终要找的位置；</li>
<li>如果字符串为：eea，即我们会因为 $e &lt; a$，而优先删去 $e$，但 $e$ 前面还有一个 $e$，因此需要一直向前处理，直到不能处理位置，即单调栈的思想！</li>
</ul>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        string s;
        cin &gt;&gt; s;

        int n &#x3D; s.size();

        ll k;
        cin &gt;&gt; k;
        vector&lt;ll&gt; sum(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    
            sum[i] &#x3D; n - i + 1;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            sum[i] +&#x3D; sum[i - 1];

        int l &#x3D; 0, r &#x3D; n;
        while (l &lt; r)
        &#123;
            int mid &#x3D; l + r + 1 &gt;&gt; 1;
            if (sum[mid] &lt;&#x3D; k)  l &#x3D; mid;
            else    r &#x3D; mid - 1;
        &#125;
        
        int del &#x3D; l - (sum[l] &#x3D;&#x3D; k ? : 0);
        
        k -&#x3D; sum[del];

        s &#x3D; &quot; &quot; + s;
        stack&lt;char&gt; stk;
        int num &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            if (stk.empty())
                stk.push(s[i]);
            else
            &#123;
                while (stk.size() &amp;&amp; stk.top() &gt; s[i] &amp;&amp; num &lt; del)
                    stk.pop(), num++;
                stk.push(s[i]);
            &#125;

        vector&lt;char&gt; v;
        while (!stk.empty())
        &#123;
            auto t &#x3D; stk.top();
            stk.pop();
            v.push_back(t);
        &#125;

        reverse(v.begin(), v.end());
        cout &lt;&lt; v[k - 1];
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>推荐题单：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1879/problem/D">D. Sum of XOR Functions</a></p>
<h3 id="一道似乎被众人堪称典的-dp-题目：E-Block-Sequence"><a href="#一道似乎被众人堪称典的-dp-题目：E-Block-Sequence" class="headerlink" title="一道似乎被众人堪称典的 $dp$ 题目：E. Block Sequence"></a><strong>一道似乎被众人堪称典的 $dp$ 题目：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1881/problem/E">E. Block Sequence</a></h3><blockquote>
<p>其实确实挺好想的，建议多想想，思路稍后写！</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    vector&lt;int&gt; dp(n + 1, 1e9);
    dp[0] &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (i + a[i] &lt;&#x3D; n)
        &#123;
            dp[i + a[i]] &#x3D; min(dp[i + a[i]], dp[i - 1]);
        &#125;
        dp[i] &#x3D; min(dp[i], dp[i - 1] + 1);
        
    &#125;

    cout &lt;&lt; dp[n] &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="码量者的题单"><a href="#码量者的题单" class="headerlink" title="码量者的题单"></a>码量者的题单</h2><h3 id="方格类题单"><a href="#方格类题单" class="headerlink" title="方格类题单"></a>方格类题单</h3><p><strong>简单入门题：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57363/E">Puzzle: Square Jam</a></p>
<p><strong>思维交互题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1934/problem/C">C. Find a Mine</a></p>
<p><strong>“蔚来杯”2022牛客暑期多校训练营4：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33189/H">Wall Builder II</a></p>
<p><strong>$2023$ 西安邀请赛银牌题：</strong><a target="_blank" rel="noopener" href="https://qoj.ac/contest/1291/problem/6746">E. Merge the Rectangles</a></p>
<p><strong>2023牛客暑期多校训练营4：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57358/H">Merge the squares!</a></p>
<p><strong>AtCoder Beginner Contest 322 D：</strong><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc322/tasks/abc322_d">D - Polyomino</a></p>
<p><mark>西安邀请赛银牌题（$by\ jinagly$）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    
    vector&lt;string&gt; a(n - 1), b(n);
    for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        cin &gt;&gt; b[i];
    &#125;
    
    vector fa(n, std::vector&lt;int&gt;(m + 1)); &#x2F;&#x2F;从网格中的第 i 行、第 j 列的单元格出发，向右延伸（水平方向）直到遇到一个不满足特定条件的单元格的位置
    vector fb(n + 1, std::vector&lt;int&gt;(m)); &#x2F;&#x2F;从网格中的第 i 行、第 j 列的单元格出发，向下延伸（垂直方向）直到遇到一个不满足特定条件的单元格的位置
    for (int i &#x3D; 1; i &lt; n; i++) &#123;
        for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) &#123;
            fa[i][j] &#x3D; (j &lt; m - 1 &amp;&amp; a[i - 1][j] &#x3D;&#x3D; a[i - 1][j + 1]) ? fa[i][j + 1] : j + 1;
        &#125;
    &#125;
    for (int i &#x3D; 1; i &lt; m; i++) &#123;
        for (int j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#123;
            fb[j][i] &#x3D; (j &lt; n - 1 &amp;&amp; b[j][i - 1] &#x3D;&#x3D; b[j + 1][i - 1]) ? fb[j + 1][i] : j + 1;
        &#125;
    &#125;
    
    auto solve &#x3D; [&amp;](auto self, int u, int d, int l, int r) -&gt; bool &#123;
        int len &#x3D; std::max(d - u, r - l);
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            if (u + i &lt; d &amp;&amp; a[u + i - 1][l] &#x3D;&#x3D; &#39;1&#39; &amp;&amp; fa[u + i][l] &gt;&#x3D; r) &#123; &#x2F;&#x2F; 水平切一刀
                return self(self, u, u + i, l, r) &amp;&amp; self(self, u + i, d, l, r);
            &#125;
            if (l + i &lt; r &amp;&amp; b[u][l + i - 1] &#x3D;&#x3D; &#39;1&#39; &amp;&amp; fb[u][l + i] &gt;&#x3D; d) &#123; &#x2F;&#x2F; 竖直切一刀
                return self(self, u, d, l, l + i) &amp;&amp; self(self, u, d, l + i, r);
            &#125;
        &#125;
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            if (u + i &lt; d &amp;&amp; (a[u + i - 1][l] &#x3D;&#x3D; &#39;1&#39; || fa[u + i][l] &lt; r)) &#123; &#x2F;&#x2F; 水平判断
                return false;
            &#125;
            if (l + i &lt; r &amp;&amp; (b[u][l + i - 1] &#x3D;&#x3D; &#39;1&#39; || fb[u][l + i] &lt; d)) &#123; &#x2F;&#x2F; 竖直判断
                return false;
            &#125;
        &#125;
        return true;
    &#125;;
    cout &lt;&lt; (solve(solve, 0, n, 0, m) ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;
    
    return 0;
&#125;</code></pre>

<p><mark>AtCoder Beginner Contest 322 D：</mark></p>
<blockquote>
<p><strong>思路：</strong></p>
<ul>
<li><strong>暴力旋转平移：</strong><ul>
<li>rotate函数：将 $n×n$ 的矩阵逆时针旋转公式：$s[i][j] &#x3D; s[3 - j][i]$ （即 $da,db,dc$ 循环）</li>
<li>区间：$[-3, 3]$ 是用来进行平移操作的（即 $dxa,dya,dxb,dyb,dxc,dyc$ 循环）</li>
</ul>
</li>
<li><strong>时间复杂度：</strong>$O(4^3×7^6)$</li>
</ul>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    array&lt;string, 4&gt; a, b, c;
    for (int i &#x3D; 0; i &lt; 4;i ++) cin &gt;&gt; a[i];
    for (int i &#x3D; 0; i &lt; 4;i ++) cin &gt;&gt; b[i];
    for (int i &#x3D; 0; i &lt; 4;i ++) cin &gt;&gt; c[i];

    auto rotate &#x3D; [&amp;](array&lt;string, 4&gt;&amp; s) -&gt; void
    &#123;
        array&lt;string, 4&gt; t;
        for (int i &#x3D; 0; i &lt; 4; i++)
            for (int j &#x3D; 0; j &lt; 4; j++)
                t[3 - j] +&#x3D; s[i][j];
        s &#x3D; t;
    &#125;;

    for (int da &#x3D; 0; da &lt; 4; da++)
    &#123;
        for (int db &#x3D; 0; db &lt; 4; db++)
        &#123;
            for (int dc &#x3D; 0; dc &lt; 4; dc++)
            &#123;
                for (int dxa &#x3D; -3; dxa &lt;&#x3D; 3; dxa++)
                &#123;
                    for (int dya &#x3D; -3; dya &lt;&#x3D; 3; dya++)
                    &#123;
                        for (int dxb &#x3D; -3; dxb &lt;&#x3D; 3; dxb++)
                        &#123;
                            for (int dyb &#x3D; -3; dyb &lt;&#x3D; 3; dyb++)
                            &#123;
                                for (int dxc &#x3D; -3; dxc &lt;&#x3D; 3; dxc++)
                                &#123;
                                    for (int dyc &#x3D; -3; dyc &lt;&#x3D; 3; dyc++)
                                    &#123;
                                        array&lt;string, 4&gt; s;
                                        s.fill(&quot;----&quot;);
                                        bool ok &#x3D; true;
                                        auto cover &#x3D; [&amp;](array&lt;string, 4&gt;&amp; t, int dx, int dy) -&gt; void
                                        &#123;
                                            for (int i &#x3D; 0; i &lt; 4; i++)
                                                for (int j &#x3D; 0; j &lt; 4; j++)
                                                &#123;
                                                    int nx &#x3D; i + dx, ny &#x3D; j + dy;
                                                    if (t[i][j] &#x3D;&#x3D; &#39;#&#39;)
                                                    &#123;
                                                        if (nx &lt; 0 || nx &gt;&#x3D; 4 || ny &lt; 0 || ny &gt;&#x3D; 4 || s[nx][ny] &#x3D;&#x3D; &#39;#&#39;)
                                                        &#123;
                                                            ok &#x3D; false;
                                                        &#125;
                                                        else    s[nx][ny] &#x3D; &#39;#&#39;;
                                                    &#125;
                                                &#125;
                                        &#125;;

                                        cover(a, dxa, dya);
                                        cover(b, dxb, dyb);
                                        cover(c, dxc, dyc);

                                        for (int i &#x3D; 0; i &lt; 4; i++)
                                        &#123;
                                            if (s[i] !&#x3D; &quot;####&quot;) 
                                                ok &#x3D; false;
                                        &#125;
                                        if (ok)
                                        &#123;
                                            return cout &lt;&lt; &quot;Yes\n&quot;,0;
                                        &#125;
                                    &#125;
                                &#125;
                            &#125;
                        &#125;
                    &#125;
                &#125;
                rotate(c);
            &#125;
            rotate(b);
        &#125;
        rotate(a);
    &#125;

    cout &lt;&lt; &quot;No\n&quot;;
    return 0;
&#125;</code></pre>

<h3 id="练习图论码力"><a href="#练习图论码力" class="headerlink" title="练习图论码力"></a>练习图论码力</h3><p><mark>题单放送：</mark></p>
<ul>
<li><strong>tarjan缩点 + DP：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2656">P2656 采蘑菇</a></li>
<li><strong>tarjan缩点（不易被看出） + DP：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2515">P2515 [HAOI2010] 软件安装</a></li>
</ul>
<p><mark>采蘑菇：</mark></p>
<p>这题卡精度，会丢失40分！</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;

struct Node
&#123;
    int v, w, rate;
&#125;;


int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    
    vector&lt;vector&lt;Node&gt;&gt; g(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int u, v, w;
        double p;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; p;
        g[u].push_back(&#123;v, w, (int)(p * 10)&#125;);
    &#125;

    vector&lt;int&gt; dfn(n + 1), low(n + 1), stk(n + 1), id(n + 1), sz(n + 1);
    vector&lt;bool&gt; in_stk(n + 1);
    int top &#x3D; 0, timestamp &#x3D; 0, scc_cnt &#x3D; 0;
    function&lt;void(int u)&gt; tarjan &#x3D; [&amp;](int u) -&gt; void
    &#123;
        dfn[u] &#x3D; low[u] &#x3D; ++timestamp;
        stk[++top] &#x3D; u, in_stk[u] &#x3D; true;
        for (auto [v, w, p] : g[u])
        &#123;
            if (!dfn[v])
            &#123;
                tarjan(v);
                low[u] &#x3D; min(low[u], low[v]);
            &#125;
            else if (in_stk[v]) low[u] &#x3D; min(low[u], dfn[v]);
        &#125;

        if (dfn[u] &#x3D;&#x3D; low[u])
        &#123;
            ++scc_cnt;
            int y;
            do
            &#123;
                y &#x3D; stk[top--];
                in_stk[y] &#x3D; false;
                id[y] &#x3D; scc_cnt;
                sz[scc_cnt]++;
            &#125; while (y !&#x3D; u);
            
        &#125;
    &#125;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        if (!dfn[i])
            tarjan(i);

    int st;
    cin &gt;&gt; st;

    &#x2F;&#x2F; 建新图
    vector&lt;int&gt; f(n + 1);
    vector&lt;vector&lt;pii&gt;&gt; new_g(scc_cnt + 1);
    for (int u &#x3D; 1; u &lt;&#x3D; n; u++)
    &#123;
        for (auto [v, w, p] : g[u])
        &#123;
            if (id[u] &#x3D;&#x3D; id[v]) &#x2F;&#x2F; 同一连通块
            &#123;
                while (w)
                &#123;
                    f[id[u]] +&#x3D; w;
                    w &#x3D; w * p &#x2F; 10;
                &#125;
            &#125;
            else
            &#123;
                new_g[id[u]].push_back(&#123;id[v], w&#125;);
            &#125;
        &#125;
    &#125;

    vector&lt;int&gt; dp(scc_cnt + 1);
    for (int i &#x3D; id[st]; i &gt;&#x3D; 1; i--)
    &#123;
        dp[i] &#x3D; max(dp[i], f[i]);
        for (auto [v, w] : new_g[i])
        &#123;
            dp[v] &#x3D; max(dp[v], dp[i] + f[v] + w);
        &#125;
    &#125;

    cout &lt;&lt; *max_element(dp.begin(), dp.end()) &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>软件安装：</mark></p>
<p>易错点：</p>
<ul>
<li>想的太简单了，以为是一个树，实际不是！（会形成环）</li>
<li>对于没有依赖的点，不能直接用 $0$ 来建图，因为可能之间给你一个连通图，这样就会出错！（感谢讨论区的大哥探路qwq）</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; v(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; v[i];

    vector&lt;int&gt; w(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; w[i];

    vector&lt;vector&lt;int&gt;&gt; g(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int p;
        cin &gt;&gt; p;
        if (p)  g[p].push_back(i);
    &#125;

    vector&lt;int&gt; dfn(n + 1), low(n + 1), stk(n + 1), id(n + 1), din(n + 1);
    int top &#x3D; 0, timestamp &#x3D; 0, scc_cnt &#x3D; 0;
    vector&lt;bool&gt; in_stk(n + 1);
    function&lt;void(int)&gt; tarjan &#x3D; [&amp;](int u) -&gt; void
    &#123;
        dfn[u] &#x3D; low[u] &#x3D; ++timestamp;
        stk[++top] &#x3D; u, in_stk[u] &#x3D; true;
        for (auto v : g[u])
        &#123;
            if (!dfn[v])
            &#123;
                tarjan(v);
                low[u] &#x3D; min(low[u], low[v]);
            &#125;
            else if (in_stk[v]) low[u] &#x3D; min(low[u], dfn[v]);
        &#125;
        if (dfn[u] &#x3D;&#x3D; low[u])
        &#123;
            int y;
            scc_cnt++;
            do
            &#123;
                y &#x3D; stk[top--];
                in_stk[y] &#x3D; false;
                id[y] &#x3D; scc_cnt;
            &#125; while (y !&#x3D; u);
        &#125;
    &#125;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        if (!dfn[i])
            tarjan(i);

    vector&lt;int&gt; new_v(scc_cnt + 1), new_w(scc_cnt + 1);
    vector&lt;vector&lt;int&gt;&gt; new_g(scc_cnt + 1);

    for (int u &#x3D; 1; u &lt;&#x3D; n; u++)
    &#123;
        for (auto v : g[u])
        &#123;
            int a &#x3D; id[u], b &#x3D; id[v];
            if (a &#x3D;&#x3D; b) continue;
            din[b]++;
            new_g[a].push_back(b);
        &#125;
        new_v[id[u]] +&#x3D; v[u], new_w[id[u]] +&#x3D; w[u];
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; scc_cnt; i++)
        if (!din[i])
            new_g[0].push_back(i);

    vector&lt;vector&lt;int&gt;&gt; dp(scc_cnt + 1, vector&lt;int&gt;(m + 1));
    function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
    &#123;
        for (auto t : new_g[u])
        &#123;
            dfs(t);
            for (int j &#x3D; m; j &gt;&#x3D; new_v[t]; j--)
            &#123;
                for (int k &#x3D; 0; k &lt;&#x3D; j; k++)
                &#123;
                    dp[u][j] &#x3D; max(dp[u][j], dp[u][j - k] + dp[t][k]);
                &#125;
            &#125;
        &#125;

        for (int j &#x3D; m; j &gt;&#x3D; 0; j--)
            if (j &gt;&#x3D; new_v[u])
                dp[u][j] &#x3D; dp[u][j - new_v[u]] + new_w[u];
            else    dp[u][j] &#x3D; 0;
        
        &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; dp[u][m] &lt;&lt; &quot;\n&quot;;
    &#125;;

    dfs(id[0]);

    cout &lt;&lt; dp[id[0]][m] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<h3 id="练习数据结构手感"><a href="#练习数据结构手感" class="headerlink" title="练习数据结构手感"></a>练习数据结构手感</h3><p><mark>题单放送：</mark></p>
<ul>
<li><p><strong>线段树（最大连续子段和）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a></p>
</li>
<li><p><strong>树链剖分（树链剖分 + 最大 &#x2F; 最小连续子段和）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1843/problem/F2">F2. Omsk Metro (hard version)</a></p>
</li>
</ul>
<p><mark>代码参考：</mark></p>
<h4 id="线段树（最大连续子段和）："><a href="#线段树（最大连续子段和）：" class="headerlink" title="线段树（最大连续子段和）："></a>线段树（最大连续子段和）：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 5e5 + 10;

int n,m;
int w[N];
struct Node
&#123;
	int l,r,sum;
	int lmx,rmx,tmx;
&#125;tr[N &lt;&lt; 2];

void pushup(Node&amp; u,Node&amp; l,Node&amp; r)
&#123;
	u.sum &#x3D; l.sum + r.sum;
	u.lmx &#x3D; max(l.lmx,l.sum + r.lmx);
	u.rmx &#x3D; max(r.rmx,r.sum + l.rmx);
	u.tmx &#x3D; max(&#123;l.tmx,r.tmx,l.rmx + r.lmx&#125;);
&#125;

void pushup(int u)
&#123;
	pushup(tr[u],tr[u &lt;&lt; 1],tr[u &lt;&lt; 1 | 1]);
&#125;

void build(int u,int l,int r)
&#123;
	tr[u] &#x3D; &#123;l,r&#125;;
	if(l &#x3D;&#x3D; r)	
	&#123;
		tr[u].sum &#x3D; w[l];
		tr[u].lmx &#x3D; tr[u].rmx &#x3D; tr[u].tmx &#x3D; w[l];
	&#125;
	else
	&#123;
		int mid &#x3D; l + r &gt;&gt; 1;
		build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1 | 1,mid + 1,r);
		pushup(u);
	&#125;
&#125;

void modify(int u,int x,int y)
&#123;
	if(tr[u].l &#x3D;&#x3D; x &amp;&amp; tr[u].r &#x3D;&#x3D; x)
	&#123;
		w[x] &#x3D; y;
		tr[u].sum &#x3D; tr[u].lmx &#x3D; tr[u].rmx &#x3D; tr[u].tmx &#x3D; y;
	&#125;
	else
	&#123;
		int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
		if(x &lt;&#x3D; mid)	modify(u &lt;&lt; 1,x,y);
		else	modify(u &lt;&lt; 1 | 1,x,y);
		pushup(u);
	&#125;
&#125;

Node query(int u,int l,int r)
&#123;
	if(tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)	return tr[u];
	int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
	if(l &gt; mid)	return query(u &lt;&lt; 1 | 1,l,r);
	else if(r &lt;&#x3D; mid)	return query(u &lt;&lt; 1,l,r);
	Node res;
	Node left &#x3D; query(u &lt;&lt; 1,l,r),right &#x3D; query(u &lt;&lt; 1 | 1,l,r);
	pushup(res,left,right);
	return res;
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	cin &gt;&gt; n &gt;&gt; m;
	for(int i &#x3D; 1;i &lt;&#x3D; n;i++)	cin &gt;&gt; w[i];

	build(1,1,n);
	while (m--)
	&#123;
		int k,x,y;
		cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;
		if(k &#x3D;&#x3D; 1)
		&#123;
			if(x &gt; y)	swap(x,y);
			cout &lt;&lt; query(1,x,y).tmx &lt;&lt; &quot;\n&quot;;
		&#125;
		else
		&#123;
			modify(1,x,y);
		&#125;
	&#125;
	
	return 0;
&#125;</code></pre>

<h4 id="树链剖分（树链剖分-最大-最小连续子段和）："><a href="#树链剖分（树链剖分-最大-最小连续子段和）：" class="headerlink" title="树链剖分（树链剖分 + 最大 &#x2F; 最小连续子段和）："></a>树链剖分（树链剖分 + 最大 &#x2F; 最小连续子段和）：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 2e5 + 10, M &#x3D; N * 2;
int n;
int h[N], e[M], w[M], ne[M], idx;
int cnt, id[N], nw[N], fa[N], sz[N], top[N], son[N], depth[N];

void init()
&#123;
    idx &#x3D; cnt &#x3D; 0;
    for (int i &#x3D; 0; i &lt;&#x3D; n + 1; i++)
    &#123;
        w[i] &#x3D; nw[i] &#x3D; id[i] &#x3D; son[i] &#x3D; depth[i] &#x3D; top[i] &#x3D; fa[i] &#x3D; 0;
        h[i] &#x3D; -1;
    &#125;
&#125;

struct Node
&#123;
    int l, r, sum;
    int lmax, rmax, tmax;
    int lmin, rmin, tmin;
&#125;tr[N &lt;&lt; 2];

struct Query
&#123;
    char op;
    int u, v, x;
&#125;q[N];


void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

void dfs1(int u, int father, int dep)
&#123;
    fa[u] &#x3D; father, depth[u] &#x3D; dep, sz[u] &#x3D; 1;

    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (j &#x3D;&#x3D; father)    continue;
        dfs1(j, u, dep + 1);
        sz[u] +&#x3D; sz[j];
        if (sz[son[u]] &lt; sz[j]) son[u] &#x3D; j;
    &#125;
&#125;

void dfs2(int u, int t)
&#123;
    id[u] &#x3D; ++ cnt, nw[cnt] &#x3D; w[u], top[u] &#x3D; t;
    if (!son[u])    return;
    dfs2(son[u], t);
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (j &#x3D;&#x3D; fa[u] || j &#x3D;&#x3D; son[u])  continue;
        dfs2(j, j);
    &#125;   
&#125;

void pushup(Node&amp; u, Node&amp; l, Node&amp; r)
&#123;
    u.sum &#x3D; l.sum + r.sum;
    u.lmin &#x3D; min(l.lmin, l.sum + r.lmin);
    u.rmin &#x3D; min(r.rmin, r.sum + l.rmin);
    u.tmin &#x3D; min(&#123;l.tmin, r.tmin, l.rmin + r.lmin&#125;);

    u.lmax &#x3D; max(l.lmax, l.sum + r.lmax);
    u.rmax &#x3D; max(r.rmax, r.sum + l.rmax);
    u.tmax &#x3D; max(&#123;l.tmax, r.tmax, l.rmax + r.lmax&#125;);
&#125;

void pushup(int u)
&#123;
    pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);
&#125;

void build(int u, int l, int r)
&#123;
    tr[u] &#x3D; &#123;l, r&#125;;
    if (l &#x3D;&#x3D; r)
    &#123;
        tr[u].sum &#x3D; nw[l];
        tr[u].lmax &#x3D; tr[u].rmax &#x3D; nw[l], tr[u].tmax &#x3D; max(0, nw[l]);
        tr[u].lmin &#x3D; tr[u].rmin &#x3D; nw[l], tr[u].tmin &#x3D; min(0, nw[l]);
    &#125;
    else
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    &#125;
&#125;

Node query(int u, int l, int r)
&#123;
    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)   return tr[u];
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if (r &lt;&#x3D; mid)   return query(u &lt;&lt; 1, l, r);
    else if (l &gt; mid)   return query(u &lt;&lt; 1 | 1, l, r);
    else
    &#123;
        auto left &#x3D; query(u &lt;&lt; 1, l, r);
        auto right &#x3D; query(u &lt;&lt; 1 | 1, l, r);
        Node res;
        pushup(res, left, right);
        return res;
    &#125;
&#125;

pii queryPath(int u, int v)
&#123;
    Node t[2], ans;
    t[0] &#x3D; t[1] &#x3D; &#123;0, 0, 0, 0, 0, 0, 0, 0, 0&#125;;
    int flag &#x3D; 1;
    while (top[u] !&#x3D; top[v])
    &#123;
        if (depth[top[u]] &lt; depth[top[v]])  swap(u ,v), flag &#x3D; 1 - flag;
        auto res &#x3D; query(1, id[top[u]], id[u]);
        pushup(ans, res, t[flag]), t[flag] &#x3D; ans;
        u &#x3D; fa[top[u]];
    &#125;
    
    if (depth[u] &lt; depth[v])    swap(u ,v), flag &#x3D; 1 - flag;
    auto res &#x3D; query(1, id[v], id[u]);
    pushup(ans, res, t[flag]), t[flag] &#x3D; ans;
    swap(t[1].lmax, t[1].rmax);
    swap(t[1].lmin, t[1].rmin);
    pushup(ans, t[1], t[0]);
    return &#123;ans.tmin, ans.tmax&#125;;
&#125;

void solve()
&#123;
    cin &gt;&gt; n;

    init();

    int node &#x3D; 1;
    w[node] &#x3D; 1;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        char op;
        int u, v, x;
        cin &gt;&gt; op;

        if (op &#x3D;&#x3D; &#39;+&#39;)
        &#123;
            cin &gt;&gt; u &gt;&gt; x;
            ++ node;
            w[node] &#x3D; x;
            add(u, node), add(node, u);
        &#125;
        else    cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;
        q[i] &#x3D; &#123;op, u, v, x&#125;;
    &#125;

    dfs1(1, -1, 1);
    dfs2(1, 1);
    build(1, 1, node);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (q[i].op &#x3D;&#x3D; &#39;?&#39;)
        &#123;
            pii res &#x3D; queryPath(q[i].u, q[i].v);
            if (q[i].x &gt;&#x3D; res.first &amp;&amp; q[i].x &lt;&#x3D; res.second)    cout &lt;&lt; &quot;YES\n&quot;;
            else    cout &lt;&lt; &quot;NO\n&quot;;
        &#125;
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

<h2 id="字符串的常见算法"><a href="#字符串的常见算法" class="headerlink" title="字符串的常见算法"></a>字符串的常见算法</h2><h3 id="LIS-——最长递增子序列"><a href="#LIS-——最长递增子序列" class="headerlink" title="$LIS$ ——最长递增子序列"></a>$LIS$ ——最长递增子序列</h3><p><mark>模板题题目链接：</mark><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/898/">896. 最长上升子序列 II</a></p>
<p><strong>时间复杂度：</strong>$O(NLogN)$</p>
<p><strong>算法：</strong>二分 + 动态规划</p>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n;
	cin &gt;&gt; n;

	vector&lt;int&gt; a(n + 1);
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)	cin &gt;&gt; a[i];

	vector&lt;int&gt; q(n + 1);
	int len &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		int l &#x3D; 0, r &#x3D; len;
		while (l &lt; r)
		&#123;
			int mid &#x3D; l + r + 1 &gt;&gt; 1;
			if (q[mid] &lt; a[i])	l &#x3D; mid;
			else	r &#x3D; mid - 1;
		&#125;
		q[l + 1] &#x3D; a[i];
		len &#x3D; max(l + 1, len);
	&#125;

	cout &lt;&lt; len &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;</code></pre>



<h3 id="LCS-——最长公共子序列（子串）"><a href="#LCS-——最长公共子序列（子串）" class="headerlink" title="$LCS$ ——最长公共子序列（子串）"></a>$LCS$ ——最长公共子序列（子串）</h3><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/899/">897. 最长公共子序列</a></p>
<p><strong>时间复杂度：</strong>$O(N^2)$</p>
<p><strong>算法：</strong>动态规划</p>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n, m;
	cin &gt;&gt; n &gt;&gt; m;

	string a, b;
	cin &gt;&gt; a &gt;&gt; b;
	a &#x3D; &quot; &quot; + a, b &#x3D; &quot; &quot; + b;

	vector&lt;vector&lt;int&gt;&gt; lcs(n + 1, vector&lt;int&gt;(m + 1));
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
		for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
			if (a[i] &#x3D;&#x3D; b[j])
				lcs[i][j] &#x3D; lcs[i - 1][j - 1] + 1;
			else	lcs[i][j] &#x3D; max(lcs[i][j - 1], lcs[i - 1][j]);
	
	cout &lt;&lt; lcs[n][m] &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;</code></pre>

<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p><strong>做法指南（这里给出 $4$ 做法！）：</strong></p>
<ul>
<li>后缀数组（以及解决多个串的做法）：$O(NlogN)$</li>
<li>后缀自动机</li>
<li>$dp$：$O(N^2)$</li>
<li>二分 + 哈希：$O(NlogN)$</li>
</ul>
<p><mark>题目链接：</mark></p>
<p><strong>两个字符串：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/3511/">3508. 最长公共子串</a></p>
<p><strong>（扩展）有多个字符串：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2813/">最长公共子串</a></p>
<ul>
<li>$SA$ 做法可参考博客：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/133699/">最长公共子串-后缀数组(带详解)</a></li>
</ul>
<p><mark>后缀数组做法：</mark></p>
<p><strong>思路：</strong> </p>
<ul>
<li>首先，由于不能包含数字，因此将每个数字变成一个没出现过的字符；</li>
<li>然后，将两个字符串拼接起来，中间用一个没出现过的字符拼接，从而得到一个新字符串；</li>
<li>由于 $height[i] &#x3D; lcp(sa[i], sa[i - 1])$，因此相邻两个的 $lcp$ 一定是最大的答案；</li>
<li>枚举每个 $height[i]$，只要 $sa[i]$ 与 $sa[i - 1]$ 的位置在新插入的中间字符的两侧即可。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 2e4 + 10;
int pos;
struct SuffixArray
&#123;
    string s;
    int n, m, sa[N], rk[N], height[N], x[N], y[N], c[N];

    void init(string t) &#123; &#x2F;&#x2F; 必须先初始化
        n &#x3D; t.size(), s &#x3D; &quot; &quot; + t, m &#x3D; &#39;z&#39;;
    &#125;

    void get_sa() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i] &#x3D; s[i]]++;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
        for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[i]]--] &#x3D; i;

        for (int k &#x3D; 1; k &lt;&#x3D; n; k &lt;&lt;&#x3D; 1) &#123;
            int num &#x3D; 0;
            for (int i &#x3D; n - k + 1; i &lt;&#x3D; n; i++)    y[++num] &#x3D; i;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                if (sa[i] &gt; k)
                    y[++num] &#x3D; sa[i] - k;
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] &#x3D; 0;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i]]++;
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
            for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[y[i]]]--] &#x3D; y[i], y[i] &#x3D; 0;
            swap(x, y);
            x[sa[1]] &#x3D; 1, num &#x3D; 1;
            for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
                x[sa[i]] &#x3D; (y[sa[i]] &#x3D;&#x3D; y[sa[i - 1]] &amp;&amp; y[sa[i] + k] &#x3D;&#x3D; y[sa[i - 1] + k] ? num : ++num);   

            m &#x3D; num;
            if (m &#x3D;&#x3D; n) break;
        &#125;
    &#125;

    void get_height() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    rk[sa[i]] &#x3D; i; &#x2F;&#x2F; 排名为i的字符的排名为i
        
        for (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++) &#123;
            if (rk[i] &#x3D;&#x3D; 1) continue;
            if (k)  k--;
            int j &#x3D; sa[rk[i] - 1];
            while (i + k &lt;&#x3D; n &amp;&amp; j + k &lt;&#x3D; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k])    k++;
            height[rk[i]] &#x3D; k;
        &#125;
    &#125;

	void solve() &#123;
		get_sa(), get_height();
		int res &#x3D; 0;
		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
			if (height[i] &gt; res &amp;&amp; ((sa[i] &gt;&#x3D; pos &amp;&amp; sa[i - 1] &lt;&#x3D; pos) || (sa[i] &lt;&#x3D; pos &amp;&amp; sa[i - 1] &gt;&#x3D; pos))) &#123;
				res &#x3D; height[i];
			&#125;
		&#125;

		cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
	&#125;
&#125;SA;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string a, b;
	cin &gt;&gt; a &gt;&gt; b;
	for (auto &amp;c : a)
		if (isdigit(c))	c &#x3D; &#39;(&#39;;
	for (auto &amp;c : b)
		if (isdigit(c))	c &#x3D; &#39;)&#39;;
	pos &#x3D; a.size() + 1;
	a.push_back(&#39;$&#39;);
	string s &#x3D; a + b;

	SA.init(s);

	SA.solve();

    return 0;
&#125;</code></pre>

<p><mark>后缀数组解决多个串做法：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;
struct SuffixArray
&#123;
	string s;
	int n, m, sa[N], rk[N], height[N], x[N], y[N], c[N];

	void init(string t) &#123; &#x2F;&#x2F; 必须先初始化
		n &#x3D; t.size(), s &#x3D; t, m &#x3D; &#39;z&#39;;
	&#125;

	void get_sa() &#123;
		&#x2F;&#x2F; 第一次基数排序
		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i] &#x3D; s[i]]++;
		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
		for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[i]]--] &#x3D; i;
		&#x2F;&#x2F; 倍增多轮
		for (int k &#x3D; 1; k &lt;&#x3D; n; k &lt;&lt;&#x3D; 1) &#123;
			int num &#x3D; 0;
			&#x2F;&#x2F; 第二关键字基数排序
			for (int i &#x3D; n - k + 1; i &lt;&#x3D; n; i++)    y[++num] &#x3D; i;
			for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
				if (sa[i] &gt; k)
					y[++num] &#x3D; sa[i] - k;
			&#x2F;&#x2F; 第一关键字基数排序
			for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] &#x3D; 0;
			for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i]]++;
			for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
			for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[y[i]]]--] &#x3D; y[i], y[i] &#x3D; 0;
			swap(x, y);
			&#x2F;&#x2F; 离散化
			x[sa[1]] &#x3D; 1, num &#x3D; 1;
			for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
				x[sa[i]] &#x3D; (y[sa[i]] &#x3D;&#x3D; y[sa[i - 1]] &amp;&amp; y[sa[i] + k] &#x3D;&#x3D; y[sa[i - 1] + k] ? num : ++num);   

			if (num &#x3D;&#x3D; n) break; &#x2F;&#x2F; 说明本次排序，没有出现相等的数，则每个数的大小关系都已经确定
			m &#x3D; num;
		&#125;
	&#125;

	void get_height() &#123;
		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    rk[sa[i]] &#x3D; i; &#x2F;&#x2F; 排名为i的字符的排名为i
		&#x2F;&#x2F; 根据 h() -&gt; height
		for (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++) &#123;
			if (rk[i] &#x3D;&#x3D; 1) continue;
			if (k)  k--;
			int j &#x3D; sa[rk[i] - 1];
			while (i + k &lt;&#x3D; n &amp;&amp; j + k &lt;&#x3D; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k])    k++;
			height[rk[i]] &#x3D; k;
		&#125;
	&#125;
&#125;SA;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n;
	cin &gt;&gt; n;

	string new_s;
	new_s.push_back(&#39; &#39;);
	int idx &#x3D; 1;

	vector&lt;int&gt; id(2e5 + 10);
	int mi &#x3D; 1e9;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		string s;
		cin &gt;&gt; s;
		mi &#x3D; min(mi, (int)s.size());
		for (auto c : s)
			new_s.push_back(c), id[idx++] &#x3D; i;
		new_s.push_back(char(&#39;A&#39; + i));
		idx++;
	&#125;

	&#x2F;&#x2F; cout &lt;&lt; new_s &lt;&lt; &quot;\n&quot;;
	SA.init(new_s);

	SA.get_sa(), SA.get_height();

	auto check &#x3D; [&amp;](int mid) -&gt; bool
	&#123;
		for (int i &#x3D; 1; i &lt;&#x3D; SA.n; i++)
		&#123;
			if (SA.height[i] &gt;&#x3D; mid)
			&#123;
				int j &#x3D; i;
				while (j &lt;&#x3D; SA.n &amp;&amp; SA.height[j] &gt;&#x3D; mid)	j++;
				j--;

				&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;
				vector&lt;bool&gt; st(n + 1);
				for (int p &#x3D; i - 1; p &lt;&#x3D; j; p++)
				&#123;
					st[id[SA.sa[p]]] &#x3D; 1;
					&#x2F;&#x2F; cout &lt;&lt; SA.sa[p] &lt;&lt; &quot; &quot; &lt;&lt; id[SA.sa[p]] &lt;&lt; &quot;\n&quot;;
				&#125;
				&#x2F;&#x2F; cout &lt;&lt; &quot;\n&quot;;
				int cnt &#x3D; 1;
				while (cnt &lt;&#x3D; n &amp;&amp; st[cnt])	cnt++;
				&#x2F;&#x2F; cout &lt;&lt; cnt &lt;&lt; &quot;\n&quot;;
				if (cnt &#x3D;&#x3D; n + 1)	return true;
				i &#x3D; j;
			&#125;
		&#125;
		return false;
	&#125;;
	
	int l &#x3D; 0, r &#x3D; mi;
	while (l &lt; r)
	&#123;
		int mid &#x3D; l + r + 1 &gt;&gt; 1;
		if (check(mid))	l &#x3D; mid;
		else	r &#x3D; mid - 1;
	&#125;

	cout &lt;&lt; l &lt;&lt; &quot;\n&quot;;
	
	return 0;
&#125;</code></pre>

<p><mark>后缀自动机做法：</mark></p>
<p><strong>思路：</strong> 跟后缀自动机求解 $n$ 个串的思路一样（可以参考博客“数据结构”篇），数字用新字符处理掉即可。</p>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e4 * 2 + 10; &#x2F;&#x2F; 空间开2倍

struct SAM
&#123;
    int tot,last;
    struct Node
    &#123;
        int len,fa;
        int ch[28];
        void init()&#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch,0,sizeof(ch));
        &#125;
    &#125;node[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125;
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;
&#125;sam;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string a, b;
    cin &gt;&gt; a &gt;&gt; b;

    for (auto c : a)
        if (isdigit(c)) sam.extend(26);
        else    sam.extend(c - &#39;a&#39;);

    vector&lt;vector&lt;int&gt;&gt; g(N + 2);
    for (int i &#x3D; 2; i &lt;&#x3D; sam.tot; i++)  g[sam.node[i].fa].push_back(i);
    
    int p &#x3D; 1, len &#x3D; 0;
    vector&lt;int&gt; now(N + 2);
    for (auto c : b)
    &#123;
        int t &#x3D; isdigit(c) ? 27 : c - &#39;a&#39;;
        while (p &gt; 1 &amp;&amp; !sam.node[p].ch[t])  p &#x3D; sam.node[p].fa, len &#x3D; sam.node[p].len;
        if (sam.node[p].ch[t])  p &#x3D; sam.node[p].ch[t], len++;
        now[p] &#x3D; max(now[p], len);
    &#125;

    vector&lt;int&gt; res(N + 2, 1e8);

    function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
    &#123;
        for (auto v : g[u])
        &#123;
            dfs(v);
            now[u] &#x3D; min(sam.node[now[u]].len, max(now[u], now[v]));
        &#125;
    &#125;;

    dfs(1);
    for (int i &#x3D; 1; i &lt;&#x3D; sam.tot; i++)  res[i] &#x3D; min(res[i], now[i]);

    int ans &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; sam.tot; i++)  ans &#x3D; max(ans, res[i]);

    cout &lt;&lt; ans;
    return 0;
&#125;</code></pre>

<p><mark> $dp$ 做法：</mark></p>
<p><strong>思路：</strong> 定义 $dp$：$f[i][j]$：$a$ 的前 $i$ 个串匹配 $b$ 的前 $j$ 个串，且以 $a[i], b[j]$ 为结尾的最长公共子串长度。</p>
<p>则：$f[i][j] &#x3D; f[i - 1][j - 1] + 1, if\ a[i]&#x3D;b[j]$</p>
<p>可以类似 $01$ 背包的优化方式进行一维优化，解决空间问题。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e4 + 10;

int f[N];
char a[N], b[N];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; a + 1 &gt;&gt; b + 1;
    
    int n &#x3D; strlen(a + 1), m &#x3D; strlen(b + 1);

    int res &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; m; j &gt;&#x3D; 1; j--)
            if (a[i] &#x3D;&#x3D; b[j] &amp;&amp; !isdigit(a[i]))
            &#123;
                f[j] &#x3D; f[j - 1] + 1;
                res &#x3D; max(res, f[j]);
            &#125;
            else    f[j] &#x3D; 0;
            
    cout &lt;&lt; res;
    return 0;
&#125;</code></pre>

<p><mark>二分 + 哈希做法：</mark></p>
<p><strong>思路：</strong> </p>
<ul>
<li>二分答案；</li>
<li>$O(N)$ check：<ul>
<li>对于第一个串，将每个长度为 $mid$ 的存入 $set$ 中，然后对第二个串进行同样操作，不过不需要再存入了，只需查询 $set$ 中是否存在即可。</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

struct Hash
&#123;
    string s;
    int n, base, mod;
    vector&lt;ll&gt; h,fh,pw;
    Hash(int _base,int _mod):base(_base),mod(_mod)&#123;&#125;

    void init(string t) &#123;&#x2F;&#x2F;初始化
        n &#x3D; t.size(), s &#x3D; &quot; &quot; + t;
        h.resize(n + 1),fh.resize(n + 2),pw.resize(n + 1);
        pw[0] &#x3D; 1;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   pw[i] &#x3D; pw[i - 1] * base % mod;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   h[i] &#x3D; (h[i - 1] * base % mod + s[i]) % mod;
        for(int i &#x3D; n;i &gt;&#x3D; 1;i--)   fh[i] &#x3D; (fh[i + 1] * base % mod + s[i]) % mod;
    &#125;
    ll getz(int l,int r)&#123;&#x2F;&#x2F;获取区间正哈希值
        return (h[r] - h[l - 1] * pw[r - l + 1] % mod + mod) % mod;
    &#125;
    ll getf(int l,int r)&#123;&#x2F;&#x2F;获取区间反哈希值
        return (fh[l] - fh[r + 1] * pw[r - l + 1] % mod + mod) % mod;
    &#125;
    bool equ(int l,int r)&#123;&#x2F;&#x2F;比较该区间正反哈希值是否一致
        return getz(l,r) &#x3D;&#x3D; getf(l,r);
    &#125;
    bool equ(int l1,int r1,int l2,int r2)&#123;&#x2F;&#x2F;比较两区间正哈希值是否一致
        return getz(l1,r1) &#x3D;&#x3D; getz(l2,r2);
    &#125;
&#125;h1(131,998&#39;244&#39;353), h2(131, 998&#39;244&#39;353);

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string a, b;
    cin &gt;&gt; a &gt;&gt; b;
    
    h1.init(a), h2.init(b);

    int n &#x3D; a.size(), m &#x3D; b.size();
    a &#x3D; &quot; &quot; + a, b &#x3D; &quot; &quot; + b;

    auto check &#x3D; [&amp;](int mid) -&gt; bool
    &#123;
        set&lt;ll&gt; S;
        for (int l &#x3D; 1; l &lt;&#x3D; n; l++)
        &#123;
            if (isdigit(a[l]))  continue;
            int r &#x3D; l;
            while (r &lt;&#x3D; n &amp;&amp; !isdigit(a[r]))    r++;
            r--;
            for (; l + mid - 1 &lt;&#x3D; r; l++)   
            &#123;
                S.insert(h1.getz(l, l + mid - 1));
            &#125;
            l &#x3D; r;
        &#125;

        for (int l &#x3D; 1; l &lt;&#x3D; m; l++)
        &#123;
            if (isdigit(b[l]))  continue;
            int r &#x3D; l;
            while (r &lt;&#x3D; m &amp;&amp; !isdigit(b[r]))    r++;
            r--;
            for (; l + mid - 1 &lt;&#x3D; r; l++)
            &#123;
                ll hash &#x3D; h2.getz(l, l + mid - 1);
                if (S.count(hash))  return true;
            &#125;
            l &#x3D; r;
        &#125;
        return false;
    &#125;;

    int l &#x3D; 0, r &#x3D; min(n, m);
    while (l &lt; r)
    &#123;
        int mid &#x3D; l + r + 1 &gt;&gt; 1;
        if (check(mid)) l &#x3D; mid;
        else    r &#x3D; mid - 1;
    &#125;

    cout &lt;&lt; l &lt;&lt; &quot;\n&quot;;
    
    return 0;
&#125;</code></pre>



<h3 id="LCP-——最长公共前缀"><a href="#LCP-——最长公共前缀" class="headerlink" title="$LCP$ ——最长公共前缀"></a>$LCP$ ——最长公共前缀</h3><p>$lcp(a,b)$：表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。</p>
<p><strong>$dp$ 解法：</strong></p>
<ul>
<li><p>定义：$dp[i][j]$ 表示：以 $i$ 开始的后缀与以 $j$ 开始的后缀的最长公共前缀长度。</p>
</li>
<li><p>如果 $s[i] &#x3D; s[j]$：$dp[i][j] &#x3D; dp[i + 1][j + 1] + 1$</p>
</li>
<li><p>如果 $s[i] \neq s[j]$：$dp[i][j] &#x3D; 0$</p>
</li>
</ul>
<p><mark>推荐题单：</mark></p>
<p>动态规划求 $lcp$（复杂度：$O(N^2)$）：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1948/problem/D">D. Tandem Repeats?</a></p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="二进制拆位算贡献"><a href="#二进制拆位算贡献" class="headerlink" title="二进制拆位算贡献"></a>二进制拆位算贡献</h3><p><strong>推荐博客：</strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/647165385">一类二进制拆位算贡献的题目</a></p>
<p><strong>问题描述：</strong></p>
<ul>
<li><p><strong>计算：</strong> $\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;i}^{n}f(i,j)×(j-i+1)$，其中 $f(i,j) &#x3D; s[i] \bigoplus s[j - 1]$：</p>
</li>
<li><p><strong>做法：</strong><mark>拆位</mark></p>
</li>
<li><p><strong>原式 &#x3D;</strong> $\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;i}^{n}\sum_{k&#x3D;0}^{m}2^k×(bit_{ik}\neq bit_{(j-1)k})×(i-(j-1))$</p>
</li>
<li><p><strong>时间复杂度：</strong>$O(nlogn)$</p>
</li>
<li><p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 998244353;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; s(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; s[i], s[i] ^&#x3D; s[i - 1];

    ll res &#x3D; 0;
    vector&lt;vector&lt;int&gt;&gt; len(30, vector&lt;int&gt;(2));
    vector&lt;vector&lt;int&gt;&gt; cnt(30, vector&lt;int&gt;(2));
    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 0; j &lt; 30; j++)
        &#123;
            int bit &#x3D; s[i] &gt;&gt; j &amp; 1;
            res &#x3D; (res + (((ll)i * cnt[j][!bit] % mod - len[j][!bit]) % mod + mod) % mod * ((1ll &lt;&lt; j) % mod) % mod) % mod;
            len[j][bit] &#x3D; (len[j][bit] + i) % mod;
            cnt[j][bit] ++;
        &#125;

    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    return 0;
&#125;</code></pre></li>
</ul>
<p><mark>推荐题单：</mark></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1879/problem/D">https://codeforces.com/contest/1879/problem/D</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/22754/H">Problem H. xor</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57359/I">The Yakumo Family</a></p>
<h3 id="普通位运算"><a href="#普通位运算" class="headerlink" title="普通位运算"></a>普通位运算</h3><p><mark>推荐题单：</mark></p>
<p><strong>$div2\ D$ 题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1946/problem/D">D. Birthday Gift</a></p>
<p><strong>$div2 \ D$ 题（经典三元组计数问题）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1957/problem/D">D. A BIT of an Inequality</a></p>
<hr>
<p><mark>锐评 $D\ Birthday\ Gift$ ：</mark></p>
<p><strong>吐槽：</strong>赛中 $1$ 小时的时候过了 $3$ 题，还算比较快的，没有什么硬核的思维题干扰，略上小分。然后争取到了时间去看了下 $D$，看到那复杂的公式，以为是什么很强大的数据结构之类的，但后面仔细想想可能是有什么性质。看了下题解后，果然是化简下式子，然后变成了别人口中的“典题”？？？怎么典了，我看完还是一点没思路啊！而且感觉真的<strong>思维量好大</strong>啊，赛场上遇到这种题该怎么办，怎么才能会这道题啊！！！</p>
<p><strong>思路：</strong>贪心。</p>
<ul>
<li>枚举合法的 $ans$ 即：或的和。<ul>
<li>对于 $x$ 的当前位为 $1$，将其设为 $0$ 后，后面的置为全 $1$，即可表示一个合法的 $ans \le x$，然后判断。</li>
</ul>
</li>
<li>对于枚举的 $ans$ 进行判断：<ul>
<li>扫一遍数组，如果异或的和与 $ans$ 的或仍然等于 $ans$，表示该段合法，即可以增加一段，依次处理即可。</li>
</ul>
</li>
<li>总结：虽然说的挺简单的，但还是得多深入思考。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n, x;
    cin &gt;&gt; n &gt;&gt; x;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    auto check &#x3D; [&amp;](int t) -&gt; int
    &#123;
        int sum &#x3D; 0, k &#x3D; 0;
        bool flag &#x3D; false;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            sum ^&#x3D; a[i];
            if ((sum | t) &#x3D;&#x3D; t)
            &#123;
                k++, sum &#x3D; 0;
                if (i &#x3D;&#x3D; n) flag &#x3D; true;
            &#125;
        &#125;
        if (flag)   return k;
        else    return -1;
    &#125;;

    int res &#x3D; check(x);

    for (int i &#x3D; 30; i &gt;&#x3D; 0; i--)
    &#123;
        if (x &amp; (1 &lt;&lt; i))
        &#123;
            int t &#x3D; x ^ (1 &lt;&lt; i);
            t |&#x3D; (1 &lt;&lt; i) - 1;
            res &#x3D; max(res, check(t));
        &#125;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="探讨区间种类数的多种做法"><a href="#探讨区间种类数的多种做法" class="headerlink" title="探讨区间种类数的多种做法"></a>探讨区间种类数的多种做法</h2><p><mark>参考博客：</mark><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/23426/">HH的项链(静态动态 树状&#x2F;线段树&#x2F;莫队&#x2F;主席树)</a></p>
<ul>
<li><p><strong>静态查询区间种类数：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2494/">HH的项链</a></p>
<ul>
<li>莫队（已更新）</li>
<li>树状数组（已更新）</li>
<li>线段树（已更新）</li>
<li>主席树 （已更新，可以参考这个：<a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/13790/">HH的项链 主席树</a>）</li>
</ul>
</li>
<li><p><strong>动态查询区间种类数：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2523/">数颜色</a></p>
<ul>
<li>带修莫队</li>
<li>树状数组套主席树（算法可能有点复杂，先不补了qwq）</li>
</ul>
</li>
<li><p><strong>树上静态查询区间种类数：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2536/">树上计数2</a></p>
<ul>
<li>树上莫队</li>
</ul>
</li>
</ul>
<h3 id="静态查询区间种类数"><a href="#静态查询区间种类数" class="headerlink" title="静态查询区间种类数"></a>静态查询区间种类数</h3><p><mark>莫队：</mark></p>
<ul>
<li><p>奇偶性优化：对于左端点在同一奇数块的区间，右端点按升序排列，反之降序。</p>
</li>
<li><p>细节（指针设置）：令 $i &#x3D; 0, j &#x3D; 1$，其中 $i$ 为右指针，$j$ 为左指针，数组元素下标是从 $1$ 开始的，初始化的时候错开，表示区间为空；然后方便好记忆的话可以这么去写区间移动的顺序：先移动右指针，再移动左指针（不过先移动谁都无所谓），写到这里发现没什么好讲的，理解那个意思就行了。</p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;

int n, m, block, ans;
int a[N], cnt[N];

struct Node
&#123;
    int l, r, id;
&#125;;

int get(int x)
&#123;
    return x &#x2F; block;
&#125;

void add(int x)
&#123;
    if (!cnt[x])    ans++;
    cnt[x]++;
&#125;

void del(int x)
&#123;
    cnt[x]--;
    if (!cnt[x])    ans--;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
    cin &gt;&gt; m;

    vector&lt;Node&gt; query(m + 1);
    block &#x3D; max(1, (int(sqrt((double)n * n &#x2F; m))));
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        cin &gt;&gt; query[i].l &gt;&gt; query[i].r, query[i].id &#x3D; i;

    sort(query.begin() + 1, query.end(), [&amp;](Node&amp; a, Node&amp; b) -&gt; bool&#123;
        int idl &#x3D; get(a.l), idr &#x3D; get(b.l);
        if (idl !&#x3D; idr) return idl &lt; idr;
        return (idl &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r;
    &#125;);

    vector&lt;int&gt; res(m + 1);
    for (int k &#x3D; 1, i &#x3D; 1, j &#x3D; 0; k &lt;&#x3D; m; k++)
    &#123;
        int id &#x3D; query[k].id, l &#x3D; query[k].l, r &#x3D; query[k].r;
        while (j &lt; r)   add(a[++j]);
        while (j &gt; r)   del(a[j--]);
        while (i &lt; l)   del(a[i++]);
        while (i &gt; l)   add(a[--i]);
        res[id] &#x3D; ans;
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cout &lt;&lt; res[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<p><mark>树状数组：</mark></p>
<p><strong>理解意义上：</strong></p>
<ul>
<li>我们按照右端点排序 $r$，然后枚举区间，新出现的数我们自然要加进去，而出现相同的数时，由于是按右端点递增来排序，我们要保留相同的数中靠右的那个，即该位置 $+1$ 表示这个位置贡献了 $1$，之前的位置 $-1$ 即变为 $0$，表示不需要这个数了。那么我们答案怎么获取？我们需要查询的是区间的答案，即区间中有多少位置被 $+1$。因此，所有的操作只涉及单点修改和区间查询。</li>
<li>考虑正确性：因为右端点递增且只保留最靠右的相同的数，而查询区间前面的结果并不会影响我们查询答案，故正确。</li>
</ul>
<p><strong>细化：</strong></p>
<ul>
<li>由于采用离线做法，避免不了排序，这里让 $r$ 从小到大排序；</li>
<li>对于一个区间：$[l,r]$，我们从 $[1,r]$ 开始扫，即从 $1$ 开始扫描，遇到一个新出现的数字，直接在该位置相加，遇到一个出现过的数字（开一个数组记录出现的位置）则在之前出现过的位置减去。这样的好处就是：将所有的数都只存最靠右的位置，且只保留 $1$ 个；</li>
<li>这样一来，我们通过树状数组的查询区间个数操作，直接查询该询问的区间个数即可。因为我们是从 $1$ 开始扫描的，那么 $[1,query[i].l - 1]$ 区间内出现的数字并不属于查询区间，虽然我们也求出来了，但我们也并未去获取里面的信息，因此并不影响答案；</li>
<li>由于 $r$ 是递增的顺序，因此我们每次处理询问，需要固定好 $r$ 的位置（即开始枚举的位置，下面代码是用 $l$ 表示的），这样一来，最多枚举了 $n$ 个位置，每次处理的时间复杂度为：$O(logN)$，故总时间复杂度：$O(NlogN)$</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

template &lt;typename T&gt;
struct Fenwick
&#123;
    const int n;
    vector&lt;T&gt; tr;
    Fenwick(int n):n(n),tr(n + 1)&#123;&#125;
    void init()&#123;&#x2F;&#x2F;清空树状数组
    for(int i &#x3D; 0;i &lt;&#x3D; n;i++)   tr[i] &#x3D; 0;
    &#125;
    void add(int x,T c)&#123;
        for(int i &#x3D; x;i &lt;&#x3D; n;i +&#x3D; i &amp; -i)   tr[i] +&#x3D; c;
    &#125;
    void add_range(int l,int r,T c)&#123;&#x2F;&#x2F;在区间[l,r]内加上数c
        add(l,c);
        add(r + 1,-c);
    &#125;
    T sum(int x)&#123;
        T res &#x3D; 0;
        for(int i &#x3D; x;i ;i -&#x3D; i &amp; -i)   res +&#x3D; tr[i];
        return res;
    &#125;
&#125;;

struct Node
&#123;
    int l, r, id;
&#125;;

bool cmp(Node&amp; a, Node&amp; b)
&#123;
    return a.r &lt; b.r;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    int q;
    cin &gt;&gt; q;
    vector&lt;Node&gt; query(q + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; q; i++)
        cin &gt;&gt; query[i].l &gt;&gt; query[i].r, query[i].id &#x3D; i;

    sort(query.begin() + 1, query.end(), cmp);
    vector&lt;int&gt; st(1e6 + 2);
    int l &#x3D; 1;
    vector&lt;int&gt; res(q + 1);
    Fenwick&lt;int&gt; fen(n);
    for (int i &#x3D; 1; i &lt;&#x3D; q; i++)
    &#123;
        for (int j &#x3D; l; j &lt;&#x3D; query[i].r; j++)
        &#123;
            if (st[a[j]])   fen.add(st[a[j]], -1);
            fen.add(j, 1);
            st[a[j]] &#x3D; j;
        &#125;
        l &#x3D; query[i].r + 1;
        res[query[i].id] &#x3D; fen.sum(query[i].r) - fen.sum(query[i].l - 1);
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; q; i++)    cout &lt;&lt; res[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<p><mark>线段树：</mark></p>
<ul>
<li>正如前面树状数组的思路，只需要单点修改和区间查询，利用线段树很简单就能实现。只要难点在于怎么想到这种做法，这是最重要的。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 5e4 + 10, M &#x3D; 1e6 + 10;

int n, m, a[N], st[M];
struct Node
&#123;
    int l, r;
    int sum;
&#125;tr[N &lt;&lt; 2];

void pushup(int u)
&#123;
    tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
&#125;

void build(int u, int l, int r)
&#123;
    tr[u] &#x3D; &#123;l, r&#125;;
    if (l &#x3D;&#x3D; r) return;
    int mid &#x3D; l + r &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
&#125;

void modify(int u, int p, int x)
&#123;
    if (tr[u].l &#x3D;&#x3D; tr[u].r &amp;&amp; tr[u].l &#x3D;&#x3D; p)
    &#123;
        tr[u].sum &#x3D; x;
        return ;
    &#125;
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if (p &lt;&#x3D; mid)   modify(u &lt;&lt; 1, p, x);
    else    modify(u &lt;&lt; 1 | 1, p, x);
    pushup(u);
&#125;

int query(int u, int l, int r)
&#123;
    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)   return tr[u].sum;
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    int res &#x3D; 0;
    if (l &lt;&#x3D; mid)   res +&#x3D; query(u &lt;&lt; 1, l, r);
    if (r &gt; mid)    res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);
    return res;
&#125;

struct Query
&#123;
    int l, r, id;
&#125;;

bool cmp(Query a, Query b)
&#123;
    return a.r &lt; b.r;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    cin &gt;&gt; m;
    vector&lt;Query&gt; q(m + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cin &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id &#x3D; i;
    sort(q.begin() + 1, q.end(), cmp);

    build(1, 1, n);

    int l &#x3D; 1;
    vector&lt;int&gt; res(m + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        for (int j &#x3D; l; j &lt;&#x3D; q[i].r; j++)
        &#123;
            if (st[a[j]])   modify(1, st[a[j]], 0);
            st[a[j]] &#x3D; j;
            modify(1, j, 1);
        &#125;
        l &#x3D; q[i].r + 1;
        res[q[i].id] &#x3D; query(1, q[i].l, q[i].r);
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cout &lt;&lt; res[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<p><mark>主席树：</mark></p>
<ul>
<li>可实现在线静态查询；</li>
<li>同样需要维护辅助数组记录值是否出现过已经出现的位置：<ul>
<li>如果是第一次出现，则直接从上一个版本的线段树拿过来并在当前位置 $+1$；</li>
<li>如果是相同的数，则先从上个版本线段树上删去这个位置，从而获得一个新版本线段树，然后在当前版本线段树上插入该位置；</li>
<li>查询：直接问第 $r$ 个版本的线段树中，区间在 $[l,r]$ 的数有多少个！因为每个版本插入的数最多是在当前位置插入的，第 $r$ 个版本的线段树插入的位置都是靠后的，且能插入到 $[l,r]$ 的也一定是区间 $[l,r]$ 真实的数。</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 5e4 + 10, M &#x3D; 1e6 + 10;

int n, m, a[N], st[M];
int root[N], idx;
struct Node
&#123;
    int l, r;
    int sum;
&#125;tr[N * 4 + 16 * N * 2];

int build(int l, int r)
&#123;
    int p &#x3D; ++idx;
    if (l &#x3D;&#x3D; r) return p;
    int mid &#x3D; l + r &gt;&gt; 1;
    tr[p].l &#x3D; build(l, mid), tr[p].r &#x3D; build(mid + 1, r);
    return p;
&#125;

int insert(int p, int l, int r, int pos, int x)
&#123;
    int q &#x3D; ++idx;
    tr[q] &#x3D; tr[p];
    if (l &#x3D;&#x3D; r)
    &#123;
        tr[q].sum +&#x3D; x;
        return q;
    &#125;
    int mid &#x3D; l + r &gt;&gt; 1;
    if (pos &lt;&#x3D; mid) tr[q].l &#x3D; insert(tr[p].l, l, mid, pos, x);
    else    tr[q].r &#x3D; insert(tr[p].r, mid + 1, r, pos, x);
    tr[q].sum &#x3D; tr[tr[q].l].sum + tr[tr[q].r].sum;
    return q;
&#125;

int query(int q, int l, int r, int pos)
&#123;
    if (l &gt;&#x3D; pos)   return tr[q].sum;
    int mid &#x3D; l + r &gt;&gt; 1;
    if (pos &lt;&#x3D; mid)   return query(tr[q].l, l, mid, pos) + tr[tr[q].r].sum;
    else    return query(tr[q].r, mid + 1, r, pos);
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;
    root[0] &#x3D; build(1, n);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    
    &#123;
        cin &gt;&gt; a[i];
        if (st[a[i]])   
        &#123;
            root[i] &#x3D; insert(root[i - 1], 1, n, st[a[i]], -1);
            root[i] &#x3D; insert(root[i], 1, n, i, 1);
        &#125;
        else    root[i] &#x3D; insert(root[i - 1], 1, n, i, 1);
        st[a[i]] &#x3D; i;
    &#125;

    cin &gt;&gt; m;
    while (m--)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; query(root[r], 1, n, l) &lt;&lt; &quot;\n&quot;; 
    &#125;
    
    return 0;
&#125;</code></pre>



<h3 id="动态查询区间种类数"><a href="#动态查询区间种类数" class="headerlink" title="动态查询区间种类数"></a>动态查询区间种类数</h3><h3 id="树上静态查询区间种类数"><a href="#树上静态查询区间种类数" class="headerlink" title="树上静态查询区间种类数"></a>树上静态查询区间种类数</h3><h2 id="诈骗题单（含有一定坑点的题目）"><a href="#诈骗题单（含有一定坑点的题目）" class="headerlink" title="诈骗题单（含有一定坑点的题目）"></a>诈骗题单（含有一定坑点的题目）</h2><blockquote>
<p>2023 年 12 月 3 日晚，打了一场 <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1902">Educational Codeforces Round 159 (Rated for Div. 2)</a>，其实 B 和 C 都非常简单，但是简单中也透露出了一些<mark>坑点</mark>，当然也有部分是因为自己对知识的不理解，仅是对自己的一种意义上的“坑点”！因此创建了一个新的题单，即“诈骗题单”，帮助自己总结一些常见的坑点信息！</p>
</blockquote>
<p><mark>Educational Codeforces Round 159 (Rated for Div. 2) B Getting Points：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1902/problem/B">B. Getting Points</a> </mark></p>
<p><strong>坑点：</strong><mark>变量名冲突</mark>。题目变量中含有 $l$，但由于需要用到二分，也用了 $l$，导致因为变量名冲突而出错，最终搞了一个小时决定换另一种写法（分类讨论）解决了本题qwq，但有意思的是，重写后我还是写到了变量名冲突（没有发现），但由于起变量名冲突的位置不同于第一次的写法，因此意外的过了！</p>
<p><mark>Educational Codeforces Round 159 (Rated for Div. 2) C Insert and Equalize：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1902/problem/C">C. Insert and Equalize</a></mark></p>
<p><strong>坑点：</strong><mark>经典爆 int </mark> 。虽然题目中的 $a_i$ 都是 $[-10^{9},10^9]$，但当数据为仅 2 个数：-$10^{9}$ 和 $10^9$ 时，需要再创建另一个数保证公差为 $2×10^9$ （题目要求），那么那个数就需要是 $-3 × 10^9$，就会爆掉，进而答案也会出错。 </p>
<p><mark>Codeforces Round 933 (Div. 3) F. Rudolf and Imbalance：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1941/problem/F">F. Rudolf and Imbalance</a></mark></p>
<p><strong>坑点：</strong> <mark>以为是三分，实际并不满足该条件（属于自己知识上的误区）。</mark> 该场景中，在三分的过程中，遇到了两个点 $m1$，$m2$ 对应权值相等的情况，导致并不满足三分的条件了，不知道区间该往哪边缩，因此导致了错误发生。</p>
<h2 id="优化好题（层层优化，一层优化但是典）"><a href="#优化好题（层层优化，一层优化但是典）" class="headerlink" title="优化好题（层层优化，一层优化但是典）"></a>优化好题（层层优化，一层优化但是典）</h2><ol>
<li><strong>$2022$ 蓝桥杯省赛真题（层层优化）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4408/">统计子矩阵</a></li>
</ol>
<ul>
<li>最初只会 $O(n^4)$ 的做法，思考了一些单调性后，也只能优化到 $O(n^3logn)$，但 $n$ 有 $500$，仍然过不去。因此必须优化到 $O(n^3)$。</li>
<li>如果枚举一个左端点，由于是二维矩阵，就已经需要两层循环了，之后另一个信息不太好枚举。</li>
<li>考虑另一个方向：枚举上端点，枚举下端点，即枚举 $x$ 的上下界，这两个枚举就是两层循环，中间的区域通过双指针即可实现 $O(N)$ 的复杂度！我超，我终于想出来了！</li>
<li>最后卡在双指针好久，$l,r$ 指针以 $r$ 为末端点要好写些，如果以 $l$ 开始感觉挺难实现的（当时还写了一个判重数组）qwq。</li>
</ul>
<ol start="2">
<li><strong>$2022$ 蓝桥杯省赛真题（层层优化）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4409/">积木画</a></li>
</ol>
<ul>
<li>优化 $1$：定义状态：$f[i][j]$: 前 $i - 1$ 列已经摆好，且第 $i$ 列的状态为 $j$ 的方案数，枚举状态，时间复杂度：$O(N(2^M)^2)$</li>
<li>优化 $2$：定义状态：$f[i][j]$: 前 $i$ 列已经摆好，且第 $i + 1$ 列摆放了 $j$ 个的方案数，枚举个数，时间复杂度： $O(NM^2)$</li>
<li>优化 $3$：定义状态同上，不过优化了式子，时间复杂度：$O(NM)$</li>
<li>优化 $4$：终极优化，矩阵快速幂，时间复杂度：$O(logN)$<ul>
<li>每一层状态都可以由上一层状态获取，因此可以矩阵快速幂；</li>
<li>有三个未知数，因此定义：$[F_{i_0},F_{i_1},F_{i_2}] &#x3D; [F_{i-1_0},F_{i-1_1},F_{i-1_2}] \times A$，显然，$A$ 是一个 $3\times3$ 的矩阵；</li>
<li>根据递推的公式（优化 $3$），解未知数可得转移矩阵 $A$，因此得解。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>$bfs$ 类型的优化（一次优化，但是典）：</strong><ul>
<li>$2023$ 年百度之星初赛：<a target="_blank" rel="noopener" href="https://www.matiji.net/exam/brushquestion/1/4347/179CE77A7B772D15A8C00DD8198AAC74">BD202301公园</a></li>
<li>$2024$ 年天梯赛 $L3-1$：<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1781658570803388428?type=7&page=1">L3-037 夺宝大赛</a></li>
</ul>
</li>
</ol>
<ul>
<li>这两道题的优化思路基本差不多（从多点个的 $bfs$ 转换为从终点到其余所有点的 $bfs$），虽然只是第一次见这两个类型的题目，但好在赛时都成功写出来了！因此，这里入典方便复习，之后如果再遇到类似的题或者套路可以尽快想出来！！！</li>
</ul>
<ol start="4">
<li><strong>计数类（二元组计数 &#x2F; 三元组计数）优化（一次优化，但是典）：</strong></li>
</ol>
<ul>
<li><p><strong>二元组：</strong></p>
<ul>
<li>$div4\ G$：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1850/problem/G">G. The Morning Star</a></li>
</ul>
</li>
<li><p><strong>三元组：</strong></p>
<ul>
<li>$div2\ D$：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1957/problem/D">D. A BIT of an Inequality</a></li>
</ul>
</li>
</ul>
<hr>
<p><mark>统计子矩阵代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 510;

int g[N][N];
int col_s[N][N];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
        &#123;
            cin &gt;&gt; g[i][j];
        &#125;

    for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
    &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            col_s[j][i] &#x3D; col_s[j][i - 1] + g[i][j];
        &#125;
    &#125;

    ll res &#x3D; 0;
    for (int up &#x3D; 1; up &lt;&#x3D; n; up++)
        for (int down &#x3D; up; down &lt;&#x3D; n; down++)
        &#123;
            for (int l &#x3D; 1, r &#x3D; 1, s &#x3D; 0; r &lt;&#x3D; m; r++)
            &#123;
                s +&#x3D; col_s[r][down] - col_s[r][up - 1];
                while (s &gt; k) 
                &#123;
                    s -&#x3D; col_s[l][down] - col_s[l][up - 1];
                    l++;
                &#125;
                res +&#x3D; r - l + 1;
            &#125;
        &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>积木画代码：</mark></p>
<p><strong>优化 $1$（时间复杂度：$O(10N)$）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int mod &#x3D; 1e9 + 7;

int f[2][4];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    &#x2F;**
     * f[i][j]: 前 i - 1 列已经摆好，且第 i 列的状态为 j 的方案数。
    *&#x2F;
    f[0][3] &#x3D; 1;
    for (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++)
    &#123;
        for (int j &#x3D; 0; j &lt; 4; j++)
        &#123;
            if (j &#x3D;&#x3D; 0)
            &#123;
                f[i &amp; 1][0] +&#x3D; f[i - 1 &amp; 1][j];
                f[i &amp; 1][1] +&#x3D; f[i - 1 &amp; 1][j];
                f[i &amp; 1][2] +&#x3D; f[i - 1 &amp; 1][j];
                f[i &amp; 1][3] +&#x3D; f[i - 1 &amp; 1][j];
            &#125;
            else if (j &#x3D;&#x3D; 1)
            &#123;
                f[i &amp; 1][2] +&#x3D; f[i - 1 &amp; 1][j];
                f[i &amp; 1][3] +&#x3D; f[i - 1 &amp; 1][j];
            &#125;
            else if (j &#x3D;&#x3D; 2)
            &#123;
                f[i &amp; 1][1] +&#x3D; f[i - 1 &amp; 1][j];
                f[i &amp; 1][3] +&#x3D; f[i - 1 &amp; 1][j];
            &#125;
            else
            &#123;
                f[i &amp; 1][0] +&#x3D; f[i - 1 &amp; 1][j];
            &#125;
            for (int j &#x3D; 0; j &lt; 4; j++)
                f[i &amp; 1][j] %&#x3D; mod;
        &#125;
        for (int j &#x3D; 0; j &lt; 4; j++)
            f[i + 1 &amp; 1][j] &#x3D; 0;
    &#125;

    cout &lt;&lt; f[n + 1 &amp; 1][0] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><strong>优化 $2$（时间复杂度：$O(6N)$）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int mod &#x3D; 1e9 + 7;

int f[2][3];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    &#x2F;**
     * f[i][j]: 前 i 列已经摆好，且第 i + 1 列摆放了j个的方案数。
    *&#x2F;
    f[0][0] &#x3D; 1;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 0; j &lt; 3; j++) &#x2F;&#x2F; 枚举 i - 1 的状态
        &#123;
            if (j &#x3D;&#x3D; 0)
            &#123;
                (f[i &amp; 1][0] +&#x3D; f[i - 1 &amp; 1][j]) %&#x3D; mod;
                (f[i &amp; 1][2] +&#x3D; f[i - 1 &amp; 1][j]) %&#x3D; mod;
                f[i &amp; 1][1] &#x3D;(f[i &amp; 1][1] + 2 * f[i - 1 &amp; 1][j] % mod) % mod;
            &#125;
            else if (j &#x3D;&#x3D; 1)
            &#123;
                (f[i &amp; 1][1] +&#x3D; f[i - 1 &amp; 1][j]) %&#x3D; mod;
                (f[i &amp; 1][2] +&#x3D; f[i - 1 &amp; 1][j]) %&#x3D; mod;
            &#125;
            else
            &#123;
                (f[i &amp; 1][0] +&#x3D; f[i - 1 &amp; 1][j]) %&#x3D; mod;
            &#125;
        &#125;
        f[i + 1 &amp; 1][0] &#x3D; f[i + 1 &amp; 1][1] &#x3D; f[i + 1 &amp; 1][2] &#x3D; 0;
    &#125;

    cout &lt;&lt; f[n &amp; 1][0] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><strong>优化 $3$（时间复杂度：$O(3N)$）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 1e9 + 7;

int f[2][3];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    &#x2F;**
     * f[i][j]: 前 i 列已经摆好，且第 i + 1 列摆放了j个的方案数。
    *&#x2F;
    f[0][0] &#x3D; 1;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        f[i &amp; 1][0] &#x3D; (f[i - 1 &amp; 1][0] + f[i - 1 &amp; 1][2]) % mod;
        f[i &amp; 1][1] &#x3D; (2 * f[i - 1 &amp; 1][0] % mod + f[i - 1 &amp; 1][1]) % mod;
        f[i &amp; 1][2] &#x3D; (f[i - 1 &amp; 1][0] + f[i - 1 &amp; 1][1]) % mod;
    &#125;

    cout &lt;&lt; f[n &amp; 1][0] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><strong>优化 $4$（时间复杂度：$O(logN)$）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 1e9 + 7;
const int N &#x3D; 3;
struct Matrix
&#123;
    int g[N][N];
&#125;;

Matrix operator* (const Matrix&amp; a, const Matrix&amp; b) &#x2F;&#x2F; 重载 * 运算法，支持矩阵乘法
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++)
        for (int j &#x3D; 0; j &lt; N; j++)
            for (int k &#x3D; 0; k &lt; N; k++)
                res.g[i][j] &#x3D; (res.g[i][j] + (ll)a.g[i][k] * b.g[k][j] % mod) % mod;
    return res; 
&#125;

Matrix fpow(Matrix a, int b)
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++) res.g[i][i] &#x3D; 1;
    while (b)
    &#123;
        if (b &amp; 1)  res &#x3D; res * a;
        a &#x3D; a * a;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

Matrix A &#x3D; 
&#123;
    &#123;
        &#123;1, 2, 1&#125;,
        &#123;0, 1, 1&#125;,
        &#123;1, 0, 0&#125;
    &#125;
&#125;;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    &#x2F;**
     * res[3][3] &#x3D; init[3] * A[3][3] ^ n
    *&#x2F;
    auto res &#x3D; fpow(A, n);

    cout &lt;&lt; res.g[0][0];
    return 0;
&#125;</code></pre>



<p><mark>$div2\ D$：D. A BIT of an Inequality 讲解：</mark></p>
<ul>
<li><p>自己把公式化简出来了（并不难化简）：$(S_{x-1} \oplus S_z) \oplus a_y &gt; (S_{x-1} \oplus S_z)$；</p>
</li>
<li><p>三元组计数，我印象中（虽然没做过多少这类型的题）是可以枚举中间的那个 $y$ 然后搞个前后缀之类的能解决（想对了）；</p>
</li>
<li><p>最后一步没想到，不知道要统计什么东西。看了下题解，瞬间恍然大悟，忽略了一个很简单的点，对于 $x \oplus y &gt; x$，$y$ 的最高位是 $1$，那么 $x$ 就必须是 $0$。</p>
</li>
<li><p>总结就是：枚举点 $y$，前后缀搞一搞，就OK啦！</p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

using ll &#x3D; long long;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1), sum_xor(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    
    &#123;
        cin &gt;&gt; a[i];
        sum_xor[i] &#x3D; sum_xor[i - 1] ^ a[i];
    &#125;

    vector&lt;vector&lt;int&gt;&gt; sum(32, vector&lt;int&gt;(n + 1));
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 0; j &lt;&#x3D; 31; j++)
        &#123;
            if (sum_xor[i] &gt;&gt; j &amp; 1)  sum[j][i] &#x3D; sum[j][i - 1] + 1;
            else    sum[j][i] &#x3D; sum[j][i - 1];
        &#125;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; suf(32, vector&lt;int&gt;(n + 2));
    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)
    &#123;
        for (int j &#x3D; 0; j &lt;&#x3D; 31; j++)
        &#123;
            if (sum_xor[i] &gt;&gt; j &amp; 1)    suf[j][i] &#x3D; suf[j][i + 1] + 1;
            else    suf[j][i] &#x3D; suf[j][i + 1];
        &#125;
    &#125;

    auto get &#x3D; [&amp;](int x) -&gt; int
    &#123;
        for (int j &#x3D; 31; j &gt;&#x3D; 0; j--)
            if (x &gt;&gt; j &amp; 1) 
                return j;
        return -1;
    &#125;;

    ll res &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int pos &#x3D; get(a[i]);
        int sum0 &#x3D; (i - sum[pos][i - 1]), suf0 &#x3D; (n - i + 1 - suf[pos][i]);
        int sum1 &#x3D; sum[pos][i - 1], suf1 &#x3D; suf[pos][i];
        res +&#x3D; (ll)sum0 * suf0 + (ll)sum1 * suf1;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="Codeforces-掉分题单"><a href="#Codeforces-掉分题单" class="headerlink" title="Codeforces 掉分题单"></a>Codeforces 掉分题单</h2><blockquote>
<p>有赛时通过了，但耗时较长的题目类型；</p>
<p>有赛时没有通过，但后面的题都开出来了（说明是一道easy题），但思维不够的题目类型；</p>
</blockquote>
<p>$div3$ 评价：一般是 7 道题目，5道是青名水平，6道是蓝名水平，快速过了 6 道才能嘎嘎上篮。</p>
<hr>
<ul>
<li>$div3\ E$ 耗时较久，但最终赛时开出来了： <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1927/problem/E">E. Klever Permutation</a> </li>
<li>$div3\ D$ 后面两题都开出来了，但这道题就是想不出来 ：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1931/problem/D">D. Divisible Pairs</a><ul>
<li>赛后很快想清楚了，觉得可行就试了下，没想到直接过了样例，然后一发 $A$ 了。其实和赛时想的没有太大的偏差，就是缺少 $0.01$ 的偏差吧，没想到哪一点上。</li>
<li>锐评：思维还是不太行，这题确实是一道非常简单的题目，最终只是移项就可以让答案浮出水面，思维并不是很高。</li>
</ul>
</li>
<li>$div2\ C$ 本想着冲个蓝，结果掉大分！<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1929/problem/C">C. Sasha and the Casino</a><ul>
<li>离比赛还有12分钟的时候做出来了，又花了整整 $1$ 个小时！每次被卡题都是 $1$ 小时起步qwq，写了近 $1$ 小时 $8$ 分钟才出。。。</li>
<li>锐评：题意能理解。问题出现在：有一部分原因是题意扭曲了，就是赌场能决定我是输还是赢，而不是什么概率事件。因此明白这个意思之后就完全读懂了题目。主要被卡的原因，还是在于理所当然了，觉得好像在哪做过，虽然不知道什么做法，但就是喜欢硬猜；实际上是根据题意慢慢写出公式求出来的。所以每次被卡题，共性都是没有按照题意一步一步列出公式，而是胡乱猜测（虽然这场比赛的 $B$ 题被猜对了，而且还不知道怎么证明）。</li>
</ul>
</li>
<li>$think-cell\ Round\ 1 (即div1+div2)$：C 都没写出来，直接掉大分！<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1930/problem/C">C. Lexicographically Largest</a><ul>
<li>赛中没有任何想法，被样例的结果否定了所有想法。</li>
<li>赛后听说老多人都是猜出来答案的，而且答案还很短，真的太痛苦了qwq</li>
</ul>
</li>
<li>$div3\ E$ 第 $5$ 题竟然都没做出来qwq，本身掉了好多分，其实这次是小上分的，就是因为分太低了qwq <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1932/problem/E">E. Final Countdown</a><ul>
<li>比赛快结束的时候被群友喂了下做法，赛后 $1$ 分钟过了qwq</li>
<li>其实是差不多的计算公式，由于我的比较麻烦导致一眼以为是高精度，结果狠狠的超时了，换种角度的计算公式可以发现其实很简单。</li>
</ul>
</li>
<li>$div3\ C$ 题都开始卡我了qwq，卡了我1个多小时！<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1933/problem/C">C. Turtle Fingers: Count the Values of k</a><ul>
<li>其实是个显然的暴力，但是我一开始以为是什么质因数分解，要一定的算法，模拟样例发现有个别样例不符，然后就一直在想怎么让分解的质因数满足要求，结果一直没成功，最后终于还是看了下数据范围想到暴力了，然后因为有点小问题导致 $wa2$，准备睡觉了，刚上床就又有思路了，绝对正确的思路，然后下去过了，顺便还把 $D$ 题过了，哎还是掉大分啊。</li>
<li>为什么 $C$ 题会想复杂，虽然题目顺序有难度递增的规则，但对于一般的比赛，还是得先正常的思考，反正就是得能看到这个分解质因数可能是行不通的。</li>
</ul>
</li>
<li>$div2\ D$ 第一次手速过前三题吧（用时 $40$ 分钟），但第四题卡了好长时间。<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1948/problem/D">D. Tandem Repeats?</a><ul>
<li>感觉就是 $dp$，但就是不知道从哪开始 $d$，不知道该怎么定义状态，不知道该怎么递进的思考该问题。</li>
<li>确实是 $dp$，不过需要对 $lcp$ （最长公共前缀）这个概念有所了解。</li>
</ul>
</li>
<li><mark>鉴定为高质量题目（算法：差分）。</mark>$div3\ E$ 没写出来，感觉是一道思维题。。。<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1955/problem/E">E. Long Inversions</a><ul>
<li>锐评：整场难度感觉比之前 $div3$ 要难一些，自己的翻译水平也差了好多，不过这场好题还挺多的，这个 $E$ 感觉很棒，当晚临睡觉前还想到了一个做法，但第二天早上就被自己 $hack$ 了，目前还在思考怎么写ing；</li>
<li>无奈看题解：看了一眼知乎题解，他说就是差分，虽然直接差分看似 $O(N^3)$，但由于是区间异或操作，可以达到 $O(N^2)$ 的优秀效果；看完不禁让我继续想用了 $bitset$，以为题解是这个意思qwq，虽然 $bitset$ 过了，但用时 $2.5s$，几乎快达到题目给的 $3s$ 时限了。</li>
<li>再度锐评：忘了说了，这次打 $cf$ 有一个天然的优势，因为最近巩固了之前学过的很多算法，学起来并不吃力了，也补了之前很多题目，感觉没什么东西能限制我了，然后决定来打 $div3$ 试试上分并检验自己的成果。结果面对 $E$ 题，我绞尽脑汁，以为是什么思维上的做法，感觉还是死在了思维了。但赛后看来，之前想过差分但觉得会超时，但现在发现，这应该是一个差分应用上的小技巧，我还真不知道！决定去学一学，顺便还学着使用了一手 $bitset$ 针不戳！</li>
</ul>
</li>
<li><mark>鉴定为区域赛思维题（算法：组合数学&#x2F; $dp$）。</mark>$div2\ C$ 很像区域赛的那种思维题，没做出来，需要好好想想。：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1957">Codeforces Round 940 (Div. 2) and CodeCraft-23</a><ul>
<li>锐评：这是一场<strong>数学含量贼高的场</strong>，怪不得我掉大分qwq，挺不错的。</li>
<li>很好，解决了这道题目（看了下题解qwq）。是一道简单的组合数学问题（现在发现自己的数学水平差到底了，最近的蓝桥杯数学题、$cf$ 数学题全都不会。。。）</li>
<li>基本思路都差不多，只不过自己在组合数学方面想的有点慢。。。其实这题可以分成两种写法：<ul>
<li>1、组合数学：考虑枚举，即选了多少个 $x \neq y$ 的情况，剩下的一定是都填在对角线上，也就是最终棋盘是固定的。<ul>
<li>假设剩下能填的矩阵的阶是 $n$，则有公式：$C_n^iC_{n-i}^{i}$。先说明下这个公式的含义：从 $n$ 行中选出 $i$ 个互不相同的横坐标，然后纵坐标首先肯定不能有和横坐标相同的数，那么就是 $n - i$ 的来历，然后同样的，从剩下 $n - i$ 个可选的纵坐标里面选出 $i$ 个。那么这个公式到底是什么含义呢？起初我只以为这就是答案了，因为这不就是所有选法吗？然后运行发现样例过不了，然后陷入了沉默。经过手捏数据发现，坏了我也不知道这到底是什么了。。。受不了了，交完 $AC$ 代码了，突然发现自己还是不会。。。刚刚去看了下官方题解表示组合数学比 $dp$ 更难理解些的意思，emmm等解决了这个组合数学再搞 $dp$ 的写法吧。。。等到了第二天上课的时候再思考这个东西，突然悟了。</li>
<li>因为我们是要选 $i$ 个格子，因为对方会自动选出相对的格子，我们不用先考虑对方的操作。$C_n^i$ 表示我选出的行的各种情况，那么显然我们已经分出了 $C_n^i$ 组，每组的行坐标都不一样，那么对于已选定的行，我们还能再选出 $C_{n-i}^{i}$ 的列，但是在对应行的分组中，不同的列的顺序会影响结果！以从 $4$ 个里面选 $2$ 个为例，如下：</li>
<li>第一组：$(1,3),(2,4)$ 或 $(1,4),(2,3)$，其中第一组的行标志是 $1、2$，剩余列中只有唯一的选法，就是 $3、4$ 在行中任意排列，都是不同的结果。其余组也类似。</li>
<li>简而言之，最终答案就是：$C_n^iC_{n-i}^{i}A_i$：按行分组，每组的列可以任意排列（如上面的例子），故此。</li>
</ul>
</li>
<li>2、$dp$：考虑一行一行的取（至于为什么每行取有点意思）。第一个是对角线位置，取了之后还剩 $n - 1$，而其余位置都是非对角线位置，即有 $n - 1$ 个，又因为这种非对角线的颜色可以任意，因此：$dp[n] &#x3D; dp[n - 1] + (n - 1) \times 2 \times dp[n-2]$。<ul>
<li>其实可能为什么就一行一行的取有点好奇。考虑第一行和第一列，其中有 $1$ 个对角线位置，其余的有 $2\times (n - 1)$ 个非对角线位置。那又为什么这样取，而不能随意的取（比如取其他行和其他列，就非得按照题解是这么说？）？</li>
<li>这样取的好处就是它在保存某种结构。即把所有关于第 $i$ 行的全部取完的情况。然后从这里去往下转移到后面的状态。所有取完第 $i$ 行的情况有哪些？有 $(i,i)$ 对角线，以及所有的第 $i$ 行和第 $i$ 列，应该就是这种原因（确信qwq）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>$div2\ C$ 又被 $C$ 卡住啦！<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1969/problem/C">C. Minimizing the Sum</a><ul>
<li>现场是这样的：以为是优先队列贪心做，结果是 $dp$。主要觉得贪心很多，但实际不然，当时没找到好样例 $hack$ 自己。。。直到第二天补题才找到，这次是自己调出来的，没有看题解。样例：$8\ 4\ 1$，给定 $2$ 次机会，优先队列会出错！因此显然只剩下 $dp$ 了，$dp$ 真的泰牛辣，真没看出来呜呜呜</li>
<li><mark>算是某些意义上的好题：以为贪心，实则 $dp$。</mark></li>
<li>感觉这个标签都能开一个专栏了，等下次再遇到这种看着很贪心，实则是 $dp$ 的题就进行归纳整理。</li>
</ul>
</li>
<li>$div2\ C$ 又又被 $C$ 卡到啦！！！<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1972/problem/C">C. Permutation Counting</a><ul>
<li>感觉能猜个大概做法，但没猜到这个结论是什么。。。感觉就是猜结论，一个不会证明的结论qwq，啊啊啊又掉分了。$D$ 分 $d1,d2$，写出了 $d1$，其实很简单，感觉 $d2$ 才是我理解的数论的好题，需要预处理，很经典qwq</li>
<li>emm第二天补题，写了没 $10$ 分钟就过了，也没看题解。感觉就是猜出了结论。。。6啊</li>
</ul>
</li>
<li>$div3$ 只做了 $4$ 题，被纯思维卡了，还有后面的题应该只是小思维，也卡了。。。<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1968/problem/F">F. Equal XOR Segments</a> <ul>
<li>$E$ 强大的思维构造，营养价值很高；</li>
<li>$F$ 是小思维，但没想到咋做，感觉不难，不知道自己到底要想多久。。。；</li>
<li>最后两题是道字符串；</li>
<li>不知道是不是这场中间题目思维含量挺高还是自己太菜了，应该是自己的问题，啥也打不过了。</li>
</ul>
</li>
</ul>
<hr>
<p><mark>D. Divisible Pairs 讲解：</mark></p>
<p><strong>题意：</strong> 给定 $n$ 个数，问有多少个数对满足：$a_i + a_j &#x3D; k_1x, a_i - a_j &#x3D; k_2y$ ? 其中 $x, y$ 是已知给定的， $k_1,k_2$ 是系数。</p>
<p><strong>思路：</strong> 移项： $a_i &#x3D; k_1x - a_j, a_i &#x3D; k_2y + a_j$，然后就会产生思路！这就是两个公式相关联起来的结果，即对同一个数，将其分别模 $x$ 和模 $y$ 存起来即可。 </p>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

void solve()
&#123;
    int n, x, y;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    map&lt;pii, int&gt; mp;
    ll res &#x3D; 0;
    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)
    &#123;
        res +&#x3D; mp[&#123;((-a[i]) % x + x) % x, a[i] % y&#125;];
        mp[&#123;a[i] % x, a[i] % y&#125;]++;
    &#125;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>$E. Final\ Countdown$ 讲解：</mark></p>
<ul>
<li><p><strong>思路：</strong>对于样例 $12345$，有两种计算方法（一个是我自己搞的，另一个是正解的qwq，太小丑了呜呜呜）</p>
<ul>
<li><p>自己的计算过程：12345 &#x3D; 1 * 5 + （12 - 1） * 4 + （123 - 12） * 3 + （1234 - 123）* 2 + （12345 - 1234） * 1。当时是从高位开始倒着想的，然后一看这公式是成立的，但是乘法必须得高精度吧，直接调板子，果不其然，TLE 了，确实应该TLE。</p>
</li>
<li><p>正解是：12345 + 1234 + 123 + 12 + 1，用前缀和预处理每一位，即可。</p>
</li>
</ul>
</li>
<li><p><strong>问题抽象出来：</strong> 求一个大整数，将其每个前缀加起来，答案是多少？</p>
</li>
<li><p><strong>吐槽：</strong>为什么该逆向思考的时候不逆向思考，不该逆向思考的时候就？</p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        int n;
        cin &gt;&gt; n;

        string s;
        cin &gt;&gt; s;

        s &#x3D; &quot; &quot; + s;
        vector&lt;int&gt; sum(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            sum[i] &#x3D; s[i] - &#39;0&#39;;
        
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            sum[i] +&#x3D; sum[i - 1];

        vector&lt;int&gt; res;
        ll jin &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            ll t &#x3D; (jin + sum[n - i + 1]) % 10;
            res.push_back(t);
            jin &#x3D; (jin + sum[n - i + 1]) &#x2F; 10;
        &#125;

        while (jin)
        &#123;
            res.push_back(jin % 10);
            jin &#x2F;&#x3D; 10;
        &#125;

        while (res.size() &amp;&amp; res.back() &#x3D;&#x3D; 0)   res.pop_back();
        
        for (int i &#x3D; res.size() - 1; i &gt;&#x3D; 0; i--)
            cout &lt;&lt; res[i];
        cout &lt;&lt; &quot;\n&quot;;
    &#125;  
    return 0;
&#125;</code></pre>

<p><mark>$D.\ Tandem\ Repeats?$ 讲解：</mark></p>
<p><strong>思路：</strong> 如果枚举长度 $len$，那么怎么快速判断 $s[l,l+len-1]$ 与 $s[l + len,l+2\times len-1]$ 是相等的呢？</p>
<p>再转换为：字符串 $s[l, 2\times len-1]$ 与 字符串 $s[l+len,l + 2×len - 1]$ 的最长公共前缀的长度是否等于 $len$ ？</p>
<p>因此，可以看出 $lcp$ 的概念了，$O(n^2)$ 的复杂度可以用 $dp$ 解决 $lcp$ 的问题，最后枚举所有串，$O(1)$ 判断即可。</p>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        string s;
        cin &gt;&gt; s;

        int n &#x3D; s.size();
        s &#x3D; &quot; &quot; + s;

        vector&lt;vector&lt;int&gt;&gt; lcp(n + 2, vector&lt;int&gt;(n + 2));
        &#x2F;**
         * s[l] &#x3D;&#x3D; s[r]: lcp[l][r] &#x3D; lcp[l + 1][r + 1] + 1
         * s[l] !&#x3D; s[r]: lcp[l][r] &#x3D; 0
        *&#x2F;
        for (int l &#x3D; n; l &gt;&#x3D; 1; l--)
            for (int r &#x3D; l; r &lt;&#x3D; n; r++)
            &#123;
                if (s[l] &#x3D;&#x3D; s[r] || s[l] &#x3D;&#x3D; &#39;?&#39; || s[r] &#x3D;&#x3D; &#39;?&#39;) lcp[l][r] &#x3D; lcp[l + 1][r + 1] + 1;
            &#125;
        
        int res &#x3D; 0;
        for (int l &#x3D; 1; l &lt;&#x3D; n; l++)
        &#123;
            for (int len &#x3D; 0; l + len &lt;&#x3D; n; len++)
            &#123;
                int r &#x3D; l + len;
                if (lcp[l][r] &#x3D;&#x3D; len)   res &#x3D; max(res, len);
            &#125;
        &#125;

        cout &lt;&lt; res * 2 &lt;&lt; &quot;\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>



<h2 id="盘点一些被卡很长时间的题目究竟是何原因？"><a href="#盘点一些被卡很长时间的题目究竟是何原因？" class="headerlink" title="盘点一些被卡很长时间的题目究竟是何原因？"></a>盘点一些被卡很长时间的题目究竟是何原因？</h2><ul>
<li><strong>小思维 + 公式推导：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1968/problem/F">F. Equal XOR Segments</a><ul>
<li>赛时没想到，赛后补题还是不知道该怎么解决。其实赛时就想到了那个小思维，说实话也不难想。因为是赛后看了题解的提示，所以开始准备奔着正解去想。但不知道一段区间怎么分成 $2$ 个异或和相等的部分，因此认为自己是卡在了实现的上面。</li>
<li>最后不得不看题解了，真的承认自己想不出来。看完后很震惊。</li>
<li>思维不是很大，因此能想到，但因为需要公式推导，<strong>没有去推导导致没有发现性质<mark>（核心原因）</mark>。</strong>但为什么不想着去推导呢？也是因为一直在抽象的去想，真的很难想到！！！而公式一列出来，才能发现性质！</li>
</ul>
</li>
</ul>
<h2 id="妙妙题"><a href="#妙妙题" class="headerlink" title="妙妙题"></a>妙妙题</h2><p><strong>1、</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4290">P4290 [HAOI2008] 玩具取名</a></p>
<ul>
<li><p><strong>题意：</strong> 有 $4$ 种字母：”WING”，其中每一种字母，可以由这四种的任意两种替换。最初只有一个字母，通过一些变换后，得到一个较长的字符串，问这个字符串最初可能是由哪些字母不断替换得来？</p>
</li>
<li><p><strong>吐槽：</strong> 看似一眼爆搜，但时间复杂度感觉非常之大，但至少得会这种爆搜，至少在蓝桥杯等赛制可以骗到一定的分数。</p>
</li>
<li><p><strong>妙处：</strong> 看似要从其中一种字母出发，不断尝试得到该较长字符串之后再寻求答案，实则需要逆向思考。想想”石子合并“这题是怎么来的？这么一想，会惊奇的发现这题会做了！反思之后发现，真的是“正难则反”！</p>
</li>
<li><p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 202;

int f[N][N][5];

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n1, n2, n3, n4;
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3 &gt;&gt; n4;

    auto get &#x3D; [&amp;](char c) -&gt; int
    &#123;
        if (c &#x3D;&#x3D; &#39;W&#39;)   return 1;
        else if (c &#x3D;&#x3D; &#39;I&#39;)  return 2;
        else if (c &#x3D;&#x3D; &#39;N&#39;)  return 3;
        else    return 4;  
    &#125;;

    auto inv_get &#x3D; [&amp;](int x) -&gt; char
    &#123;
        if (x &#x3D;&#x3D; 1) return &#39;W&#39;;
        else if (x &#x3D;&#x3D; 2)    return &#39;I&#39;;
        else if (x &#x3D;&#x3D; 3)    return &#39;N&#39;;
        else    return &#39;G&#39;;
    &#125;;

    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; state(5, vector&lt;vector&lt;int&gt;&gt;(5, vector&lt;int&gt;(5, 0)));

    string s;
    for (int i &#x3D; 1; i &lt;&#x3D; n1; i++)  
    &#123;
        cin &gt;&gt; s;
        state[get(s[0])][get(s[1])][1] &#x3D; 1;
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; n2; i++)   
    &#123;
        cin &gt;&gt; s;
        state[get(s[0])][get(s[1])][2] &#x3D; 1;
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; n3; i++)   
    &#123;
        cin &gt;&gt; s;
        state[get(s[0])][get(s[1])][3] &#x3D; 1;
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; n4; i++)   
    &#123;
        cin &gt;&gt; s;
        state[get(s[0])][get(s[1])][4] &#x3D; 1;
    &#125;

    cin &gt;&gt; s;

    int n &#x3D; s.size();
    s &#x3D; &quot; &quot; + s;

    &#x2F;**
     * f[i][j]: 将区间[i,j]合并为一个数字
     * 定义: W:1, I:2, N:3, G:4
     * f[i][j] &#x3D; f[i][k](合并为1个数字) + f[k + 1][j](合并为另一个数字) (二者再合并为新数字)
    *&#x2F;
    for (int l &#x3D; n; l &gt;&#x3D; 1; l--)
        for (int r &#x3D; l; r &lt;&#x3D; n; r++)
        &#123;
            if (l &#x3D;&#x3D; r)
            &#123;
                f[l][r][get(s[l])] &#x3D; 1;
                continue;
            &#125;
            else if (l + 1 &#x3D;&#x3D; r)
            &#123;
                for (int i &#x3D; 1; i &lt;&#x3D; 4; i++)
                    if (state[get(s[l])][get(s[r])][i])   
                        f[l][r][i] &#x3D; 1;
                continue;
            &#125;
            for (int k &#x3D; l; k + 1 &lt;&#x3D; r; k++)
            &#123;
                auto vec1 &#x3D; f[l][k], vec2 &#x3D; f[k + 1][r];
                for (int i1 &#x3D; 1; i1 &lt;&#x3D; 4; i1++)
                &#123;
                    if (!f[l][k][i1])   continue;
                    for (int i2 &#x3D; 1; i2 &lt;&#x3D; 4; i2++)
                    &#123;
                        if (!f[k + 1][r][i2])   continue;
                        for (int i3 &#x3D; 1; i3 &lt;&#x3D; 4; i3++)
                            if (state[i1][i2][i3])
                                f[l][r][i3] &#x3D; 1;
                    &#125;
                &#125;
            &#125;
        &#125;

    bool ok &#x3D; false;
    for (int i &#x3D; 1; i &lt;&#x3D; 4; i++)
        if (f[1][n][i])
        &#123;
            ok &#x3D; true;
            cout &lt;&lt; inv_get(i);
        &#125;
    
    if (!ok)    cout &lt;&lt; &quot;The name is wrong!&quot;;
    return 0;
&#125;</code></pre></li>
</ul>
<p><strong>2、$2023$ 蓝桥杯 $b$ 组省赛最后一题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4966/">砍树</a></p>
<ul>
<li><p><strong>题意：</strong>给定一颗树和 $m$ 个无序数对 $(a_i,b_i)$，其中 $a_i、b_i$ 互不相同，问能否删除一条边使得这 $m$ 个无序数对的每一个 $a_i$ 和 $b_i$ 互不相同？，若有多个满足条件，请输出最大边的编号；若不存在，请输出 $-1$。</p>
</li>
<li><p><strong>吐槽：</strong>听说是树剖，但怎么也看不出来，看了几遍之后总是没想法，不知道从哪入手。。。看了下题解，发现真的妙！为什么我没想到这一点！！！很重要的！</p>
</li>
<li><p><strong>妙处：</strong>考虑一对无序数对的点 $x$ 和 $y$，如果我们砍掉某条边可以让这两个点不连通，那么这条边一定是从 $x$ 到 $y$ 路径上的一点，其他无序数对也是如此。那么我们不妨在这 $m$ 条路径的<strong>边</strong>的权值上 $+1$，这个操作可以使用<mark>树上差分</mark>，因此如果最后某条边的权值为 $m$，我们选出编号最大的即可，秒啊！</p>
</li>
<li><p><strong>做法2：</strong>路径上添加权值，可以用<mark>树链剖分</mark>。不过由于我们一般要操作的是点权，而题目是边权，就需要将边权转到点权上，有多少边权就转多少点权，边权转为儿子节点上，公共祖先不附带权值，因此需要减去！</p>
</li>
<li><p><strong>收获：</strong>通过这道题目，总结了树上差分点权、边权操作，以及树链剖分的点权、边权（边权化点权）操作，还学到了树链剖分的 $lca$ 写法，收获满满！</p>
</li>
<li><p><strong>代码（树上差分写法）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;pii&gt;&gt; g(n + 1);
    for (int i &#x3D; 1; i &lt; n; i++)
    &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        g[a].push_back(&#123;b, i&#125;);
        g[b].push_back(&#123;a, i&#125;);
    &#125;

    vector&lt;pii&gt; path(m + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cin &gt;&gt; path[i].first &gt;&gt; path[i].second;

    vector&lt;vector&lt;int&gt;&gt; fa(n + 1, vector&lt;int&gt;(18));
    vector&lt;int&gt; depth(n + 1, 0x3f3f3f3f);
    auto bfs &#x3D; [&amp;](int root) -&gt; void 
    &#123;
        queue&lt;int&gt; q;
        q.push(root);
        depth[0] &#x3D; 0, depth[root] &#x3D; 1;
        while (!q.empty())
        &#123;
            auto u &#x3D; q.front();
            q.pop();
            for (auto [v, id] : g[u])
            &#123;
                if (depth[v] &gt; depth[u] + 1)
                &#123;
                    q.push(v);
                    depth[v] &#x3D; depth[u] + 1;
                    fa[v][0] &#x3D; u;
                    for (int k &#x3D; 1; k &lt;&#x3D; 17; k++)
                        fa[v][k] &#x3D; fa[fa[v][k - 1]][k - 1];
                &#125;
            &#125;
        &#125;
    &#125;;
    bfs(1);
    
    auto lca &#x3D; [&amp;](int a, int b) -&gt; int
    &#123;
        if (depth[a] &lt; depth[b])  swap(a, b);
    
        for (int k &#x3D; 17; k &gt;&#x3D; 0; k--)
            if(depth[fa[a][k]] &gt;&#x3D; depth[b])
                a &#x3D; fa[a][k];
    
        if (a &#x3D;&#x3D; b) return a;
    
        for (int k &#x3D; 17; k &gt;&#x3D; 0; k--)
            if (fa[a][k] !&#x3D; fa[b][k])
                a &#x3D; fa[a][k], b &#x3D; fa[b][k];
        return fa[a][0];
    &#125;;

    vector&lt;int&gt; w(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int a &#x3D; path[i].first, b &#x3D; path[i].second;
        w[a] ++, w[b] ++, w[lca(a, b)] -&#x3D; 2;
    &#125;

    int res_id &#x3D; -1;
    function&lt;int(int, int)&gt; dfs &#x3D; [&amp;](int u, int father) -&gt; int
    &#123;
        int res &#x3D; w[u];
        for (auto [v, id] : g[u])
        &#123;
            if (v &#x3D;&#x3D; father)    continue;
            int t &#x3D; dfs(v, u);

            if (t &#x3D;&#x3D; m) res_id &#x3D; max(res_id, id);   
            res +&#x3D; t;
        &#125;
        return res;
    &#125;;
    dfs(1, -1);

    cout &lt;&lt; res_id &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>
</li>
<li><p><strong>代码（树链剖分写法）：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 1e5 + 10;
int res_id[N];
struct HLD
&#123;
    int n, m, cnt;
    int sz[N], top[N], dep[N], fa[N], son[N], id[N];
    vector&lt;pii&gt; g[N];
    struct Tree                          
    &#123;
        int l, r;
        ll add, sum;
    &#125;tr[N &lt;&lt; 2];

    void dfs1(int u, int father, int depth) &#123;
        dep[u] &#x3D; depth, fa[u] &#x3D; father, sz[u] &#x3D; 1;
        for (auto [v, id] : g[u])
        &#123;
            if(v &#x3D;&#x3D; father) continue;
            dfs1(v, u, depth + 1);
            sz[u] +&#x3D; sz[v];
            res_id[v] &#x3D; id;
            if(sz[son[u]] &lt; sz[v])  son[u] &#x3D; v;
        &#125;
    &#125;

    void dfs2(int u, int t)
    &#123;
        id[u] &#x3D; ++cnt, top[u] &#x3D; t;
        if (!son[u]) return;
        dfs2(son[u], t);
        for (auto [v, id] : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa[u] || v &#x3D;&#x3D; son[u])   continue;
            dfs2(v, v);
        &#125;
    &#125;
    
    int lca(int u, int v) &#123;
        while (top[u] !&#x3D; top[v]) &#123;
            if (dep[top[u]] &gt; dep[top[v]]) &#123;
                u &#x3D; fa[top[u]];
            &#125;
            else &#123;
                v &#x3D; fa[top[v]];
            &#125;
        &#125;
        return dep[u] &lt; dep[v] ? u : v;
    &#125;

    void pushup(int u)
    &#123;
        tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    &#125;

    void eval(Tree &amp;u,ll add)
    &#123;
        u.add +&#x3D; add;
        u.sum +&#x3D; (u.r - u.l + 1) * add;
    &#125;

    void pushdown(int u)
    &#123;
        eval(tr[u &lt;&lt; 1], tr[u].add);
        eval(tr[u &lt;&lt; 1 | 1], tr[u].add);
        tr[u].add &#x3D; 0;
    &#125;

    void build(int u,int l,int r)
    &#123;
        tr[u] &#x3D; &#123;l, r&#125;;
        if (l &#x3D;&#x3D; r)  return;
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid), build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;

    void update(int u, int l, int r, int k)
    &#123;
        if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    
        &#123;   
            eval(tr[u], k);
        &#125;
        else
        &#123;
            pushdown(u);
            int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
            if (l &lt;&#x3D; mid)    update(u &lt;&lt; 1, l, r, k);
            if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k);
            pushup(u);
        &#125;
    &#125;

    ll query(int u,int l,int r)
    &#123;
        if (l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return  tr[u].sum;
        pushdown(u);
        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
        ll res &#x3D; 0;
        if (l &lt;&#x3D; mid)    res +&#x3D; query(u &lt;&lt; 1, l, r);
        if (r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);
        return res;
    &#125;

    void update_path(int u,int v,int k)
    &#123;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
            update(1, id[top[u]], id[u], k);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u, v);
        update(1, id[v], id[u], k);
    &#125;

    void update_tree(int u,int k)
    &#123;
        update(1, id[u], id[u] + sz[u] - 1, k);
    &#125;

    ll query_path(int u,int v)
    &#123;
        ll res &#x3D; 0;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]])   swap(u, v);
            res +&#x3D; query(1, id[top[u]], id[u]);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u,v);
        res +&#x3D; query(1, id[v], id[u]);
        return res;
    &#125;

    ll query_tree(int u)
    &#123;
        return query(1, id[u], id[u] + sz[u] - 1);
    &#125;

    void solve()
    &#123;
        cin &gt;&gt; n &gt;&gt; m;
        for (int i &#x3D; 1; i &lt; n; i++)
        &#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            g[a].push_back(&#123;b, i&#125;);
            g[b].push_back(&#123;a, i&#125;);
        &#125;

        vector&lt;pii&gt; path(m + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cin &gt;&gt; path[i].first &gt;&gt; path[i].second;

        dfs1(1, -1, 1);
        dfs2(1, 1);

        build(1, 1, n);
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        &#123;
            update_path(path[i].first, path[i].second, 1);
            int p &#x3D; lca(path[i].first, path[i].second);
            update_path(p, p, -1);
        &#125;

        int res &#x3D; -1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            if (query_path(i, i) &#x3D;&#x3D; m)
            &#123;
                res &#x3D; max(res, res_id[i]);
            &#125;
        &#125;
        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;hld;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    hld.solve();
    return 0;
&#125;</code></pre></li>
</ul>
<h2 id="卡空间题"><a href="#卡空间题" class="headerlink" title="卡空间题"></a>卡空间题</h2><p><strong>1、DP题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4290">P4290 [HAOI2008] 玩具取名</a></p>
<ul>
<li>卡题原因：定义了 $dp$ 数组：$vector<int> dp[N][N]$，实际一个 $vector$ 里面最多只装 $1,2,3,4$ 这四个数，而且我还用了去重，以为不会很占空间，但结果是内存超了 $125M$！最后看了下题解的写法，就是开了个 $dp[N][N][5]$，没想到修改成这样之后，只用了 $1M$ 内存就过了！WTF？太逆天了只能说。</li>
</ul>
<p><strong>2、之前2023RAICOM国赛第四题（算法：拓扑排序），也是被STL卡空间了</strong></p>
<ul>
<li>具体详情可以拉到下面 RAICOM 讲解中，有详情提到。</li>
</ul>
<h2 id="模拟题单"><a href="#模拟题单" class="headerlink" title="模拟题单"></a>模拟题单</h2><p><strong>简单模拟 + 细节（有时间可总结一套处理该类问题的通解写在下面）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1877/problem/B">B. Helmets in Night Light</a></p>
<p><strong>看似二分，实则贪心，但需要一定的模拟过程的功底：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1891/problem/C">C. Smilo and Monsters</a></p>
<p><strong>2023CCPC桂林签到模拟题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/G">G. Hard Brackets Problem</a></p>
<p><strong>2023CCPC桂林银牌模拟题（带有一定的贪心）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/B">B. The Game</a></p>
<p><strong>第 $46$ 届 $ICPC$ 亚洲区域赛（昆明）(正式赛）（待考古）：</strong> <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/32708/A">Amino Acids</a> </p>
<p><strong>2023南京站ICPC（初步认为是：贪心+大模拟，待补）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104821/problem/L">L. Elevator</a></p>
<p><strong>cf div2 D（暴力（链表）模拟但需要优化（否则会超时）（已补））：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1922/problem/D">D. Berserk Monsters</a></p>
<p><mark>2023CCPC桂林签到模拟题：</mark></p>
<blockquote>
<p><strong>思路：</strong></p>
<p>1、判断合法性：</p>
<ul>
<li>打一次左括号就会自动补全右括号，打右括号就最多只有右括号，因此右括号的总数一定大于等于左括号的总数。但不能直接从前往后遍历判断，而是从后往前遍历！</li>
</ul>
<p>2、模拟：</p>
<ul>
<li>经过多次思考和试错，发现了一个重要的性质：</li>
<li>1、如果后面没有了左括号，则要么直接退出，要么打出一些右括号；</li>
<li>2、如果当前是右括号，前面还有些未匹配完的左括号，则优先给前面未匹配的左括号；如果后面还有左括号，说明这个左括号一定得打出来，就得用右括号去移动。</li>
</ul>
<p>虽然这样是过了，但还是感觉有点丑（容易出错可能）。</p>
<p>从知乎里翻了下别人的“如何评价 2023桂林站”，找到了相关该题的解法，如果合法，直接输出原串就行了，根本不用手动模拟，多出来的右括号直接用来位移，我超牛逼！（赛场上真的太shab了）</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    string s;
    cin &gt;&gt; s;
    auto check &#x3D; [&amp;]() -&gt; bool
    &#123;
        int right &#x3D; 0, left &#x3D; 0;
        for (int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--)
        &#123;
            if (s[i] &#x3D;&#x3D; &#39;)&#39;)    right++;
            else    left++;
            if (left &gt; right)   return false;
        &#125;
        return true;
    &#125;;

    if (!check())   return cout &lt;&lt; &quot;impossible\n&quot;, void();

    cout &lt;&lt; s &lt;&lt; &quot;\n&quot;;
    &#x2F;*
    如果)后面有东西，则先打右括号
    *&#x2F;

    &#x2F;&#x2F; int left &#x3D; 0, right &#x3D; 0;
    &#x2F;&#x2F; for (auto c : s)
    &#x2F;&#x2F;     if (c &#x3D;&#x3D; &#39;(&#39;)   left++;
    &#x2F;&#x2F;     else    right++;

    &#x2F;&#x2F; int n &#x3D; s.size(), cnt &#x3D; 0;
    &#x2F;&#x2F; string res;
    &#x2F;&#x2F; for (int i &#x3D; 0; i &lt; n; i++)
    &#x2F;&#x2F; &#123;
    &#x2F;&#x2F;     if (s[i] &#x3D;&#x3D; &#39;(&#39;)
    &#x2F;&#x2F;     &#123;
    &#x2F;&#x2F;         res.push_back(&#39;(&#39;);
    &#x2F;&#x2F;         left--;
    &#x2F;&#x2F;         cnt++;
    &#x2F;&#x2F;         if (!left)
    &#x2F;&#x2F;         &#123;
    &#x2F;&#x2F;             if (right &#x3D;&#x3D; cnt) &#x2F;&#x2F; cnt: 还未匹配的左括号个数
    &#x2F;&#x2F;             &#123;
    &#x2F;&#x2F;                 break;
    &#x2F;&#x2F;             &#125;
    &#x2F;&#x2F;             else
    &#x2F;&#x2F;             &#123;
    &#x2F;&#x2F;                 i++;
    &#x2F;&#x2F;                 while (i &lt; n)   res.push_back(&#39;)&#39;), i++;
    &#x2F;&#x2F;                 break;
    &#x2F;&#x2F;             &#125;   
    &#x2F;&#x2F;         &#125;
    &#x2F;&#x2F;     &#125;
    &#x2F;&#x2F;     else
    &#x2F;&#x2F;     &#123;
    &#x2F;&#x2F;         if (!left)
    &#x2F;&#x2F;         &#123;
    &#x2F;&#x2F;             if (right &#x3D;&#x3D; cnt) &#x2F;&#x2F; cnt: 还未匹配的左括号个数
    &#x2F;&#x2F;             &#123;
    &#x2F;&#x2F;                 break;
    &#x2F;&#x2F;             &#125;
    &#x2F;&#x2F;             else
    &#x2F;&#x2F;             &#123;
    &#x2F;&#x2F;                 while (i &lt; n)   res.push_back(&#39;)&#39;), i++;
    &#x2F;&#x2F;                 break;
    &#x2F;&#x2F;             &#125;   
    &#x2F;&#x2F;         &#125;

    &#x2F;&#x2F;         if (left)   res.push_back(&#39;)&#39;);
    &#x2F;&#x2F;         if (cnt)    cnt--;
    &#x2F;&#x2F;         right--;
    &#x2F;&#x2F;     &#125;
    &#x2F;&#x2F; &#125;
    
    &#x2F;&#x2F; cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>2023CCPC桂林银牌模拟题（带有一定的贪心）讲解：</mark></p>
<blockquote>
<p><strong>题意：</strong>给一个集合 $A$，每次从中选择一个数 $+1$，然后删掉最小的，问能不能变成集合 $B$。</p>
<p><strong>思路：</strong></p>
<p>1、 贪心：一定是集合 $A$ 后面 $m$ 个数变成集合 $B$ 。</p>
<p>2、先删后加：因为反着来的话第一个样例都过不去qwq</p>
<p>3、这里有一个小 $tips$ ：用 $multiset$ 模拟集合，删一个数的话比较好操作，但是还要找到集合中最小的数，那么可以用 $map$ 实现，直接 $for$ 循环遍历的第一个数就是，然后 $break$！</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n + 1), b(m + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cin &gt;&gt; b[i];

    sort(a.begin() + 1, a.end()), sort(b.begin() + 1, b.end());

    if ([&amp;]&#123;
        for (int i &#x3D; n - m + 1, j &#x3D; 1; i &lt;&#x3D; n; i++, j++)
            if (a[i] &gt; b[j])    
                return true;
        return false;
    &#125;())  return cout &lt;&lt; &quot;-1\n&quot;, void();

    int cnt &#x3D; 0;
    for (int i &#x3D; n - m + 1, j &#x3D; 1; i &lt;&#x3D; n; i++, j++)
        cnt +&#x3D; b[j] - a[i];

    if (n - m &lt; cnt)    return cout &lt;&lt; &quot;-1\n&quot;, void();


    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    heap.push(a[i]);

    vector&lt;int&gt; v;
    vector&lt;int&gt; tp;
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap2 &#x3D; heap;
    vector&lt;int&gt; op;

    v.push_back(0);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    v.push_back(a[i]);
    while (cnt !&#x3D; v.size() - 1 - m)
    &#123;
        int last &#x3D; v.size() - 1 - m - cnt;&#x2F;&#x2F; 预留cnt的额外空间, 然后删去额外last的空间
        while (!heap.empty() &amp;&amp; last)
        &#123;
            auto t &#x3D; heap.top();
            heap.pop();
            op.push_back(t);
            heap.push(t + 1);
            heap.pop();
            last--;
        &#125;
        heap2 &#x3D; heap;

        tp.push_back(0);
        while (!heap.empty())
        &#123;
            auto t &#x3D; heap.top();
            heap.pop();
            tp.push_back(t);
        &#125;&#x2F;&#x2F; 获取删掉last后的数组新a
        v &#x3D; tp;
        tp.clear();
        heap &#x3D; heap2;
        if ([&amp;]&#123;
        for (int j &#x3D; m, i &#x3D; v.size() - 1; j &gt;&#x3D; 1; j--, i--)
            if (v[i] &gt; b[j])
            &#123;
                &#x2F;&#x2F; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot; &lt;&lt; b[j] &lt;&lt; &quot;\n&quot;;
                return true;
            &#125;
        return false;
        &#125;())    return cout &lt;&lt; &quot;-1\n&quot;, void();
        if (v.size() &lt;&#x3D; m)   return cout &lt;&lt; &quot;-1\n&quot;, void();

        cnt &#x3D; 0;
        for (int j &#x3D; m, i &#x3D; v.size() - 1; j &gt;&#x3D; 1; j--, i--)
            cnt +&#x3D; b[j] - v[i];
    &#125;

    for (int j &#x3D; m, i &#x3D; v.size() - 1; j &gt;&#x3D; 1; j--, i--)
        if (v[i] &lt; b[j])
        &#123;
            int t &#x3D; v[i];
            while (t &lt; b[j])
            &#123;
                op.push_back(t);
                t++;
                cnt--;
            &#125;
        &#125;

    if (cnt &gt; 0)
    &#123;
        heap &#x3D; heap2;
        while (!heap.empty() &amp;&amp; cnt)
        &#123;
            auto t &#x3D; heap.top();
            heap.pop();
            op.push_back(t);
            heap.push(t + 1);
            heap.pop();
            cnt--;
        &#125;
    &#125;

    auto check &#x3D; [&amp;]() -&gt; bool
    &#123;
        multiset&lt;int&gt; S;
        &#x2F;&#x2F; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;
        map&lt;int, int&gt; mp;
        for (int i &#x3D; 1;  i&lt;&#x3D; n; i++)    S.insert(a[i]), mp[a[i]]++;
        &#x2F;&#x2F; return true;
        for (int i &#x3D; 0; i &lt; op.size(); i++)
        &#123;
            int x &#x3D; op[i];
            S.erase(S.find(x));
            S.insert(x + 1);
            mp[x]--, mp[x + 1]++;
            if (!mp[x]) mp.erase(x);
            
            int t;
            for (auto [mpx, mpy] : mp)
            &#123;
                mp[mpx]--;
                t &#x3D; mpx;
                if (mpy &#x3D;&#x3D; 1)   mp.erase(mpx);
                break;
            &#125;
            S.erase(S.find(t));

        &#125;

        bool ok &#x3D; true;
        vector&lt;int&gt; res(m + 1);
        int i &#x3D; 1;
        for (auto x : S)
            res[i++] &#x3D; x;
        sort(res.begin(), res.end());
        return res &#x3D;&#x3D; b;
    &#125;;

    if (!check())    return cout &lt;&lt; &quot;-1\n&quot;, void();
    cout &lt;&lt; op.size() &lt;&lt; &quot;\n&quot;;
    for (auto x : op)   cout &lt;&lt; x &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>cf div2 D（暴力（链表）模拟但需要优化（否则会超时）（这个题什么时候有脑子了，什么时候补，质量非常的棒））：D. Berserk Monsters：</mark></p>
<p><strong>补题过程中的吐槽：</strong> 链表维护是可以想到的，但对于 $n$ 个回合，互相杀不死的情况下，时间复杂度会是 $O(n^2)$，这该怎么办？看了题解，没见几个说清楚的，就算说了，也就提了一嘴，还是不明白。</p>
<p>但是现在还没想明白，不想再看题解了，也不想用题解的代码去调试来解除自己的疑惑，先放一段时间（相信不会很长），等想清楚了再执笔。</p>
<p><strong>补题成功：</strong>当晚没睡着，想了想这道题目，突然猜了下题意，如果该轮没被杀死，那么下一轮的防御值会继续维持原有的，因为只有这样才可做，不然真的很难。第二天看了下题意，确实是这样！题意说：“只有在该轮受到的伤害严格大于 $d_i$ 才会死”，因此就很有思路了。</p>
<p><strong>思路：</strong> 第一轮先枚举谁会死，之后的每一轮，我们枚举死者的左右两边，这些位置是最有可能继续死去的。因此，最多死 $n$ 个敌人，枚举死去的敌人左右 $2$ 边也最多只有2个，故已解。</p>
<p><mark>优化：</mark> 枚举所有人一定会超时，但只有死去的敌人左右两边是最有可能死去的，而其他位置不会再死去，因此，只枚举死去敌人左右两边即为优化，减少枚举数量。</p>
<p><mark>代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 2), d(n + 2);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; d[i];

    vector&lt;int&gt; l(n + 2), r(n + 2);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        l[i] &#x3D; i - 1, r[i] &#x3D; i + 1;
    &#125;

    vector&lt;int&gt; v;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    v.push_back(i);

    vector&lt;int&gt; die;
    map&lt;int, int&gt; mpdie;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (i &#x3D;&#x3D; 1)
        &#123;
            for (auto x : v)
            &#123;
                int sum &#x3D; a[l[x]] + a[r[x]];
                if (sum &gt; d[x]) die.push_back(x);
            &#125;
        &#125;
        else
        &#123;
            set&lt;int&gt; S;
            for (auto x : die)
            &#123;
                mpdie[x] &#x3D; 1;
                l[r[x]] &#x3D; l[x];
                r[l[x]] &#x3D; r[x];
                if (l[x] &gt;&#x3D; 1 &amp;&amp; l[x] &lt;&#x3D; n &amp;&amp; !mpdie.count(l[x]))   S.insert(l[x]);
                if (r[x] &gt;&#x3D; 1 &amp;&amp; r[x] &lt;&#x3D; n &amp;&amp; !mpdie.count(r[x]))   S.insert(r[x]);
            &#125;
            die.clear();
            for (auto x : S)
            &#123;
                int sum &#x3D; a[l[x]] + a[r[x]];
                if (sum &gt; d[x] &amp;&amp; !mpdie.count(x)) die.push_back(x), mpdie[x] &#x3D; 1;
            &#125;
        &#125;
        cout &lt;&lt; die.size() &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    &#125;
&#125;
int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="交互题单"><a href="#交互题单" class="headerlink" title="交互题单"></a>交互题单</h2><p><strong>简单交互题（cf rating：1300）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1867/problem/C">C. Salyg1n and the MEX Game</a></p>
<p><strong>普通交互题（$div2\ C$ 题）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1937/problem/C">C. Bitwise Operation Wizard</a></p>
<p><strong>中等交互题（cf rating：2200）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1867/problem/E2">E2. Salyg1n and Array (hard version)</a></p>
<h2 id="思维-贪心好题"><a href="#思维-贪心好题" class="headerlink" title="思维 &amp; 贪心好题"></a>思维 &amp; 贪心好题</h2><p><mark>题单：</mark></p>
<ol>
<li><strong>2022ECfinal 第一道签到题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9728">2022ECfinal M Dining Professors</a></li>
<li><strong>思维（构造、分类讨论） + 贪心：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1873/problem/G">G. ABBC or BACB</a></li>
<li><strong>div3 D 贪心好题（思维不够，差一点就想到了，但无奈赛后看题解才明白）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1921/problem/D">D. Very Different Array</a></li>
<li><strong>div2 C 思维题（并不难，但思维不够，变成了掉分场）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1925/problem/A">easy：A. We Got Everything Covered!</a>     <a target="_blank" rel="noopener" href="https://codeforces.com/contest/1925/problem/C">hard：C. Did We Get Everything Covered?</a> </li>
<li><strong>$div1+div2\ C$ 思维题（难度堪比ECfinal思维题）</strong>：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1930/problem/C">C. Lexicographically Largest</a></li>
</ol>
<p><mark>1.分析：</mark></p>
<blockquote>
<p><strong>思路：</strong></p>
<ul>
<li>对于每个能吃辣的位置，在其前方三个位置+1，表示贡献；</li>
<li>对这些位置上的贡献进行排序，贡献高的说明对辣的喜爱度也较高，则优先分配辣的；</li>
<li>最后遍历一遍计算答案即可；</li>
</ul>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    vector&lt;int&gt; b(n + 1);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (a[i])
        &#123;
            b[i]++;
            b[i % n + 1]++;
            b[(i + n - 2) % n + 1]++;
        &#125;
    &#125;

    vector&lt;int&gt; p(n + 1);
    iota(p.begin() + 1, p.end(), 1);
    sort(p.begin() + 1, p.end(), [&amp;](int i, int j) -&gt; bool&#123;
        return b[i] &gt; b[j];
    &#125;);

    b.assign(n + 1, 0);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if (i &lt;&#x3D; m) 
            b[p[i]] &#x3D; 1;
    &#125;

    int res &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int cur &#x3D; i, left &#x3D; (i + n - 2) % n + 1, right &#x3D; i % n + 1;

        if (a[cur] &#x3D;&#x3D; 1)    res +&#x3D; 3;
        else
        &#123;
            if (!b[cur])    res++;
            if (!b[left])   res++;
            if (!b[right])  res++;
        &#125;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>2.代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    string s;
    cin &gt;&gt; s;

    int cnta &#x3D; 0, cntb &#x3D; 0;
    vector&lt;int&gt; v;
    for (int i &#x3D; 0; i &lt; s.size(); i++)
    &#123;
        if (s[i] &#x3D;&#x3D; &#39;A&#39;)
        &#123;
            cnta ++;
        &#125;
        else
        &#123;
            v.push_back(cnta);
            cnta &#x3D; 0;
            cntb ++;
        &#125;
    &#125;
    if (cnta)   v.push_back(cnta);
    
    sort(v.begin(), v.end());

    int res &#x3D; accumulate(v.begin(), v.end(), 0);
    res -&#x3D; (cntb &gt;&#x3D; v.size() ? 0 : v[0]);
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    return 0;
&#125;</code></pre>

<p><mark> 3.讲解：</mark></p>
<p><strong>简要题意：</strong> 给定 $n$ 个数 $a_i$，需要从有 $m(m \ge n)$ 个数的 $b$ 数组中选出 $n$ 个数凑出 $c$ 数组，$c$ 数组次序可以任意，使得 $\sum abs(a_i - c_i)$ 最大。</p>
<p><strong>思路：</strong> 一定需要排序，贪心的选最大值和最小值或最小值和最大值进行匹配即可，证明的话可以手试。</p>
<p><strong>吐槽：</strong>当时是依次进行类似的比较的，忽略了要分别从两边开始的这种特定顺序，导致rating–。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        int n, m;
        cin &gt;&gt; n &gt;&gt; m;

        vector&lt;int&gt; a(n + 1), b(m + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    cin &gt;&gt; b[i];


        sort(a.begin() + 1, a.end());
        sort(b.begin() + 1, b.end());
        deque&lt;int&gt; dqa;
        deque&lt;int&gt; dqb;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    dqa.push_back(a[i]);
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    dqb.push_back(b[i]);

        ll res &#x3D; 0;
        while (dqa.size())
        &#123;
            if (abs(dqa.front() - dqb.back()) &gt;&#x3D; abs(dqa.back() - dqb.front()))
            &#123;
                res +&#x3D; abs(dqa.front() - dqb.back());
                dqa.pop_front(), dqb.pop_back(); 
            &#125;
            else
            &#123;
                res +&#x3D; abs(dqa.back() - dqb.front());
                dqa.pop_back(), dqb.pop_front();
            &#125;
        &#125;
        
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>4.讲解：</mark></p>
<p><strong>题意：</strong> 给定长度为 $m$ 的字符串，问其中是否包含所有这样的子序列，即只由字母表的前 $k$ 个字母组成，长度为 $n$ 的字符串。若存在一个串，其不为该长度为 $m$ 的字符串的子序列，请输出该串。</p>
<p><strong>吐槽：</strong> 听说是印度场，出题人的英语描述真的是服了，题意看了老长时间。非得觉得用一句话表述就很易懂吗qwq</p>
<p><strong>思路：</strong> 抽象成这么理解：以最先出现所有前 $k$ 个字母划线，那么这是一个“块”，如果有 $ \ge n$ 个这样的块，就一定可以满足条件。为什么？就如最开始我们想的一个很难实现的想法，判断每个字母是不是可以当做第 $i(1 \le  i \le k)$ 位类似。因此，这就是”YES”的情况。</p>
<p>对于”NO“，怎么输出答案呢？我们知道，每块的最后一个字母，在该块内一定是出现了仅 $1$ 次的，那么将每块的这些字母连接起来，最后再让最后残缺的一块中没出现过的字母拼起来即可。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

void solve()
&#123;
    int n, k, m;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;

    string s;
    cin &gt;&gt; s;

    s &#x3D; &quot; &quot; + s;
    string res;
    map&lt;int, int&gt; mp;
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        if (s[i] - &#39;a&#39; &lt; k) mp[s[i] - &#39;a&#39;] &#x3D; 1;
        if (mp.size() &#x3D;&#x3D; k)
        &#123;
            res.push_back(s[i]);
            mp.clear();
        &#125;
    &#125;
    if (res.size() &gt;&#x3D; n)    cout &lt;&lt; &quot;YES\n&quot;;
    else
    &#123;
        cout &lt;&lt; &quot;NO\n&quot;;
        if (res.size() &lt; n)
        &#123;
            for (int i &#x3D; 0; i &lt; k; i++)
                if (!mp.count(i))
                &#123;
                    while (res.size() &lt; n)  res.push_back(i + &#39;a&#39;);
                    break;
                &#125;
        &#125;
        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>5.分析：</mark></p>
<ul>
<li><strong>思路：</strong>从大到小排序，如果数字相同为了减少损失，先取前一个数，这样次大值就可以为最大值减1了，这样损失绝对最小。感觉好多人都能猜到答案的长度为 $n$ 了，但是我没想到qwq</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; a(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i], a[i] +&#x3D; i;

        sort(a.begin() + 1, a.end(), greater&lt;&gt;());
        for (int i &#x3D; 2; i &lt;&#x3D; n; i++)    a[i] &#x3D; min(a[i], a[i - 1] - 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    &#125;
    return 0;
&#125;</code></pre>



<h2 id="构造题单"><a href="#构造题单" class="headerlink" title="构造题单"></a>构造题单</h2><blockquote>
<p>构造当然是需要“思维”的，应该没有题不需要思维叭？只是思维强度高低罢力</p>
</blockquote>
<ul>
<li><strong>div3 E 题（差一点就掉分！）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1927/problem/E">E. Klever Permutation</a> <ul>
<li>题意：构造一个排列，使得任意连续长度为 $k$ 的和的差都不大于1。</li>
<li>吐槽：找规律乱试数字导致未果，打表暴力也没找到结果，最终是从题意要求列出一些算是公式吧，找到了其中的奥秘。</li>
<li>正解：1,k+1,2k+1…为一组，然后2,k+2,2k+2,…为第二组，以此类推。然后由于又需要任意差都不大于1，所以就是奇偶交替着依次递增1和依次递减1即可。这题挺锻炼思维的，刚开始看到这题的时候感觉之前做过似的，但一点没印象，这次算真正从头开始思考叭。</li>
</ul>
</li>
</ul>
<h2 id="期望题单"><a href="#期望题单" class="headerlink" title="期望题单"></a>期望题单</h2><blockquote>
<p>最终，还是于 $2024.4.27$ 日推出了这个题单，感觉这次省赛出了好几个关于期望的题目，哎不是很擅长这种题目。而且并不只是省赛，其他邀请赛、区域赛等等都喜欢出这类的题目，因此，我必须出手创造这个题单！</p>
</blockquote>
<p><strong>$2023\ CCPC$ 深圳站银牌题：</strong><a target="_blank" rel="noopener" href="https://vjudge.net/contest/594105#problem/L">L - Mary 有棵有根树 </a></p>
<p><strong>$2024\ ICPC$ 湖北省赛签到题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/105139/problem/J">J. Points on the Number Axis A</a></p>
<p><strong>$2024\ ICPC$ 湖北省赛金牌题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/105139/problem/K">K. Points on the Number Axis B</a></p>
<h2 id="口述型好题"><a href="#口述型好题" class="headerlink" title="口述型好题"></a>口述型好题</h2><blockquote>
<p>所谓口述型好题（没想到一个很好的名字），意思是一种题型看着很常见，但不能及时想出来解法的题目。</p>
</blockquote>
<ul>
<li>给定 $n$ 个数，每个数都有权值，将这 $n(n \le 20)$ 个数划分为 $2$ 个集合，使得集合两边权值和之差最小。<ul>
<li><strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2392">P2392 kkksc03考前临时抱佛脚</a></li>
<li><strong>加强版题目链接：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/76681/G">旗鼓相当的对手</a></li>
<li>思路：暴力或 $dp$ 。</li>
</ul>
</li>
<li>给定一个无向图，可能有多个连通块，请输出一个简单环：满足该环内边权最小的值整体最小。输出最小的边权值和路径。<ul>
<li><strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1927/problem/F">F. Microcycle</a>   <strong>类似题意的另一道题目：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6175">P6175 无向图的最小环问题</a></li>
</ul>
</li>
</ul>
<p><mark>F. Microcycle 讲解：</mark></p>
<p><strong>吐槽：</strong> 不太敢搜索，因为怕超时，还因为自己能想到的搜索时间复杂度太高了，而且还没什么搜索思路。最终 $div3$ 未能成功上篮。</p>
<p><strong>思路：</strong> </p>
<ul>
<li>割边绝对不能成环；</li>
<li>对于一个树，给定两点 $u, v$ ，可以搜索出一条从 $u$ 到 $v$ 的路径；</li>
<li>首先思考下怎么找到这个最小的边：考虑类似 $Kruskal$ 的做法，对边进行排序，然后依次合并，一但出现两个点在同一连通块里，可以知道已经形成了一个环。但我们需要找到或者说是记录最小的边对应的环是哪个。从小到大依次枚举边，一旦出现环，当前的边的权值不是最小的一个，最小权值可能是当前环内某个边权，但不太好处理。不妨考虑从大到小枚举边，这样枚举有一个很好的性质：即一旦出现环，当前边就是该环的最小边权！因此最小边权值就获取了。</li>
<li>接下来考虑如何获得这条路径：考虑合并的时候建边，而在同一连通块内的边不建。这样建成的边就是一个树。当然我们最终会建多棵树。但边权最小的环对应的树也就只有 $1$ 个。因此对于树来找一条 $u$ 到 $v$ 的路径就不难了。</li>
</ul>
<p><strong>代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

template&lt;typename T&gt;
struct DSU &#123;
	vector&lt;T&gt; p, sz;
	DSU(T n) : p(n), sz(n, 1) &#123; iota(p.begin(), p.end(), 0); &#125;
	&#x2F;&#x2F;初始化
	void init(int n) &#123;
		p.resize(n);
		iota(p.begin(), p.end(), 0);
		sz.assign(n, 1);
	&#125;
	&#x2F;&#x2F;找父节点
	T find(T x) &#123;
		while (x !&#x3D; p[x]) x &#x3D; p[x] &#x3D; p[p[x]];
		return x;
	&#125;
	&#x2F;&#x2F;合并集合
	bool merge(T x, T y) &#123;
		x &#x3D; find(x);
		y &#x3D; find(y);
		if (x &#x3D;&#x3D; y) return false;
		sz[x] +&#x3D; sz[y];
		p[y] &#x3D; x;
		return true;
	&#125;
	&#x2F;&#x2F;判断是否同一集合
	bool same(T x, T y) &#123; return find(x) &#x3D;&#x3D; find(y); &#125;
	&#x2F;&#x2F;集合大小
	T size(T x) &#123; return sz[find(x)]; &#125;
&#125;;

void solve()
&#123;
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;

	vector&lt;array&lt;int, 3&gt;&gt; Edges(m + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
	&#123;
		cin &gt;&gt; Edges[i][1] &gt;&gt; Edges[i][2] &gt;&gt; Edges[i][0]; 
	&#125;

	sort(Edges.begin() + 1, Edges.end(), greater&lt;&gt;());

	DSU&lt;int&gt; dsu(n + 1);
	int res &#x3D; 1e9, st &#x3D; -1, ed &#x3D; -1;
	vector&lt;vector&lt;int&gt;&gt; g(n + 1);
	for (auto [w, u, v] : Edges)
	&#123;
		if (!dsu.merge(u, v))
		&#123;
			res &#x3D; w;
			st &#x3D; u, ed &#x3D; v;
		&#125;
		else
		&#123;
			g[u].push_back(v);
			g[v].push_back(u);
		&#125;
	&#125;

	vector&lt;int&gt; path;
	function&lt;bool(int, int)&gt; dfs &#x3D; [&amp;](int u, int fa) -&gt; bool
	&#123;
		path.push_back(u);
		if (u &#x3D;&#x3D; ed)	return true;

		for (auto v : g[u])
		&#123;
			if (v &#x3D;&#x3D; fa)	continue;
			if (dfs(v, u))	return true;
			path.pop_back();
		&#125;
		return false; &#x2F;&#x2F; 现在匿名函数非void返回类型好像必须要return, 不然会MLE，变正规了
	&#125;;

	dfs(st, -1);

	cout &lt;&lt; res &lt;&lt; &quot; &quot; &lt;&lt; path.size() &lt;&lt; &quot;\n&quot;;
	for (auto x : path)	cout &lt;&lt; x &lt;&lt; &quot; \n&quot;[x &#x3D;&#x3D; path.back()];
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int t;
	cin &gt;&gt; t;

	while (t--)
	&#123;
		solve();
	&#125;
	
	return 0;
&#125;</code></pre>



<h2 id="递归（包括分治、归并）好题"><a href="#递归（包括分治、归并）好题" class="headerlink" title="递归（包括分治、归并）好题"></a>递归（包括分治、归并）好题</h2><ul>
<li><p><strong>DP + 递归建树（难点在于建树思想 + 如何递归不RE &#x2F; MLE）</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI2006] 三色二叉树</a></p>
</li>
<li><p><strong>天梯赛 $L2$ 递归题（困扰一年后才解决qwq，主要没分析对时间复杂度）：<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772841508874?type=7&page=1">L2-047 锦标赛</a></strong></p>
</li>
<li><p><strong>$2023\ ICPC$ 西安站铜牌题（归并思想）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/476283/problem/H">H. Elimination Series Once More</a></p>
</li>
<li><p><strong>$2023\ CCPC$ 深圳站铜牌题（分治思想，但绝不能分块！）：</strong><a target="_blank" rel="noopener" href="https://vjudge.net/contest/594105#problem/A">A - 一道好题 </a></p>
</li>
</ul>
<hr>
<p><mark>下面是讲解：</mark></p>
<ul>
<li><strong>DP + 递归建树（难点在于建树思想 + 如何递归不RE &#x2F; MLE）</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI2006] 三色二叉树</a><ul>
<li>该题目一共交了 $10$ 多发，不是 $RE$ 就是 $MLE$，感觉写法基本一样，但为何总是出错？找到问题了，还是匿名函数求 $dp$ 的问题，$build$ 没改，仅还是把匿名函数的 $int$ 改为 $void$ 就行了，为什么这么神奇？</li>
<li>$why$ 好？递归建树消耗自己太多时间！建不明白，还一堆$RE &#x2F; MLE$ ！<ul>
<li>找到原因了，匿名函数返回值写成了 $int$ 导致 $MLE$，改成 $void$ 就 $AC$ 了！</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    cin &gt;&gt; s;

    int n &#x3D; s.size();
    s &#x3D; &quot; &quot; + s;

    vector&lt;vector&lt;int&gt;&gt; g(2 * n + 2, vector&lt;int&gt;(2));
    int cur &#x3D; 1, idx &#x3D; 1;
    function&lt;void(int)&gt; build &#x3D; [&amp;](int u) -&gt; void
    &#123;
        int op &#x3D; s[cur++] - &#39;0&#39;;
        if (op &gt;&#x3D; 1)    g[u][0] &#x3D; ++idx, build(g[u][0]);
        if (op &#x3D;&#x3D; 2)    g[u][1] &#x3D; ++idx, build(g[u][1]);
    &#125;;

    build(1);

    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2));
    vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(2));
    &#x2F;**
     * dp[i][0]: 以i为根，且颜色不是绿色: dp[i][0] &#x3D; max(dp[v1][0] + d[v2][1], dp[v1][1] + dp[v2][0]);
     * dp[i][1]: 以i为根，且颜色是绿色: dp[i][1] &#x3D; dp[v1][0] + dp[v2][0] + 1
    *&#x2F;
    function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
    &#123;
        dp[u][1] &#x3D; f[u][1] &#x3D; 1;
        if (g[u][0])    dfs(g[u][0]);
        if (g[u][1])    dfs(g[u][1]);
        
        dp[u][0] &#x3D; max(dp[g[u][0]][0] + dp[g[u][1]][1], dp[g[u][0]][1] + dp[g[u][1]][0]);
        dp[u][1] &#x3D; dp[g[u][0]][0] + dp[g[u][1]][0] + 1;
        f[u][0] &#x3D; min(f[g[u][0]][0] + f[g[u][1]][1], f[g[u][0]][1] + f[g[u][1]][0]);
        f[u][1] &#x3D; f[g[u][0]][0] + f[g[u][1]][0] + 1;
    &#125;;

    dfs(1);

    cout &lt;&lt; max(dp[1][0], dp[1][1]) &lt;&lt; &quot; &quot; &lt;&lt; min(f[1][0], f[1][1]) &lt;&lt; &quot;\n&quot;;

    return 0;
&#125;</code></pre>

<ul>
<li><p><strong>天梯赛 $L2$ 递归题（困扰一年后才解决qwq，主要没分析对时间复杂度）：<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772841508874?type=7&page=1">L2-047 锦标赛</a></strong></p>
</li>
<li><p>其实思路这一年一直都一样，没有变过。最后也确实是对的，没做出来的原因有2：</p>
<ul>
<li>1、不太会建树，比如说下标该怎么索引，怎么遍历？<ul>
<li>2、如果匹配不成功，就得回溯，时间复杂度应该不够吧？有没有一次遍历就能知道答案的？</li>
</ul>
</li>
</ul>
</li>
<li><p>下面对上面这两个问题进行解决：</p>
<ul>
<li><p>1、我是按照自己理解的方式去建图，可能并不优，但确实也不是太麻烦。每一场比赛有 $2$ 个人，当成 $1$ 个结点，因为是满二叉树，如果根节点编号为 $1$，两个孩子的编号就是 $2, 3$，即 $2\times u, 2\times u + 1$，因此我们从最后一场比赛开始赋值为 $1$，每个点存两个值即可，最后遍历到最后一场比赛，就能得知每个选手的成绩。</p>
</li>
<li><p>2、考虑最坏的情况，如果到最后一层（$logn$ 层）发现不合法，则最多往上跳到第 $1$ 层，接着如果还是最后一层不合法，则最多往上只能跳到第 $2$ 层，不能再往上了因为上一层的所有情况（最多 $2$ 种情况）已经遍历清楚了，因此：</p>
<ul>
<li>$1+\cdots+logn + 2 + \cdots + logn + \cdots ≈ 4NlogN$，大致是结合线段树的情况进行分析的，自己分析的，可能不太标准qwq</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 1e6 + 10, M &#x3D; 20;

int k;
pii a[M][N];
pii id[N];
&#x2F;&#x2F; 将每一场比赛当做一个结点
bool dfs(int u)
&#123;
    if (u * 2 &gt;&#x3D; (1 &lt;&lt; k))  return true;
    int l &#x3D; id[u].first, r &#x3D; id[u].second;
    int mi &#x3D; a[l][r].first, mx &#x3D; a[l][r].second;
    int nxl_mi &#x3D; a[l - 1][2 * r - 1].first, nxr_mi &#x3D; a[l - 1][2 * r].first;
    &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; mi &lt;&lt; &quot; &quot; &lt;&lt; mx &lt;&lt; &quot; &quot; &lt;&lt; nxl_mi &lt;&lt; &quot; &quot; &lt;&lt; nxr_mi &lt;&lt; &quot;\n&quot;;

    &#x2F;&#x2F; 第一种放法
    if (mi &gt;&#x3D; nxl_mi &amp;&amp; mx &gt;&#x3D; nxr_mi)
    &#123;
        a[l - 1][2 * r - 1].second &#x3D; mi, a[l - 1][2 * r].second &#x3D; mx;
        if (dfs(2 * u) &amp;&amp; dfs(2 * u + 1)) return true;
        a[l - 1][2 * r - 1].second &#x3D; 0, a[l - 1][2 * r].second &#x3D; 0;
    &#125;

    &#x2F;&#x2F; 第二种放法
    if (mx &gt;&#x3D; nxl_mi &amp;&amp; mi &gt;&#x3D; nxr_mi)
    &#123;
        a[l - 1][2 * r - 1].second &#x3D; mx, a[l - 1][2 * r].second &#x3D; mi;
        if (dfs(2 * u) &amp;&amp; dfs(2 * u + 1)) return true;
        a[l - 1][2 * r - 1].second &#x3D; 0, a[l - 1][2 * r].second &#x3D; 0;
    &#125;

    return false;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; k;
    for (int i &#x3D; 1; i &lt;&#x3D; k; i++)
    &#123;
        int idx &#x3D; 1 &lt;&lt; (k - i);
        for (int j &#x3D; 1; j &lt;&#x3D; 1 &lt;&lt; (k - i); j++)
        &#123;
            cin &gt;&gt; a[i][j].first;
            id[idx++] &#x3D; &#123;i, j&#125;;
        &#125;
    &#125;
    cin &gt;&gt; a[k][1].second;

    if (a[k][1].second &lt; a[k][1].first || !dfs(1))  cout &lt;&lt; &quot;No Solution\n&quot;;
    else
    &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; 1 &lt;&lt; (k - 1); i++)   cout &lt;&lt; a[1][i].first &lt;&lt; &quot; &quot; &lt;&lt; a[1][i].second &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; (1 &lt;&lt; (k - 1))];
    &#125;
    
    return 0;
&#125;</code></pre>



<p><strong>$2023\ CCPC$ 深圳站铜牌题（分治思想，但绝不能分块！）：</strong><a target="_blank" rel="noopener" href="https://vjudge.net/contest/594105#problem/A">A - 一道好题 </a></p>
<p><strong>吐槽：</strong>首先，这绝对是一道好题！本来挺容易想的，就是可以想到很多种做法，但最后发现这些做法都被 $hack$ 了，因为时间复杂度不对！</p>
<ul>
<li>第一次尝试：我直接暴力去往上加，能同时加的话就同时加，看着挺“贪心”的方法，结果确实会超时（自己造了一个从 $1$ 开始的每次递增 $1$ 的样例，发现次数很大很大）。</li>
<li>第二次尝试：想着分块去搞，以为 $\sqrt n$ 应该够小了，没有仔细去算具体是多少的数值，直到写完后发现还是那个样例过不去，虽然已经优化到 $3e4$ 左右的次数了，但确实一想，$n\sqrt n$ 还是会超过 $2e4$，写了这么久，为什么不多分析一下时间复杂度在写？</li>
<li>第三次尝试：我看了下题解，发现是分治，确实这种数据范围就得 $log$。这是一个数值分治的题目，想清楚之后，也不需要之前那么复杂的写法，会自带一个很巧妙的写法，最后测试了那个样例，只需要 $8000$ 多次就可以了！交一发，终于过了！</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

using pii &#x3D; pair&lt;int, int&gt;;

constexpr int N &#x3D; 1010;

vector&lt;int&gt; gb[N];

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n;
	cin &gt;&gt; n;

	vector&lt;pii&gt; b(n + 1);
	int mx &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	
	&#123;
		cin &gt;&gt; b[i].first;
		b[i].second &#x3D; 0;
		mx &#x3D; max(mx, b[i].first);
		gb[b[i].first].push_back(i);
	&#125;
	
	vector&lt;pii&gt; res;
	function&lt;void(int, int)&gt; dfs &#x3D; [&amp;](int l, int r) -&gt; void
	&#123;
		if (l &gt; r)	return;

		int mid &#x3D; l + r &gt;&gt; 1, cur &#x3D; -1;
		for (int i &#x3D; mid; i &lt;&#x3D; r; i++) &#x2F;&#x2F; 将大于等于mid的全部提升到mid
		&#123;
			for (auto x : gb[i])
			&#123;
				if (b[x].second &gt;&#x3D; mid)	continue;
				res.push_back(&#123;2, x&#125;);
				b[x].second++;
				cur &#x3D; b[x].second;
			&#125;
		&#125;

		if (cur !&#x3D; -1)
		&#123;
			int len &#x3D; mid - cur;
			for (int i &#x3D; 1, num &#x3D; cur; i &lt;&#x3D; len; i++, num++)
			&#123;
				res.push_back(&#123;1, num&#125;);
			&#125;
			for (int i &#x3D; mid; i &lt;&#x3D; r; i++)
			&#123;
				for (auto x : gb[i])
				&#123;
					b[x].second +&#x3D; len;
				&#125;
			&#125;
		&#125;

		dfs(l, mid - 1);
		dfs(mid + 1, r);
	&#125;;

	dfs(0, mx);

	cout &lt;&lt; res.size() &lt;&lt; &quot;\n&quot;;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	assert(b[i].first &#x3D;&#x3D; b[i].second);
	assert(res.size() &lt;&#x3D; 20000);
	for (auto [x, y] : res)	
		cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;

	return 0;
&#125;</code></pre>



<h2 id="数据分治题单"><a href="#数据分治题单" class="headerlink" title="数据分治题单"></a>数据分治题单</h2><p><strong>$2023CCPC$ 桂林站签到题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/K">K. Randias Permutation Task</a></p>
<p><mark>$2023CCPC$ 桂林签到详解：</mark></p>
<blockquote>
<p><strong>思路：</strong>数据范围 $n × m \le 180$：</p>
<p>1、如果 $m$ 为大约 $20$ 的话可以 $2^{20}$ 暴力枚举（实际可能容易超时，因为这个也有点极限，略微降低 $m$ 就行）</p>
<p>2、如果 $m$ 很大，比如40，那么就不能枚举了，但此时 $n$ 的范围就小了，那该怎么写呢？（好难，因为突然就不会写了，然后根据题解的印象和知乎聊的一些做法，$dp$ 确实能做，但还真没想到，但这么一想 $dp$ 又确实可以，真的太神奇了）。$dp$ 为前 $i$ 个数选与不选的集合方案，暴力维护即可。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;int&gt;&gt; g(m + 1, vector&lt;int&gt;(n + 1)); 
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
            cin &gt;&gt; g[i][j];

    auto solve1 &#x3D; [&amp;]() -&gt; void
    &#123;
        set&lt;string&gt; S;
        auto insert &#x3D; [&amp;](vector&lt;int&gt; a) -&gt; void
        &#123;
            string s;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                s.push_back(char(a[i] + &#39;0&#39;));
            S.insert(s);
        &#125;;
        auto merge &#x3D; [&amp;](vector&lt;int&gt; a, vector&lt;int&gt; b) -&gt; vector&lt;int&gt;
        &#123;
            vector&lt;int&gt; res(n + 1);
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                res[i] &#x3D; a[b[i]];
            return res;
        &#125;;
        for (int i &#x3D; 1; i &lt; 1 &lt;&lt; m; i++)
        &#123;
            vector&lt;int&gt; v(n + 1);
            for (int j &#x3D; 0; j &lt; m; j++)
            &#123;
                if (i &gt;&gt; j &amp; 1)
                &#123;
                    if (v[1] &#x3D;&#x3D; 0)  v &#x3D; g[j + 1];
                    else    v &#x3D; merge(v, g[j + 1]);
                &#125;
            &#125;
            if (v[1])   insert(v);
        &#125;
        cout &lt;&lt; S.size() &lt;&lt; &quot;\n&quot;;
    &#125;;

    auto solve2 &#x3D; [&amp;]() -&gt; void
    &#123;
        vector&lt;set&lt;string&gt;&gt; f(m + 1);
        auto merge &#x3D; [&amp;](set&lt;string&gt; S, vector&lt;int&gt; a) -&gt; set&lt;string&gt;
        &#123;
            set&lt;string&gt; res &#x3D; S;
            auto insert &#x3D; [&amp;](vector&lt;int&gt; v) -&gt; void
            &#123;
                string s;
                for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                    s.push_back(char(v[i] + &#39;0&#39;));
                res.insert(s);
            &#125;;
            auto get &#x3D; [&amp;](string s) -&gt; vector&lt;int&gt;
            &#123;
                vector&lt;int&gt; a(n + 1);
                for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                    a[i] &#x3D; s[i - 1] - &#39;0&#39;;
                return a;
            &#125;;
            insert(a);
            for (auto x : S)
            &#123;
                vector&lt;int&gt; t &#x3D; get(x);
                vector&lt;int&gt; v(n + 1);
                for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                &#123;
                    v[i] &#x3D; t[a[i]];
                &#125;
                insert(v);
            &#125;
            return res;
        &#125;;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        &#123;
            f[i] &#x3D; f[i - 1];
            f[i] &#x3D; merge(f[i], g[i]);
        &#125;
        cout &lt;&lt; f[m].size() &lt;&lt; &quot;\n&quot;;
    &#125;;

    if (m &lt;&#x3D; 15)    solve1();
    else    solve2();

    return 0;
&#125;</code></pre>



<h2 id="循环移位题单"><a href="#循环移位题单" class="headerlink" title="循环移位题单"></a>循环移位题单</h2><p>打 $cf$ 遇到 $C$ 题总是寄？多学点循环移位的题！</p>
<p><mark>推荐题单：</mark></p>
<p><strong>找规律：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1894/problem/C">C. Anonymous Informant</a></p>
<p><strong>建图：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1867/problem/D">D. Cyclic Operations</a></p>
<p><strong>没有移位，但是很循环！（待考古）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1848/problem/C">C. Vika and Price Tags</a></p>
<p><strong>2023 湘潭邀请赛（CCPC）签到题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104396/problem/A">A. Today’s Word</a></p>
<p><strong>2023 南京站 ICPC 签到题（待考古）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104813/problem/L">L. Palm Island</a></p>
<p><strong>一场高质量 div3 的 F 题目（待补）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1907/problem/F">F. Shift and Reverse</a></p>
<p><strong>一道循环典题（赛后立马就写出来了）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1920/problem/D">D. Array Repetition</a></p>
<p><mark>Anonymous Informant 讲解：</mark></p>
<blockquote>
<p><strong>题意：</strong> 给定长度为 $n$ 的数组 $b$，它是由 $a$ 数组经过 $k$ 次操作得到的，问 $b$ 数组是否合法？</p>
<p>操作：任选 $a$ 数组的一个元素 $x$，满足 $a_x &#x3D; x$，然后将数组整体循环左移 $x$ 位。</p>
<p><strong>思路：</strong> </p>
<ul>
<li>经过手玩可以发现，一个可以被选择的数，经过循环移位后，该数一定落在了最后一个位置。</li>
<li>题目给了答案数组 $b$，我们应该要想到从答案数组逆推回去，如果这种逆操作可以执行完 $k$ 次，显然是合法的。</li>
<li>那么因为每次操作，合法数字一定在最后一个位置，因此，我们从最后一个位置入手，推下一个落在最后一个位置的数字是谁，位置在哪，一直往前推，直到无法操作即可，一旦遇到之前出现过的下标位置，则出现循环节，表明序列合法，可以一直操作下去。</li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    map&lt;int, int&gt; mp;
    function&lt;bool(int, int)&gt; dfs &#x3D; [&amp;](int pos, int k) -&gt; bool
    &#123;
        if (k &#x3D;&#x3D; 0) return true;

        if (1 &lt;&#x3D; a[pos] &amp;&amp; a[pos] &lt;&#x3D; n)
        &#123;
            if (mp.count(pos))  return true;
            mp[pos]++;
            int nxt &#x3D; (pos - a[pos] + n) % n;
            nxt &#x3D; nxt &#x3D;&#x3D; 0 ? n : nxt;
            return dfs(nxt, k - 1);
        &#125;
        return false;
    &#125;;
    
    cout &lt;&lt; (dfs(n, k) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    
    int t;
    cin &gt;&gt; t;

    while (t--) solve();

    return 0;
&#125;</code></pre>

<p><mark>D. Cyclic Operations 讲解：</mark></p>
<blockquote>
<p><strong>题意：</strong> 给点长度为 $n$ 的数组，其元素都为 $0$ ，请任选长度为 $k$ 的数组 $l$（每个数互不相同），改变每个元素：$a_{l_i} &#x3D; l_{i % k + 1}$ 后，能得到给的数组 $b$。</p>
<p><strong>思路：</strong></p>
<p>已知： $a_{l_i} &#x3D; l_{i%k+1}$</p>
<p>又由于需要令 $a_j &#x3D; b_j$，即：<br>$a_{l_i} &#x3D; l_{i%k+1} &#x3D; b_{l_i}$</p>
<p>对于：$b_1,b_2,\cdots b_n$</p>
<p>要与  $a_1,a_2,\cdots a_n$ 与之对应</p>
<p>则 $a_1 &#x3D; b_1$，又 $a_{l_i} &#x3D; l_{i%k+1}$，则构造 $k$ 个长度的 $l$ 数组时（$k \ge 2$，$k &#x3D; 1$ 只能顺序 $1,2,\cdots n$）可以构造出 $1,b_1,\cdots$，则满足：$a_{l_i} &#x3D; l_{i%k+1} &#x3D;&gt; a_1 &#x3D; b_1$，可以想象成有一条有向边 $1-&gt;b_1$。</p>
<p>同理，有：$2-&gt;b_2,3-&gt;b_3,\cdots,n-&gt;b_n$。于是，图就建立好了。</p>
<p><strong>证明合法性：</strong></p>
<p>如果 $k &#x3D; 1$：则显然只能是 $1,2,3,\cdots,n$ 的序列；</p>
<p>如果 $k &gt; 1$：</p>
<ul>
<li>如果 $k &lt; $  环长：则需要若干次 $k$ 去尽力填充这个环，当最后一次填满这个环时，一定会覆盖这个环上原本的数；</li>
<li>如果 $k &gt; $ 环长：则一次就会溢出这个环，同时也会覆盖这个环上原本的数。</li>
</ul>
<p>上面所说的覆盖环上原本的数可能书面上写起来比较抽象，不妨在纸上试一试！</p>
<p><strong>实现细节：</strong> </p>
<p>细节1：每个点都有一个出边，当一个环是成功的之后，可能有多个点的出边都指向这个环，那么当第二个天进入这个环后需要跳过，不然就会导致死循环；</p>
<p>细节2：自环问题也是不能忽略的，环的长度必须等于 $k$，如果 $k$ 不为 $1$ 的话，即使每个点各自形成环也是不行的，因为如果能凑出的话需要 $k$ 个数相同，但根据题意是互不相同的，故自环也要考虑。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;int&gt; a(n + 1);
    vector&lt;vector&lt;int&gt;&gt; adj(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i], adj[i].push_back(a[i]);

    bool ok &#x3D; true;
    if (k &#x3D;&#x3D; 1)
    &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            if (a[i] !&#x3D; i)  
            &#123;
                ok &#x3D; false;
                break;
            &#125;
        return cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;), void();
    &#125;

    vector&lt;int&gt; st(n + 1);
    vector&lt;int&gt; fa(n + 1);
    function&lt;bool(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; bool
    &#123;
        st[u] &#x3D; 1;
        for (auto v : adj[u])
        &#123;
            if (!st[v])
            &#123;
                fa[v] &#x3D; u;
                if(!dfs(v)) return false;
            &#125;
            else if (st[v] &#x3D;&#x3D; 2)    continue;
            else
            &#123;
                int x &#x3D; u, len &#x3D; 1;
                while (x !&#x3D; v)
                &#123;
                    x &#x3D; fa[x];
                    len++;
                &#125;
                if (len !&#x3D; k)   return false;
            &#125;
        &#125;
        st[u] &#x3D; 2;
        return true;
    &#125;;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        if (!st[i])
        &#123;
            ok &#x3D; dfs(i);
            if (!ok)    break;
        &#125;
    
    cout &lt;&lt; (ok ? &quot;YES\n&quot; : &quot;NO\n&quot;);
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>2023 湘潭邀请赛（CCPC）签到题：A. Today’s Word</mark></p>
<p><strong>思路：</strong></p>
<ul>
<li>显然，当字符串增大到一定程度的时候（长度 $\ge 2m$ ），答案会是以最后 $m$ 为循环。</li>
<li>暴力获取这个长度的字符串，每次增长是 $2$ 倍的关系，因此增长循环是 $log$，单个增长里面长度循环 $2$ 倍。时间复杂度即为：$O(NlogN)$。</li>
<li>最后的循环，虽然是 $10^{100}$，但快速幂很快就可以得到，而且模数是隐式的 $26$，由此，答案解决。</li>
</ul>
<p><strong>赛后补题的小吐槽：</strong></p>
<ul>
<li>交了 $23$ 发才过，第一次失误是因为字符加上循环节的计算出了问题，导致结果都不是小写英文字母了，太逆天了。</li>
<li>发现了后，没想到字符串截取的时候写成了 $s.size() - 1$，长度没取够，导致一直在尝试着其他的问题，直到最后才发现（打印输出）我的字符串截取少了 $qwq$，最后终于过了，这题还算比较 $easy$ 的，不过挺智慧的一道题。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

ll fpow(ll a,ll b, int mod)
&#123;
   ll res &#x3D; 1;
   a %&#x3D; mod;
   while(b)
   &#123;
       if(b &amp; 1)   res &#x3D; res * a % mod;
       a &#x3D; a * a % mod;
       b &gt;&gt;&#x3D; 1;
   &#125;
   return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    string s;
    cin &gt;&gt; s;

    int cnt &#x3D; 0;
    while (n &lt; 2 * m)
    &#123;
        string l &#x3D; s.substr(0, n &#x2F; 2), r &#x3D; s.substr(n &#x2F; 2);
        for (auto &amp;c : r)   
            c &#x3D; (c &#x3D;&#x3D; &#39;z&#39; ? &#39;a&#39; : c + 1);
        n *&#x3D; 2;
        s &#x3D; l + s + r;
        cnt++;
    &#125;

    int t &#x3D; ((fpow(10, 100, 26) - cnt) % 26 + 26) % 26;

    string res;
    for (int i &#x3D; s.size() - m; i &lt; s.size(); i++)
    &#123;
        char c &#x3D; ((s[i] + t) % &#39;a&#39;) % 26 + &#39;a&#39;;
        res +&#x3D; c;
    &#125;

    cout &lt;&lt; res;
    return 0;
&#125;</code></pre>

<p><mark>D. Array Repetition 讲解：</mark></p>
<p><strong>题意：</strong>初始数组为空，有两个操作，操作1：往数组末尾添加 1 个数；操作2：将数组整体复制 $x$ 份添加到末尾。问第 $k$ 个数是多少？</p>
<p><strong>思路：</strong> 存每个块的长度和操作，即对第一个操作，存信息为：[l: 1, r: 1, x &#x3D; x]，第二个操作存信息：[l: 1, r: n, cnt &#x3D; cnt]，然后还要存每个块的大小。这样我们就可以从后往前递归出具体的块的位置，即递归二分位置即可。由于可能会爆 $long\ long$，这里有一个好的做法就是用除法！类似试除法：i &lt;&#x3D; x &#x2F; i ，并标记最后一个位置是第几个即可，整体来说，思路是能想到的了，1e18这个大数据可能会导致细节不好处理，因此需要多知道一些处理小技巧。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

struct Block
&#123;
    ll l, r;
    ll x, cnt;
&#125;;

int main()
&#123;
    IOS;
    cf (_)
    &#123;
        int n, q;
        cin &gt;&gt; n &gt;&gt; q;

        ll cur_id &#x3D; 1;
        vector&lt;Block&gt; block(n + 1);
        vector&lt;ll&gt; length(n + 1);
        int final_end &#x3D; n;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            int op, x;
            cin &gt;&gt; op &gt;&gt; x;
            if (final_end !&#x3D; n) continue;

            if (op &#x3D;&#x3D; 1)
            &#123;
                block[i] &#x3D; &#123;cur_id, cur_id, x, 0&#125;;
                length[i] &#x3D; 1;
                cur_id++;
            &#125;
            else
            &#123;
                if (x &gt;&#x3D; 1e18 &#x2F; (cur_id - 1))
                &#123;
                    ll r &#x3D; 1e18;
                    block[i] &#x3D; &#123;cur_id, (ll)r, 0, x&#125;;
                    length[i] &#x3D; r;
                    final_end &#x3D; i;
                &#125;
                else
                &#123;
                    ll r &#x3D; cur_id + x * (cur_id - 1) - 1;
                    block[i] &#x3D; &#123;cur_id, r, 0, x&#125;;
                    length[i] &#x3D; x * (cur_id - 1);
                    cur_id +&#x3D; x * (cur_id - 1);
                &#125;
            &#125;
        &#125;
        
        vector&lt;ll&gt; sum(final_end + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; final_end; i++)    
        &#123;
            sum[i] &#x3D; min((ll)2e18, sum[i - 1] + length[i]);
        &#125;

        for (int id &#x3D; 1; id &lt;&#x3D; q; id++)
        &#123;
            ll k;
            cin &gt;&gt; k;

            function&lt;int(int, int, ll)&gt; dfs &#x3D; [&amp;](int ql, int qr, ll k) -&gt; int
            &#123;
                int l &#x3D; ql, r &#x3D; qr;
                while (l &lt; r)
                &#123;
                    int mid &#x3D; l + r &gt;&gt; 1;
                    if (sum[mid] &gt;&#x3D; k)  r &#x3D; mid;
                    else    l &#x3D; mid + 1;
                &#125;
                if (block[l].cnt &#x3D;&#x3D; 0)  return block[l].x;
                ll kth &#x3D; k - sum[l - 1];
                kth %&#x3D; sum[l - 1];
                if (kth &#x3D;&#x3D; 0)   kth &#x3D; sum[l - 1];
                return  dfs(1, l - 1, kth);
            &#125;;        

            cout &lt;&lt; dfs(1, final_end, k) &lt;&lt; &quot; \n&quot;[id &#x3D;&#x3D; q];
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<h2 id="动态规划好题"><a href="#动态规划好题" class="headerlink" title="动态规划好题"></a>动态规划好题</h2><p>$tag1$：给定 $01$ 串，问满足指定构造要求的串有多少个？<strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1920/problem/E">E. Counting Binary Strings</a></p>
<p>$tag2$：有 $n$ 个开着的路灯，路灯在不同的位置，有不同的功率消耗，最初在某一个路灯下，可以向左或向右关闭路灯，问消耗的功率最小是多少？<strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯</a></p>
<p>$tag3$：给定有向图（可能有重边和自环），每条边的边长为 $1$，问从 $1$ 号点到 $n$ 号点，所有距离中，二进制中 $1$ 的数量最少是多少（这个描述是根据题意想出的）？<strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1613">P1613 跑路</a></p>
<hr>
<p><mark>$tag1$ 做法思路：</mark></p>
<p><strong>1、对于一个构造好的串，其有多少子串满足 $exactly\ one\ 1$？</strong></p>
<ul>
<li>形如这样的串：0001001001，可以看出有3“段”，长度分别为4,4,4，有个公式，对于 m 段，有：$\sum_{i&#x3D;1}^{m-1}a_ia_{i+1}$ 个子串是满足的（这个公式可能确实不是很好直接看出来）；</li>
</ul>
<p><strong>2、如何定义状态（重点）？</strong></p>
<ul>
<li>令 $f[i][j]$ 为：前 $i$ 个数，最后一段为 $j$ 的方案数。根据上一段是多少，可以得出递推表达式：<ul>
<li>$f[i][j] &#x3D; f[i][j] + f[i - j × last][last]$</li>
</ul>
</li>
<li>初始化：$f[0][i] &#x3D; 1$，其中 $i \in [1,k]$ </li>
<li>最终答案即为：$\sum_{i}^{k}f[n][i]$</li>
</ul>
<p><strong>3、时间复杂度</strong></p>
<ul>
<li>枚举上一状态时，表面上有 $k$ 次，其实还需满足 $j × last \le i$，即 $last$ 总枚举次数：$\lfloor \frac{i}{1} \rfloor + \lfloor \frac{i}{2} \rfloor + \cdots + \lfloor \frac{i}{i} \rfloor\approx ilogi$ </li>
<li>故总时间复杂度为：$nklogn$</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 998244353;

void solve()
&#123;
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(k + 1));
    &#x2F;*
    想法：
    1. 给定一个串，有多少满足的子串?
    2. 定义状态: 前i段, &quot;最后一段&quot;长度为j的方案数
    f[i][j] &#x3D; f[i - last * j][last]
    *&#x2F;
    for (int i &#x3D; 1; i &lt;&#x3D; k; i++)    f[0][i] &#x3D; 1;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 1; j &lt;&#x3D; k; j++)
        &#123;
            for (int last &#x3D; 1; last &lt;&#x3D; k &amp;&amp; j * last &lt;&#x3D; i &amp;&amp; last + j - 1 &lt;&#x3D; k; last++)
            &#123;
                f[i][j] &#x3D; (f[i][j] + f[i - j * last][last]) % mod;
            &#125;
        &#125;
    &#125;

    ll res &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; k; i++)
        res &#x3D; (res + f[n][i]) % mod;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>$tag2$ 做法思路：</mark></p>
<p><strong>1、如何定义 $dp$ 状态？</strong></p>
<ul>
<li>为什么会突然想到 $dp$ ？因为往左或往后结果是不同的，贪心是不可能贪出结果的。</li>
<li>一般直接来想都是定义 $dp[1][n]$ 即关闭完区间 $[1, n]$ 所有路灯后的最小功率值。但是每次转移都有依赖性，比如上次从 $1$ 走到了 $4$，那么在这种情况下还得再从 $4$ 接着走下去，就觉得没有什么思路，上一次的状态找不到。</li>
<li>每次向左和向右可以提示到再加一维，即 $dp[i][j][0&#x2F;1]$，用来表示方向。但还是不能继续进行下去。why？因为漏了一个重点：$dp[1][n]$ 一定是走到了某个端点（$1$ 或 $n$），因为一旦走到其中一个端点，那么接下来他一定会继续朝着另一个端点走到尽头！因此： $dp[1][n][0]$ 表示关闭完区间 $[1,n]$ 的路灯，并停在 $1$ 号点上，同理， $dp[1][n][1]$ 是停在了 $n$ 号点上，这是解决这道题的关键。</li>
</ul>
<p><strong>2、怎么状态转移？</strong></p>
<ul>
<li>$dp[l][r]$ 上一步是从 $dp[l + 1][r]$ 转移过来的，也可能是从 $dp[l][r - 1]$ 转移过来的。</li>
<li>再加上方向后，有如下公式：<ul>
<li>$dp[l][r][0] &#x3D; min(dp[l + 1][r][0] + val1, dp[l + 1][r][1] + val2)$</li>
<li>$dp[l][r][1] &#x3D; min(dp[l][r - 1][1] + val1, dp[l][r - 1][0] + val2)$</li>
</ul>
</li>
</ul>
<p><strong>3、时间复杂度：$O(n^2)$​</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, p;
    cin &gt;&gt; n &gt;&gt; p;

    vector&lt;int&gt; pos(n + 1), cost(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; pos[i] &gt;&gt; cost[i];

    vector&lt;int&gt; sum(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    sum[i] &#x3D; sum[i - 1] + cost[i];

    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1, vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(2, 1e9)));
    f[p][p][0] &#x3D; f[p][p][1] &#x3D; 0;
    for (int l &#x3D; n; l &gt;&#x3D; 1; l--)
    &#123;
        for (int r &#x3D; l; r &lt;&#x3D; n; r++)
        &#123;
            if (l &#x3D;&#x3D; r) continue;
            
            if (l + 1 &lt;&#x3D; n) 
            &#123;
                int w &#x3D; sum[l] + sum[n] - sum[r];
                f[l][r][0] &#x3D; min(f[l + 1][r][0] + (pos[l + 1] - pos[l]) * w, f[l + 1][r][1] + (pos[r] - pos[l]) * w);
            &#125;
            int w &#x3D; sum[l - 1] + sum[n] - sum[r - 1];
            f[l][r][1] &#x3D; min(f[l][r - 1][1] + (pos[r] - pos[r - 1]) * w, f[l][r - 1][0] + (pos[r] - pos[l]) * w);
        &#125;
    &#125;
    cout &lt;&lt; min(f[1][n][0], f[1][n][1]) &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>$tag3$ 做法思路：</mark></p>
<p><strong>1、吐槽：</strong></p>
<ul>
<li>最初想法是：在所有 $1$ ~ $n$ 路径中，取出所有路径，然后找到路径的环，对自环进行特判 $\cdots$ 但是太麻烦了，而且实现起来可能还很容易出错，类似分类讨论。</li>
</ul>
<p><strong>2、正解：</strong></p>
<ul>
<li>倍增处理 $i$ 到 $j$ 是否能在 $2^k$ 下可达。如果可达，显然是 $1$ 的贡献，预处理完所有情况后，重新建图，然后跑从 $1$ 到 $n$ 的最短路即可。</li>
<li>怎么倍增进行 $dp$ 处理呢？<ul>
<li>最初对于已有的边长为 $1$ 的边，用两条能连接起来的相同长度的边能继续拼凑出 $2^k$ 。即先枚举幂次，然后枚举 $i,j,k$ 来预处理出所有可达的情况。</li>
<li>时间复杂度：$O(n^4)$，其中 $n \le 50$</li>
</ul>
</li>
<li>对于求最短路，由于数据范围很小，因此可以直接使用 $Floyd$.</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;int&gt;&gt; g(n + 1, vector&lt;int&gt;(n + 1, 1e9));
    vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; st(n + 1, vector&lt;vector&lt;bool&gt;&gt;(n + 1, vector&lt;bool&gt;(n + 1)));
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        st[a][b][0] &#x3D; 1;
        g[a][b] &#x3D; 1;
    &#125;

    for (int cnt &#x3D; 0; cnt &lt;&#x3D; n - 1; cnt++)
    &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
            &#123;
                for (int k &#x3D; 1; k &lt;&#x3D; n; k++)
                &#123;
                    if (st[i][j][cnt] &amp;&amp; st[j][k][cnt])
                    &#123;
                        st[i][k][cnt + 1] &#x3D; 1;
                        g[i][k] &#x3D; 1;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    for (int k &#x3D; 1; k &lt;&#x3D; n; k++)
    &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
            &#123;
                g[i][j] &#x3D; min(g[i][j], g[i][k] + g[k][j]);
            &#125;
        &#125;
    &#125;

    cout &lt;&lt; g[1][n];
    return 0;
&#125;</code></pre>



<h2 id="高质量比赛推荐"><a href="#高质量比赛推荐" class="headerlink" title="高质量比赛推荐"></a>高质量比赛推荐</h2><blockquote>
<p>最近做了一场比赛的题目（非 $vp$，灵感比赛来自：<strong>2023 ICPC HIAST Collegiate Programming Contest</strong>，不过这场比赛没有题解，需要自己多摸索），发现质量挺棒的，于是决定开一个（比赛）专场，把好的场次推荐出来！</p>
</blockquote>
<p><strong>点评：</strong></p>
<ul>
<li><strong>$2023\ ICPC\ HIAST\ Collegiate\ Programming\ Contest$：</strong>题目难度逐渐递增，开始做的时候，可写的题目比较多，有一些 $dp$ 初级、中级的题目，后面还有数据结构中等难度以上的题目，算法层面上都是基本了解的，难度比较大的题目还需要一定时间补完。</li>
<li><strong>$2023\ ICPC$ 西安区域赛：</strong>质量贼棒，但是个别题目好像出了些锅，据说上传题目一直在往后延迟，可能是在修复数据。前期的签到模拟题很巧妙，还有一道签到数论题目质量也很棒（待补），还出了一道归并排序的题目（也是自己的知识盲区），后面的题目印象中更好些，真的是一道高质量的比赛题目，只不过自己水平太菜了，还需要多补一补。</li>
</ul>
<p><mark>推荐比赛：</mark></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104493">2023 ICPC HIAST Collegiate Programming Contest</a></p>
<p><strong>$2023\ ICPC$ 西安区域赛：</strong> 链接待上传到 $ucup$</p>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/contest#category=replay&title=%E7%AC%AC%E4%B9%9D%E5%B1%8A%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B">$2023\ CCPC$ 区域赛：哈尔滨、深圳、秦皇岛</a></p>
<p>貌似推荐的上面比赛难道不小，还遇到了一些 $cf$ 上的比赛，质量也挺不错的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1932">Codeforces Round 927 (Div. 3)</a><ul>
<li>$C$ 题可以逆向思考，因为逆元不一定存在，因为需要保证除数和模数互质，但不一定能保证，因此不能用逆元的方法去做（这也是我当时写的过程中遇到了不可思议的事情，但现在一看就想通缘由了）</li>
<li>$E$ 题算法标签是：前缀和 + 高精度。是一道不错的题目！</li>
</ul>
</li>
</ul>
<h2 id="蓝桥杯精选"><a href="#蓝桥杯精选" class="headerlink" title="蓝桥杯精选"></a>蓝桥杯精选</h2><p><strong>历届真题网站：</strong><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/?first_category_id=1&page=1&sort=students_count&second_category_id=3">蓝桥官网</a></p>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><h4 id="判断平年-闰年"><a href="#判断平年-闰年" class="headerlink" title="判断平年&#x2F;闰年"></a>判断平年&#x2F;闰年</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;
int main()
&#123;
    &#x2F;*1、能被4整除，但不能别100整除
      2、能被400整除(满足二者之一即为闰年)
      闰年二月份29天
      平年二月份28天
      if条件中两个条件都得写哇
    *&#x2F;
  if((year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) ||year % 400 &#x3D;&#x3D; 0);
&#125;
</code></pre>

<h4 id="获取日期字符串"><a href="#获取日期字符串" class="headerlink" title="获取日期字符串"></a>获取日期字符串</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int months[] &#x3D; &#123;
	0,31,28,31,30,31,30,
	31,31,30,31,30,31
&#125;;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);
	&#x2F;&#x2F;以2022年为例,平年2月份为28天,闰年为29天
	int year &#x3D; 2022,month &#x3D; 1,day &#x3D; 1;
	for(int i &#x3D; 0;i &lt; 365;i++)
	&#123;
		char str[10];
		sprintf(str,&quot;%04d%02d%02d&quot;,year,month,day);
		string s &#x3D; str;
		cout &lt;&lt; s &lt;&lt; endl;

		if(++day &gt; months[month])	
		&#123;
			day &#x3D; 1;
			month++;
		&#125;
	&#125;

	return 0;
&#125;</code></pre>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/844/">排列数字</a></p>
<p><mark>手写全排列：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 20;

int n;
int st[N];
vector&lt;int&gt; v;
void dfs(int cnt&#x2F;*当前已经选了多少个数*&#x2F;)
&#123;
    if(cnt &#x3D;&#x3D; n)
    &#123;
        for(auto x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &quot;\n&quot;;
        return ;
    &#125;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        if(st[i])   continue;&#x2F;&#x2F;st数组:保证之前选过的数字不能再选了
        st[i] &#x3D; true;
        v.push_back(i);
        dfs(cnt + 1);
        st[i] &#x3D; false;
        v.pop_back();
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;
    dfs(0);
    return 0;
&#125;</code></pre>

<p><mark>调用函数实现：</mark></p>
<blockquote>
<p>首先，请记住：next_permutation() 函数！</p>
<p>iota函数()：前两个参数是范围，第三个参数是初值是多少，之后每个元素都从初值递增1。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int n;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;
    vector&lt;int&gt; a(n + 1);
    iota(a.begin(),a.end(),0);
    do
    &#123;
        for(int i &#x3D; 1;i &lt; a.size();i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; a.size() - 1];
    &#125; while (next_permutation(a.begin() + 1,a.end()));
    
    return 0;
&#125;</code></pre>

<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><blockquote>
<p>与排列所不同的是：需要按照顺序组合，即多加一个参数cur：表示当前要从第几个数开始，有了这种顺序后，就可以不用st数组判重了。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">void dfs(int cur&#x2F;*当前是第几个数*&#x2F;,int cnt&#x2F;*当前已经选了多少个数*&#x2F;)
&#123;
    if(cnt &#x3D;&#x3D; select)&#x2F;&#x2F;从n个数中选select个
    &#123;
        for(auto x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &quot;\n&quot;;
        return ;
    &#125;

    for(int i &#x3D; cur;i &lt;&#x3D; n;i++)
    &#123;
        v.push_back(i);
        dfs(i + 1,cnt + 1);
        v.pop_back();
    &#125;
&#125;&#x2F;&#x2F;如果用dfs(1,0)调用：表示数组元素从1开始,当前已经选了0个数。</code></pre>

<h2 id="天梯赛-OR-CAIP（原RoboCom）"><a href="#天梯赛-OR-CAIP（原RoboCom）" class="headerlink" title="天梯赛 OR CAIP（原RoboCom）"></a>天梯赛 OR CAIP（原RoboCom）</h2><blockquote>
<p>常用小技巧：</p>
<p>1、断言：assert();</p>
<p>2、随机数</p>
<p>3、暴力搜索 + 打表（可参考 $2024$ 天梯赛 $L2-4$）</p>
</blockquote>
<ol>
<li><strong>断言</strong></li>
</ol>
<ul>
<li><p>$assert();$ 括号内用为真的判断语句，如果为假，则会出现 $RE$ 的报错。</p>
</li>
<li><p>如果当本身就 $RE$ 的话，为了防止与断言报错重合，可以用 $if$ 语句判断，然后设置死循环，如下：</p>
<ul>
<li><pre><code class="c++">if (cnt &lt; 2)	while(1);
<pre class="language-none"><code class="language-none">
    

2. **随机数**

- 新学了一个“效率较高”的”随机数算法“，在全局中加入下面代码：

  &#96;&#96;&#96;c++
  mt19937 mrand(random_device&#123;&#125;());
  int rnd(int x) &#123; return mrand() % x;&#125;</code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>调用方式（举例如下）：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; rnd(100);</code></pre></li>
</ul>
<p><strong>3、大模拟思路：</strong></p>
<ul>
<li><p>明确存储容器</p>
</li>
<li><p>函数代码分工</p>
<p>​		虽然这次 $2023RAICOM$ 国赛的模拟能写成来，但却太暴力了，导致超时。。。，即使分工明确又如何，算法思维又是多么的重要！</p>
<p>推荐几道这类比赛（天梯赛、$RAMCOM$）中经典的大模拟题目：</p>
<p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1518582268930473984?type=7&page=1">插松枝</a></p>
<p><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772841508872?type=7&page=1">堆宝塔</a></p>
<p>还有一道是RAICOM国赛的第三题，很经典（因为太暴力会超时 $qwq$），<strong>题目链接：</strong><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1693095794755289088/exam/problems/1693095890628689922?type=7&page=0">RC-u3 兰州拉面派餐系统</a></p>
<ul>
<li><p>讲解这题（当时用纯暴力只拿了一半分数，不然就能拿国一了 $qwq$）：</p>
<ul>
<li><p>思路：每次都是优先“时间”，即哪个篮子先好，就先用哪个篮子，因此，其实就不难想到用<mark>优先队列</mark>（但当时可能第一题写了10多分钟，总感觉时间不够用，但其实确实得多停下来认真思考一下的，当时还是有点急了）。</p>
</li>
<li><p>代码：</p>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef pair&lt;int, int&gt; pii;
typedef tuple&lt;int, int, int&gt; tpl;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);
	
	int n, m, l;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;

	priority_queue&lt;tpl, vector&lt;tpl&gt;, greater&lt;tpl&gt;&gt; heap;
	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)	heap.push(&#123;-1, i, 0&#125;);

	vector&lt;int&gt; time(n + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	cin &gt;&gt; time[i];

	vector&lt;int&gt; need(l + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; l; i++)	cin &gt;&gt; need[i];

	vector&lt;int&gt; cnt(m + 1); &#x2F;&#x2F; 每个篮子煮了多少面

	vector&lt;pii&gt; ans; &#x2F;&#x2F; 编号: 时间

	for (int i &#x3D; 1; i &lt;&#x3D; l; i++)
	&#123;
		int v &#x3D; need[i];
		auto t &#x3D; heap.top();
		heap.pop();

		auto [a, b, c] &#x3D; t;
		if (a &#x3D;&#x3D; -1)
		&#123;
			heap.push(&#123;time[v], b, i&#125;);
		&#125;
		else
		&#123;
			ans.push_back(&#123;c, a&#125;);
			heap.push(&#123;a + time[v], b, i&#125;);
		&#125;
		cnt[b] ++;
	&#125;

	while (heap.size())
	&#123;
		auto t &#x3D; heap.top();
		heap.pop();

		auto [a, b, c] &#x3D; t;
		if (a !&#x3D; -1)
		&#123;
			ans.push_back(&#123;c, a&#125;);
		&#125;
	&#125;

	sort(ans.begin(), ans.end(), [&amp;](pii a, pii b) -&gt; bool&#123;
		if (a.second !&#x3D; b.second)	return a.second &lt; b.second;
		return a.first &lt; b.first;
	&#125;);
	
	for (int i &#x3D; 0; i &lt; ans.size(); i++)
		cout &lt;&lt; ans[i].first &lt;&lt; &quot;:&quot; &lt;&lt; ans[i].second &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; ans.size() - 1];

	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
		cout &lt;&lt; cnt[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; m];
	return 0;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<p>这里顺便再讲下2023RAICOM国赛第四题（算法：拓扑排序）：</p>
<blockquote>
<p><strong>思路：</strong></p>
<p>1、必须先移动上面的，才能移动下面的，有一直顺序关系，可以联想到拓扑排序；</p>
<p>2、怎么建图呢？仔细思考可以发现，只需要看一块与上一块直接的关系即可，成环的话就同样建图，大不了 $impossible$。</p>
<p>3、怎么保证字典序最小？普通的队列里面，都是可以选择从一个入口出发，我们当然要先选择一个编号最小的，从这个点遍历后的其他点进入队列后，不清楚该点的编号大小与队列已存在的编号大小的关系，但仍要选择一个编号最小的当做入口，因此可以想到了用<strong>优先队列</strong>。</p>
<p>4、如果用之前熟悉的 $vector$ 以及 $map$ 等各类 $STL$，会发现出现各种的<strong>内存超限</strong>，必须全部换成普通的数组，才可以过！</p>
</blockquote>
<p>仅使用了一个 $STL$ 中 $set$ 内存超限如下：</p>
<p><img src="/../../../../images/17.png"></p>
<p>全部换成普通数组（除了优先队列以外，这个不可替换 $qwq$）以后：</p>
<p><img src="/../../../../images/18.png"></p>
<p><mark>代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 1e3 + 10, M &#x3D; 1e6 + 10;

int g[2][N];
int h[M], e[M], ne[M], idx;
bool st[M];
int d[M];

void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    memset(h, -1, sizeof(h));
    
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
        &#123;
            cin &gt;&gt; g[i &amp; 1][j];
            st[g[i &amp; 1][j]] &#x3D; true;

            if (i &gt;&#x3D; 2 &amp;&amp; g[i &amp; 1][j] !&#x3D; g[(i - 1) &amp; 1][j])
            &#123;
                int u &#x3D; g[(i - 1) &amp; 1][j], v &#x3D; g[i &amp; 1][j];
                add(u, v);
                d[v]++;
            &#125;
        &#125;

    auto topsort &#x3D; [&amp;]() -&gt; void
    &#123;
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;
        vector&lt;int&gt; res;
        int cnt &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; 1e6; i++)
        &#123;   
            if (!st[i]) continue;
            cnt++;
            if (!d[i])  heap.push(i);
        &#125;

        while (!heap.empty())
        &#123;
            auto t &#x3D; heap.top();
            heap.pop();
            res.push_back(t);
            for (int i &#x3D; h[t]; ~i; i &#x3D; ne[i]) 
            &#123;
                int v &#x3D; e[i];
                if (--d[v] &#x3D;&#x3D; 0)    heap.push(v);
            &#125;
        &#125;
        
        for (int i &#x3D; 0; i &lt; res.size(); i++)
            cout &lt;&lt; res[i] &lt;&lt; &quot; \n&quot;[i + 1 &#x3D;&#x3D; res.size() &amp;&amp; res.size() &#x3D;&#x3D; cnt];
        
        if (res.size() !&#x3D; cnt) cout &lt;&lt; &quot;Impossible\n&quot;;
    &#125;;

    topsort();

    return 0;
&#125;</code></pre>

<p><strong>4、图上两点之间的所有路径：</strong></p>
<ul>
<li><p><mark>树上两点之间的路径（暴力法可用 $lca$ 获取）：</mark></p>
<p>预处理 $lca$，调用下面函数，可以获取任意两点之间的路径。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto get_path &#x3D; [&amp;](int a, int b) -&gt; vector&lt;int&gt;
&#123;
    int p &#x3D; lca(a, b);
    vector&lt;int&gt; res, tv;

    while(a)
    &#123;
        res.push_back(a);
        if(a &#x3D;&#x3D; p)  break;
        a &#x3D; fa[a][0];
    &#125;
    while(b !&#x3D; p)
    &#123;
        tv.push_back(b);
        b &#x3D; fa[b][0];
    &#125;
    reverse(tv.begin(), tv.end());
    res.insert(res.end(), tv.begin(), tv.end());
    return res;
&#125;;

auto res &#x3D; get_path(1, 5);
for (auto x : res)  cout &lt;&lt; x &lt;&lt; &quot; &quot;;</code></pre>
</li>
<li><p><mark>无向有环图两点间的路径（最短路径）：</mark></p>
<p>可以用 $dijkstra$ 或 $bfs$ 预处理出两点的最短路径，跑 $dfs$ 并附带距离参数，如果距离超过最短路径则返回（剪枝），将每次的路径都存下来，在找到目的顶点的时候出来答案即可（不过这样的话，递归太深可能会出现<strong>段错误</strong>）。</p>
<p>题目灵感来源：<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1556843855285559296/exam/problems/1556843936151740418?type=7&page=0">睿抗2022国赛-RC-u3 战利品分配</a></p>
<p><mark>暴力解法（得分：20 &#x2F; 25）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

int main()
&#123;
    IOS;
    int n, m, k, p;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p;

    vector&lt;int&gt; w(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; w[i];

    vector&lt;vector&lt;int&gt;&gt; g(n + 1);
    while (m--)
    &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        g[a].push_back(b);
        g[b].push_back(a);
    &#125;
    
    int st, ed;
    cin &gt;&gt; st &gt;&gt; ed;

    auto bfs &#x3D; [&amp;](int st) -&gt; vector&lt;int&gt;
    &#123;
        queue&lt;int&gt; q;
        q.push(st);
        vector&lt;int&gt; dist(n + 1, 0x3f3f3f3f);
        dist[st] &#x3D; 0;
        while (!q.empty())
        &#123;
            auto u &#x3D; q.front();
            q.pop();
            for (auto v : g[u])
            &#123;
                if (dist[v] &gt; dist[u] + 1)
                &#123;
                    dist[v] &#x3D; dist[u] + 1;
                    q.push(v);
                &#125;
            &#125;
        &#125;
        return dist;
    &#125;;

    auto dist &#x3D; bfs(st);
    int mi &#x3D; dist[ed];
    vector&lt;int&gt; path;
    int res &#x3D; 0;
    function&lt;void(int, int, int)&gt; dfs &#x3D; [&amp;](int u, int fa, int d) -&gt; void
    &#123;
        if (d &gt; mi) return;
        if (u &#x3D;&#x3D; ed)
        &#123;
            if (u &#x3D;&#x3D; ed)
            &#123;
                int sum &#x3D; 0;
                for (int i &#x3D; p - 1; i &lt; path.size(); i +&#x3D; k)
                    sum +&#x3D; w[path[i]];
                res &#x3D; max(res, sum);
            &#125;
            return;
        &#125;

        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa)    continue;
            
            path.push_back(v);
            dfs(v, u, d + 1);
            path.pop_back();
        &#125;
    &#125;;

    path.push_back(st);
    dfs(st, -1, 0);

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre></li>
</ul>
<h3 id="天梯赛好题精选"><a href="#天梯赛好题精选" class="headerlink" title="天梯赛好题精选"></a>天梯赛好题精选</h3><blockquote>
<p>总结这三年打的天梯赛：</p>
<p>大一：129分，无奖。</p>
<p>大二：183分，个人国三。团体国二。</p>
<p>大三：238分（全校最高分），个人国二。团体也国二吧。</p>
</blockquote>
<p>刚刚结束 $2024$ 年天梯赛，个人得分：$238$，个人国二。</p>
<ul>
<li>L2-4：剪枝 $dfs$，由于自己没剪到最优导致有两个点没过（超时），不过数据范围比较小，其实可以暴力跑出来然后打表得出结果的，但是没想到这个技巧，不过这个如何剪枝也是值得学习的，待补。</li>
<li>L3-1：这题最后我拿了满分，前期只是暴力 $bfs$ 了 $nm$ 次，导致超时。最后发现原来是可以从终点 $bfs$ 一次就可以了，这个技巧最后被我想到了，感觉是遇到的第二个这样的题型了（多点同时 $bfs$ 到一个终点不如从一个终点遍历到图上所有点！），上次遇到应该是 $2023$ 年百度之星签到题。。。</li>
<li>L3-2：只写了暴力，拿了15分。其实是一道真正的算法题（L3-1也是算法题，比L3-1更算法），有空记得补一下。</li>
</ul>
<h2 id="算法中的小技巧"><a href="#算法中的小技巧" class="headerlink" title="算法中的小技巧"></a>算法中的小技巧</h2><h3 id="技巧一：二维数组映射"><a href="#技巧一：二维数组映射" class="headerlink" title="技巧一：二维数组映射"></a>技巧一：二维数组映射</h3><p>对于点对的编号数值较大，想开二维数组判重，但是不能开太大？</p>
<p><strong>问题案例：</strong>给点 $n$ 个点 $(n \le 10^5)$ ，有 $m$ 条边 $(u,v)$，由于不能加入重边，因此需要判重。而二维数组无法开太大，因此怎么办呢？(题目来源：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1177/">最大半连通子图</a>，<a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/1649748772841508875?type=7&page=0">L2-048 寻宝图</a>，其中：第一道题目需要用到该技巧，第二个题目开动态二维数组也可以，但也可以用该技巧练练手！)</p>
<p><strong>解决：</strong>将二维的点对映射成一个数，由于 $(u,v)$ 在 $10^5$ 以内，因此可以根据公式：$u × 1000000ll + v$ 计算出点对的哈希值，然后开一个 $unordered_set$ 来判重即可。</p>
<h3 id="技巧二：判断-2-的幂次"><a href="#技巧二：判断-2-的幂次" class="headerlink" title="技巧二：判断 $2$ 的幂次"></a>技巧二：判断 $2$ 的幂次</h3><blockquote>
<p><strong>判断一个数是否为 $2$ 的幂次？</strong></p>
<ul>
<li>$check1$：调用函数 <code>__builtin_popcount(x)</code> 判断二进制中 $1$ 的个数是否是1；</li>
<li>$check2$：$lowbit$ 运算，判断 $x$ 的 $lowbit$ 是否等于本身；</li>
<li>$check3$：令 $x$ 和 $x - 1$ 进行与运算，判断结果是否为 $0$。</li>
</ul>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool check1(int x)
&#123;
    return __builtin_popcount(x) &#x3D;&#x3D; 1;
&#125;

bool check2(int x)
&#123;
    return x &#x3D;&#x3D; (x &amp; (-x));
&#125;

bool check3(int x)
&#123;
    return (x &amp; (x - 1)) &#x3D;&#x3D; 0;
&#125;</code></pre>

<h3 id="技巧三：求-lfloor-log-2x-rfloor"><a href="#技巧三：求-lfloor-log-2x-rfloor" class="headerlink" title="技巧三：求 $\lfloor log_2x \rfloor$"></a>技巧三：求 $\lfloor log_2x \rfloor$</h3><blockquote>
<p><strong>注意：</strong>不要直接使用 $log2(x)$ 或者 $log2l(x)$ 函数，当 $x &#x3D; 562949953421311$ 时，答案应为 $48$，而函数却输出了 $49$！</p>
<p>做法1：调用函数：<mark>$__bit_width(x) - 1$</mark></p>
<p>做法2：手写 $log2()$ 函数</p>
</blockquote>
<p><mark>做法1代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int f(ll x) &#123;
    return __bit_width(x) - 1;
&#125;</code></pre>

<p><mark>做法2代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto log2 &#x3D; [&amp;](ll x) -&gt; ll
&#123;
    ll t &#x3D; 1;
    int ans &#x3D; 0;
    while (t * 2 &lt;&#x3D; x)
    &#123;
        t *&#x3D; 2;
        ans++;
    &#125;
    return ans;
&#125;;</code></pre>

<p><strong>测试题目（该题如果直接调用 $log2(x)$ 函数会出错）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1891/problem/D">D. Suspicious logarithms</a></p>
<h3 id="技巧四：判断完全平方数"><a href="#技巧四：判断完全平方数" class="headerlink" title="技巧四：判断完全平方数"></a>技巧四：判断完全平方数</h3><blockquote>
<p><strong>判断一个数是否为（完全）平方数？</strong></p>
<p>将一个数 $n$ 开根号向下取整后得到 $x$，只需判断 $x^2 &#x3D;&#x3D; n$ 。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool check(ll n)
&#123;
    ll x &#x3D; sqrt(n);
    return x * x &#x3D;&#x3D; n;
&#125;</code></pre>

<h3 id="技巧五：判断两个线段是否重叠"><a href="#技巧五：判断两个线段是否重叠" class="headerlink" title="技巧五：判断两个线段是否重叠"></a>技巧五：判断两个线段是否重叠</h3><p><strong>两种方法判断（假定端点重合不算重叠）：</strong></p>
<ul>
<li>$!(b\ \le\ c\ ||\ d\ \le\ a)$</li>
<li>等价于：$b &gt; c \ &amp;&amp;\ d &gt; a$</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool is_overlap(int a, int b, int c, int d)
&#123;
	return b &gt; c &amp;&amp; d &gt; a;
&#125;</code></pre>



<h3 id="技巧六：输出路径"><a href="#技巧六：输出路径" class="headerlink" title="技巧六：输出路径"></a>技巧六：输出路径</h3><h4 id="状态转移路径-最短路径："><a href="#状态转移路径-最短路径：" class="headerlink" title="状态转移路径 &#x2F; 最短路径："></a>状态转移路径 &#x2F; 最短路径：</h4><p><strong>题目灵感来源：</strong><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1556843855285559296/exam/problems/1556843936151740419?type=7&page=0"><strong>变牛的最快方法</strong></a></p>
<p>该题目是最短编辑路径的变种，只不过加了个输出路径，这是一个关于二维点对的路径输出问题，一般都是逆序获取路径的（如果强行每次用容器将每个过程的路径记录下来，这样是会超内存的！），故总结如下：</p>
<p><mark>一维路径模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; pre(n + 1); &#x2F;&#x2F; 存储方式
for(auto [v,w] : g[u])
&#123;
    if(dist[v] &gt; dist[u] + w)
    &#123;
        dist[v] &#x3D; dist[u] + w;
        heap.push(&#123;dist[v],v&#125;);
        pre[v] &#x3D; u; &#x2F;&#x2F; 记录
    &#125;
&#125;
vector&lt;int&gt; path; &#x2F;&#x2F; 存储路径
int t &#x3D; n;
while(t)
&#123;
    path.push_back(t);
    t &#x3D; pre[t];
&#125;
reverse(path.begin(), path.end());
for (auto x : path) &#x2F;&#x2F; 打印输出路径
    cout  &lt;&lt; x &lt;&lt; &quot; &quot;;</code></pre>

<p><mark>二维路径模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int state[N][N]; &#x2F;&#x2F; 当前点的操作是什么
pii pre[N][N]; &#x2F;&#x2F; 二维点对转移

int x &#x3D; n, y &#x3D; m;
vector&lt;int&gt; res;
while(x || y)
&#123;
    res.push_back(state[x][y]); &#x2F;&#x2F; 将操作放入容器中
    int t &#x3D; x;
    x &#x3D; pre[x][y].first, y &#x3D; pre[t][y].second;
&#125;</code></pre>

<p><mark>灵感题目代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;


const int N &#x3D; 2010;
struct ANS
&#123;
    vector&lt;int&gt; v;
&#125;;
&#x2F;&#x2F; ANS res[N][N];
int state[N][N];
pii pre[N][N];

int main()
&#123;
    IOS;
    vector&lt;int&gt; a, b;
    int x;
    a.push_back(0), b.push_back(0);
    while (cin &gt;&gt; x)
    &#123;
        if(x &#x3D;&#x3D; -1) break;
        a.push_back(x);
    &#125;
    while (cin &gt;&gt; x)
    &#123;
        if(x &#x3D;&#x3D; -1) break;
        b.push_back(x);
    &#125;
    int n &#x3D; a.size() - 1, m &#x3D; b.size() - 1;

    vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1));
    &#x2F;*
    f[i][j]: a的前i个匹配b的前j个
    删除，修改，插入
    删除: f[i][j] &#x3D; f[i - 1][j] + 1
    修改: a[i] !&#x3D; b[j], f[i][j] &#x3D; f[i - 1][j - 1] + 1
    插入: f[i][j] &#x3D; f[i][j - 1] + 1
    *&#x2F;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    
    &#123;
        f[i][0] &#x3D; i;
        pre[i][0] &#x3D; &#123;i - 1, 0&#125;;
        state[i][0] &#x3D; 0;
        &#x2F;&#x2F; res[i][0].v &#x3D; res[i - 1][0].v;
        &#x2F;&#x2F; res[i][0].v.push_back(0);
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    
    &#123;
        f[0][i] &#x3D; i;
        pre[0][i] &#x3D; &#123;0, i - 1&#125;;
        state[0][i] &#x3D; 3;
        &#x2F;&#x2F; res[0][i].v &#x3D; res[0][i - 1].v;
        &#x2F;&#x2F; res[0][i].v.push_back(3);
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
        &#123;
            &#x2F;&#x2F; f[i][j] &#x3D; min(f[i - 1][j] + 1, f[i][j - 1] + 1);&#x2F;&#x2F; 删除, 插入
            &#x2F;&#x2F; f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1] + (a[i] !&#x3D; b[j]));&#x2F;&#x2F; 修改
            if (f[i - 1][j] + 1 &lt; f[i][j - 1])
            &#123;
                f[i][j] &#x3D; f[i - 1][j] + 1;
                pre[i][j] &#x3D; &#123;i - 1, j&#125;;
                state[i][j] &#x3D; 0;
            &#125;
            else
            &#123;
                f[i][j] &#x3D; f[i][j - 1] + 1;
                pre[i][j] &#x3D; &#123;i, j - 1&#125;;
                state[i][j] &#x3D; 3;
            &#125;
            
            if(f[i - 1][j - 1] + (a[i] !&#x3D; b[j]) &lt; f[i][j])
            &#123;
                pre[i][j] &#x3D; &#123;i - 1, j - 1&#125;;
                if (a[i] !&#x3D; b[j])   state[i][j] &#x3D; 1;
                else    state[i][j] &#x3D; 2;

                f[i][j] &#x3D; f[i - 1][j - 1] + (a[i] !&#x3D; b[j]);
            &#125;
        &#125;
    &#125;

    cout &lt;&lt; f[n][m] &lt;&lt; &quot;\n&quot;;
    
    x &#x3D; n;
    int y &#x3D; m;
    vector&lt;int&gt; res;
    while(x || y)
    &#123;
        res.push_back(state[x][y]);
        int t &#x3D; x;
        x &#x3D; pre[x][y].first, y &#x3D; pre[t][y].second;
    &#125;

    reverse(res.begin(), res.end());
    for (auto x : res) cout &lt;&lt; x;
    return 0;
&#125;</code></pre>

<h2 id="C-个人通用模板"><a href="#C-个人通用模板" class="headerlink" title="C++个人通用模板"></a>C++个人通用模板</h2><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;&#x2F;&#x2F;__int128_t
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define lowbit(x)   ((x)&amp;(-x))
#define fi first
#define se second
#define pb push_back
&#x2F;&#x2F;获取最大值&#x2F;最小值
template &lt;typename T&gt; bool chkMax(T &amp;x, T y) &#123; return (y &gt; x) ? x &#x3D; y, 1 : 0; &#125;
template &lt;typename T&gt; bool chkMin(T &amp;x, T y) &#123; return (y &lt; x) ? x &#x3D; y, 1 : 0; &#125;

template &lt;typename T&gt; void inline read(T &amp;x) &#123;&#x2F;&#x2F;快读
    int f &#x3D; 1; x &#x3D; 0; char c &#x3D; getchar();
    while (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &#123; if (c &#x3D;&#x3D; &#39;-&#39;) f &#x3D; -1; c &#x3D; getchar(); &#125;
    while (c &lt;&#x3D; &#39;9&#39; &amp;&amp; c &gt;&#x3D; &#39;0&#39;) x &#x3D; (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48), c &#x3D; getchar();
    x *&#x3D; f;
&#125;
template&lt;typename T&gt; void inline write(T x)&#123;&#x2F;&#x2F;快写
	if(x &lt; 0) putchar(&#39;-&#39;), x &#x3D; -x;
	if(x &gt; 9)   write(x &#x2F; 10);
	putchar(x % 10 + &#39;0&#39;);
&#125;

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;&#x2F;&#x2F;随机数
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;&#x2F;&#x2F;最大公约数
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;&#x2F;&#x2F;快速幂

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    return 0;
&#125;</code></pre>

<h3 id="吸氧优化"><a href="#吸氧优化" class="headerlink" title="吸氧优化"></a>吸氧优化</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC optimize(2)</code></pre>



<h3 id="究极快读"><a href="#究极快读" class="headerlink" title="究极快读"></a>究极快读</h3><pre class="language-c++" data-language="c++"><code class="language-c++">namespace fastIO &#123;
    const int BUF_SIZE &#x3D; 1 &lt;&lt; 15;
    char buf[BUF_SIZE], * s &#x3D; buf, * t &#x3D; buf;
    inline char fetch() &#123;
        if (s &#x3D;&#x3D; t) &#123;
            t &#x3D; (s &#x3D; buf) + fread(buf, 1, BUF_SIZE, stdin);
            if (s &#x3D;&#x3D; t) return EOF;
        &#125;
        return *s++;
    &#125;

    template&lt;class T&gt; inline void read(T&amp; x) &#123;
        bool sgn &#x3D; 1;
        T a &#x3D; 0;
        char c &#x3D; fetch();
        while (!isdigit(c)) sgn ^&#x3D; (c &#x3D;&#x3D; &#39;-&#39;), c &#x3D; fetch();
        while (isdigit(c)) a &#x3D; a * 10 + (c - &#39;0&#39;), c &#x3D; fetch();
        x &#x3D; sgn ? a : -a;
    &#125;

    template&lt;class T&gt; inline void write(T x, char c &#x3D; -1) &#123;
        if(x &lt; 0) putchar(&#39;-&#39;), x &#x3D; -x;
        if(x &gt; 9)   write(x &#x2F; 10);
        putchar(x % 10 + &#39;0&#39;);
        if(~c)  putchar(c);
    &#125;
&#125;
using namespace fastIO;</code></pre>

<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);&#x2F;&#x2F;从文件里面读取数据
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);&#x2F;&#x2F;将数据写入文件内
    
    fclose(stdin);
    fclose(stdout);
    return 0;
&#125;</code></pre>

<h3 id="三维数组-vector-写法"><a href="#三维数组-vector-写法" class="headerlink" title="三维数组 $vector$ 写法"></a>三维数组 $vector$ 写法</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    int n,m;
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n + 1,vector&lt;vector&lt;int&gt;&gt;(m + 1,vector&lt;int&gt;(m + 1,0x3f3f3f3f)));
    f[0][0][0] &#x3D; 1;
    cout &lt;&lt; f[0][0][0] &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<h2 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h2><h3 id="常见-ASCII-码"><a href="#常见-ASCII-码" class="headerlink" title="常见 ASCII 码"></a>常见 ASCII 码</h3><p>$0:48;\ \ \ \ A:65;\ \ \ \ a:97$</p>
<p><strong>小写字母的 $ASCII$ 码比大写字母的 $ASCII$ 码大 <mark>32</mark>。</strong></p>
<h3 id="计算空间大小"><a href="#计算空间大小" class="headerlink" title="计算空间大小"></a>计算空间大小</h3><p>$1e6$ 个 $chat$ 为 $1M$</p>
<p>$1e6$ 个 $int$ 为 $4M$</p>
<h3 id="C-运行时间"><a href="#C-运行时间" class="headerlink" title="C++运行时间"></a>C++运行时间</h3><p> $1s$ 大约可以运行 <strong>$1e8$</strong> 次，即 <strong>一亿</strong>！</p>
<h3 id="int-long-long-最大值范围"><a href="#int-long-long-最大值范围" class="headerlink" title="$int &#x2F; long\ long$ 最大值范围"></a>$int &#x2F; long\ long$ 最大值范围</h3><ul>
<li><code>int</code>：$2^{31} - 1 &#x3D; 2147483647$，即 $2e9$ 多，共 $10$ 位。</li>
<li><code>long long</code>：$2^{63} - 1 &#x3D; 9223372036854775807$，即 $9e18$，共 $19$ 位。</li>
</ul>
<h3 id="二进制位数"><a href="#二进制位数" class="headerlink" title="二进制位数"></a>二进制位数</h3><p>若：$n &#x3D; 2^{x} - 1$ ，则 $n$ 共有 $x$ 个二进制位，最高位为 $x - 1$。</p>
<h3 id="前-n-个数的平方的和公式"><a href="#前-n-个数的平方的和公式" class="headerlink" title="前 $n$ 个数的平方的和公式"></a>前 $n$ 个数的平方的和公式</h3><p>$1^2 + 2^2 + 3^3 + \cdots + n^2 &#x3D; \sum_{i&#x3D;1}^{n}{i^2} &#x3D; \frac{n(n + 1)(2n + 1)}{6}$</p>
<h3 id="读取带空格的字符串"><a href="#读取带空格的字符串" class="headerlink" title="读取带空格的字符串"></a>读取带空格的字符串</h3><pre class="language-c++" data-language="c++"><code class="language-c++">string s;
getline(cin, s);</code></pre>

<p><strong>注意：</strong>如果前面还读取过其他输入，需要添加 $getchar()$！</p>
<h3 id="计算区间内相同元素的区间下标和对应值"><a href="#计算区间内相同元素的区间下标和对应值" class="headerlink" title="计算区间内相同元素的区间下标和对应值"></a>计算区间内相同元素的区间下标和对应值</h3><blockquote>
<p>即将类似字符串 $aabddccc$ 转换为：</p>
<p>$[1,2] : a$</p>
<p>$[3,3]: b$</p>
<p>$[4,5]:d$</p>
<p>$[6,8]:c$</p>
<p>下面给出通用方法：</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    s &#x3D; &quot; abccdddc&quot;;

    int n &#x3D; s.size() - 1;
    
    int pos &#x3D; 1;&#x2F;&#x2F; 记录开始下标
    vector&lt;tuple&lt;int, int, char&gt;&gt; v;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#x2F;&#x2F; 从第二个开始
    &#123;
        if (s[i] !&#x3D; s[i - 1])
        &#123;
            v.push_back(&#123;pos, i - 1, s[i - 1]&#125;);
            pos &#x3D; i;
        &#125;
    &#125;
    v.push_back(&#123;pos, n, s[n]&#125;);

    for (auto [x, y, z] : v)
        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<h3 id="连续区间和最大值"><a href="#连续区间和最大值" class="headerlink" title="连续区间和最大值"></a>连续区间和最大值</h3><p><strong>实现代码：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int res &#x3D; 0, cur &#x3D; 0;
for(int i &#x3D; 0;i &lt; v.size();i++)
	cur &#x3D; max(v[i],cur + v[i]), res &#x3D; max(res,cur);</code></pre>

<p><mark>推荐题单：</mark><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/37895/A">寂寞如雪</a></p>
<h2 id="在这里写个对拍！"><a href="#在这里写个对拍！" class="headerlink" title="在这里写个对拍！"></a>在这里写个对拍！</h2><p><strong>参考题目链接：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">01背包问题</a></p>
<blockquote>
<p>首先，正解和暴力解法仍需正常写，不必加任何与文件输入输出流相关的代码。</p>
<p>而数据代码生成器：</p>
<p>​	1、封装一个函数用来读文件写入随机数据，并关闭文件。</p>
<p>​	2、主函数调用 $system()$ 去执行两份代码，并判断生成的结果是否一致（答案会在 $system$ 里面写入文件中）。</p>
</blockquote>
<p><mark>文件共计7个：</mark></p>
<ul>
<li><strong>main.cpp</strong>    对拍执行函数（已经含有对其他文件的编译功能）</li>
<li><strong>generate_data.cpp</strong>    生成随机数据的文件</li>
<li>input.txt    存放数据生成的文件</li>
<li><strong>std.cpp</strong>    正解</li>
<li>std_output.txt    正解的输出结果</li>
<li><strong>bf.cpp</strong>    暴力解法</li>
<li>bf.output.txt    暴力解法的生成结果</li>
</ul>
<p>搭好框架后，只需写好正解$(std.cpp)$、暴力解法$(bf.cpp)$、以及生成随机数据$(generate_data)$的代码即可！</p>
<p><mark>总执行函数： main.cpp</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;    
    auto compile &#x3D; [&amp;]() -&gt; void
    &#123;
        printf(&quot;编译中:\n&quot;);
        system(&quot;g++ generate_data.cpp -o generate_data&quot;);
        system(&quot;g++ std.cpp -o std&quot;);
        system(&quot;g++ bf.cpp -o bf&quot;);
        printf(&quot;编译结束!\n&quot;);
    &#125;;

    compile();&#x2F;&#x2F;编译C++文件

    for(int i &#x3D; 1;i &lt;&#x3D; 100;i++)
    &#123;
        printf(&quot;Test: %d\n&quot;,i);

        system(&quot;generate_data.exe&quot;);&#x2F;&#x2F;生成数据
        system(&quot;std.exe &lt; input.txt &gt; std_output.txt&quot;);&#x2F;&#x2F;生成正解
        system(&quot;bf.exe &lt; input.txt &gt; bf_output.txt&quot;);&#x2F;&#x2F;生成暴力解
        if(system(&quot;fc std_output.txt bf_output.txt&quot;))&#x2F;&#x2F;判断是否一致
        &#123;
            puts(&quot;Error!&quot;);
            break;
        &#125;
        
        getchar();&#x2F;&#x2F;每次回车开始下一个数据
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>随机数据生成器：generate_data.cpp</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

int main()
&#123;
    ofstream fout(&quot;input.txt&quot;);
    int n &#x3D; rnd(100);
    fout &lt;&lt; n &lt;&lt; endl;
    
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   fout &lt;&lt; rnd(100) &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   fout &lt;&lt; rnd(2) &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];

    fout.close();
    return 0;
&#125;</code></pre>



<p><mark>正解：std.cpp</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1010;
int n,m;
int v[N],w[N];&#x2F;&#x2F;v表示体积，w表示价值
int f[N];&#x2F;&#x2F;一维数组

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;物品个数、背包容量
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; v[i] &gt;&gt; w[i];&#x2F;&#x2F;输入每个物品的体积、价值
    
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        for(int j &#x3D; m;j &gt;&#x3D; v[i];j--)&#x2F;&#x2F;逆序更新
        &#123;
            f[j] &#x3D; max(f[j],f[j-v[i]] + w[i]);
        &#125;
    cout &lt;&lt; f[m] &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<p><mark>暴力：bf.cpp</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1010;
int n,m;
int v[N],w[N];&#x2F;&#x2F;v表示体积，w表示价值
int f[N];&#x2F;&#x2F;一维数组

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;&#x2F;&#x2F;物品个数、背包容量
    for(int i &#x3D; 0;i &lt; n;i++)   cin &gt;&gt; v[i] &gt;&gt; w[i];&#x2F;&#x2F;输入每个物品的体积、价值
    
    int res &#x3D; 0;
    for(int i &#x3D; 0;i &lt; 1 &lt;&lt; n;i++)
    &#123;
        int sumv &#x3D; 0,sumw &#x3D; 0;
        for(int j &#x3D; 0;j &lt; n;j++)
            if(i &gt;&gt; j &amp; 1)  sumv +&#x3D; v[j],sumw +&#x3D; w[j];
        if(sumv &lt;&#x3D; m)   res &#x3D; max(res,sumw);
    &#125;
    cout &lt;&lt; res &lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<h2 id="反思栏"><a href="#反思栏" class="headerlink" title="反思栏"></a>反思栏</h2><p>最近遇到了 $3$ 种题，突然尬住了。</p>
<p>为什么？</p>
<p>自从将码风设定为 $cin$ 且 $STL$ 以后（向偶像 $jiangly$ 学习），就爱不释手，感觉非常方便。每次遇到的一些题目大都不会被卡超时之类的，因为本身就只有极少数题目会卡。但想到最近突然遇到 $3$ 种题型，彻底让我感觉，要学会随机应变，都得会使用，因为 $cin$ 并不会一直好用，$STL$ 也不是 $YYDS$。</p>
<p><strong>第一个题：2023西安区域赛签到题</strong></p>
<p>​	给了 $python$ 的标准二重 $for$ 循环代码，问求和结果。</p>
<p>一眼上去的思路就是用字符串进行处理，获取括号里面的参数，然后各种转换解析。但是如果用 $scanf$ 读入，则就会非常的方便！</p>
<p><strong>第二个题：2023桂林铜牌题莫队 &#x2F; 树状数组</strong> </p>
<p>​	题目给的每个数的范围最大是 $5e5$，于是我开了个 $vector$ 数组用来记录一些相关信息，这看似并不会影响什么。但是题目中说每个 $m$ 最大是 $5e5$，但由于是多组测试数据，并不保证 $\sum{m}$ 的值。那么看似多余的描述，实际上却会让我超时！咦，为什么？原来我每次开 $5e5$ 的空间，如果他每次都是 $m &#x3D; 5e5$ 的规模的话，我就是 $t$ 次开了 $5e5$ 的空间，但是开空间其实也是初始化的一种，即可以理解成一次测试数据我 $for$ 循环了 $5e5$ 次，那么 $t$ 次必然超时！我超，没想到会在开空间的时候超时！因此应该用 $map$ 来取代 $vector$，或开全局数组，每次清空使用到位置的数组位置上的内容。</p>
<p><strong>第三个题：$2023RAICOM$ 国赛的拓扑排序题目</strong></p>
<p>​	题目给了 $64M$ 的空间，建图的时候用 $vector<vector>$ ，还用到了 $map$，但没想到竟然会<strong>内存超限</strong>！$map$ 换成 $vector$ 的话则会额外增加一个内存超限的数据，这让我百般不能理解。怎么都想不出来该怎么优化，大概是看到网上提交有使用 $add$ 函数建图的回忆，于是因为这题没有多组测试数据，我就改成了全局数组，建图用了原始的邻接表的形式，没想到竟然过了，而且还少了一半的内存空间。而再仅把一个全局数组换成 $map$ 去实现，则又导致内存超限，真的很难以理解！</p>
<hr>
<p>以上情况，出现 $1$ 种，$2$ 种并没有让我引起很大的反馈，大概我补题的顺序是先第二个题，再第三个题，都没有太大的感触，表现的只是惊讶，直到第一个题西安站的题解发出来后，看到了用 $scanf$ 的输入方便，最终引起了我的很大重视（因为 $cin$ 是我的底线，$STL$ 也被击破了，我的经常写题的码风受到了很大的质疑）。因此决定，应该都要掌握，哪个更方便就用哪个，随机应变一定不会错！</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">重生带我走</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://318471543.github.io/2024/10/08/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">https://318471543.github.io/2024/10/08/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">重生带我走</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                                    <span class="chip bg-color">好题精选</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="数据结构">
                        
                        <span class="card-title">数据结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/08/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="基础算法">
                        
                        <span class="card-title">基础算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">基础算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">重生带我走</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/318471543" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:318471543@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=318471543" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 318471543" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5545924159" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5545924159" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/shen-mu-yi-35" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/shen-mu-yi-35" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.8}});</script></body>

</html>
