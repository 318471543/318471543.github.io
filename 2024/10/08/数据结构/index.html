<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构, 重生带我走">
    <meta name="description" content="KMP


算法
KMP
扩展KMP



数据维护
ne[i]表示P[1,i]中相等前后缀的最大长度
z[i]表示S与其后缀S[i,n]的最长公共前缀的长度


算法流程
双指针(i,j)，借助旧状态ne[1~i-1]加速计算新状态ne[">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构 | 重生带我走</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">重生带我走</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">重生带我走</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">数据结构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><table>
<thead>
<tr>
<th>算法</th>
<th>KMP</th>
<th>扩展KMP</th>
</tr>
</thead>
<tbody><tr>
<td>数据维护</td>
<td>ne[i]表示P[1,i]中相等前后缀的最大长度</td>
<td>z[i]表示S与其后缀S[i,n]的最长公共前缀的长度</td>
</tr>
<tr>
<td>算法流程</td>
<td><strong>双指针</strong>(i,j)，借助旧状态ne[1~i-1]加速计算新状态ne[i]</td>
<td><strong>盒子</strong>[l,r]，借助旧状态z[1~i - 1]，加速计算新状态z[i]</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h3 id="KMP-1"><a href="#KMP-1" class="headerlink" title="KMP"></a>KMP</h3><blockquote>
<p><strong>KMP算法</strong>是可以在<strong>文本串s</strong>中快速查找<strong>模式串p</strong>的一种算法。</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto KMP &#x3D; [&amp;](string p,string s) -&gt; vector&lt;int&gt;
&#123;
    vector&lt;int&gt; res;
    int n &#x3D; p.size(),m &#x3D; s.size();
    p &#x3D; &quot; &quot; + p,s &#x3D; &quot; &quot; + s;

    vector&lt;int&gt; ne(n + 1);
    for(int i &#x3D; 2,j &#x3D; 0;i &lt;&#x3D; n;i++)
    &#123;
        while(j &amp;&amp; p[i]!&#x3D;p[j+1])    j &#x3D; ne[j];
        if(p[i]&#x3D;&#x3D;p[j+1])    j++;
        ne[i] &#x3D; j;
    &#125;

    for(int i &#x3D; 1,j &#x3D; 0;i &lt;&#x3D; m;i++)
    &#123;
        while(j &amp;&amp; s[i]!&#x3D;p[j+1])    j &#x3D; ne[j];
        if(s[i]&#x3D;&#x3D;p[j+1])    j++;
        if(j&#x3D;&#x3D;n)&#x2F;&#x2F;匹配成功
        &#123;
            res.push_back(i - n);&#x2F;&#x2F;匹配的下标从0开始
            j &#x3D; ne[j];
        &#125;
    &#125;
    return res;
&#125;;</code></pre>

<p><mark>模板题：</mark><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/833/">KMP字符串</a></p>
<h3 id="EX-KMP"><a href="#EX-KMP" class="headerlink" title="EX-KMP"></a>EX-KMP</h3><p><mark>Z函数：</mark>求一个字符串str以第 i 位开始的后缀与str的最长公共前缀（lcp）</p>
<p>使用z[i]表示第i位开始的后缀与str的最长公共前缀</p>
<p><mark>扩展KMP：</mark>给两个字符串str1、str2，求出str1的每一个后缀与str2的最长公共前缀，时间复杂度：O（n）</p>
<p><strong>推荐视频教学：</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Y54y1o7Ca?spm_id_from=333.337.search-card.all.click&vd_source=3d7e149b792ef13210101958098b6da2">扩展 KMP(Z 函数)</a></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5410">【模板】扩展 KMP（Z 函数）</a></p>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 2e7 + 7;
int n, m, z[N], p[N];
char a[N], b[N];

void Z(char *s, int n) 
&#123;
	z[1] &#x3D; n;

	for (int i &#x3D; 2, l &#x3D; 0, r &#x3D; 0; i &lt;&#x3D; n; i++) 
    &#123;
		if (i &lt;&#x3D; r) z[i] &#x3D; min(z[i - l + 1], r - i + 1);
		while (i + z[i] &lt;&#x3D; n &amp;&amp; s[i + z[i]] &#x3D;&#x3D; s[z[i] + 1]) ++z[i];
		if (i + z[i] - 1 &gt; r) l &#x3D; i, r &#x3D; i + z[i] - 1;
	&#125;
&#125;

void exkmp(char *s, int n, char *t, int m) 
&#123;
	Z(t, m);

	for (int i &#x3D; 1, l &#x3D; 0, r &#x3D; 0; i &lt;&#x3D; n; i++) 
    &#123;
		if (i &lt;&#x3D; r) p[i] &#x3D; min(z[i - l + 1], r - i + 1);
		while (i + p[i] &lt;&#x3D; n &amp;&amp; s[i + p[i]] &#x3D;&#x3D; t[p[i] + 1]) ++p[i];
		if (i + p[i] - 1 &gt; r) l &#x3D; i, r &#x3D; i + p[i] - 1;
	&#125;
&#125;

int main() 
&#123;
	scanf(&quot;%s%s&quot;,a + 1,b + 1);
    n &#x3D; strlen(a + 1),m &#x3D; strlen(b + 1);

	exkmp(a, n, b, m);

	ll res &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; m; i++) res ^&#x3D; 1ll * i * (z[i] + 1);
	printf(&quot;%lld\n&quot;,res);
	res &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) res ^&#x3D; 1ll * i * (p[i] + 1);
	printf(&quot;%lld\n&quot;,res);
	return 0;
&#125;</code></pre>



<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><mark>封装模板（一维双哈希）：</mark></p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当开多个 $Hash$ 结构体时，应注意空间问题，可将 $pw$ 数组开成全局变量，只初始化一次即可。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Hash
&#123;
    int base,mod;
    vector&lt;ll&gt; h,fh,pw;
    Hash(int _base,int _mod):base(_base),mod(_mod)&#123;&#125;

    void init()&#123;&#x2F;&#x2F;初始化
        h.resize(n + 1),fh.resize(n + 2),pw.resize(n + 1);
        pw[0] &#x3D; 1;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   pw[i] &#x3D; pw[i - 1] * base % mod;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   h[i] &#x3D; (h[i - 1] * base % mod + s[i]) % mod;
        for(int i &#x3D; n;i &gt;&#x3D; 1;i--)   fh[i] &#x3D; (fh[i + 1] * base % mod + s[i]) % mod;
    &#125;
    ll getz(int l,int r)&#123;&#x2F;&#x2F;获取区间正哈希值
        return (h[r] - h[l - 1] * pw[r - l + 1] % mod + mod) % mod;
    &#125;
    ll getf(int l,int r)&#123;&#x2F;&#x2F;获取区间反哈希值
        return (fh[l] - fh[r + 1] * pw[r - l + 1] % mod + mod) % mod;
    &#125;
    bool equ(int l,int r)&#123;&#x2F;&#x2F;比较该区间正反哈希值是否一致
        return getz(l,r) &#x3D;&#x3D; getf(l,r);
    &#125;
    bool equ(int l1,int r1,int l2,int r2)&#123;&#x2F;&#x2F;比较两区间正哈希值是否一致
        return getz(l1,r1) &#x3D;&#x3D; getz(l2,r2);
    &#125;
&#125;h1(131,998&#39;244&#39;353),h2(13331,1e9 + 7);</code></pre>

<p><mark>封装模板（二维哈希）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Hash
&#123;
    int base_x,base_y;
    vector&lt;vector&lt;ll&gt;&gt; h,fh;
    vector&lt;ll&gt; px,py;
    Hash(int _base_x, int _base_y): base_x(_base_x), base_y(_base_y) &#123;&#125;

    void init() &#123;&#x2F;&#x2F;初始化
        h.resize(n + 2), fh.resize(n + 2), px.resize(n + 1), py.resize(m + 1);
        for(int i &#x3D; 0;i &lt;&#x3D; n + 1;i++)   h[i].resize(m + 2),fh[i].resize(m + 2);
        px[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) px[i] &#x3D; px[i - 1] * base_x;
        py[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) py[i] &#x3D; py[i - 1] * base_y;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
            for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
                h[i][j] &#x3D; h[i - 1][j] * base_x + h[i][j - 1] * base_y - h[i - 1][j - 1] * base_x * base_y + s[i][j];
        for(int i &#x3D; n;i &gt;&#x3D; 1;i--)
            for(int j &#x3D; m;j &gt;&#x3D; 1;j--)
                fh[i][j] &#x3D; fh[i + 1][j] * base_x + fh[i][j + 1] * base_y - fh[i + 1][j + 1] * base_x * base_y + s[i][j];
    &#125;   
    ll getz(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;获取矩阵区间: [x1,y1] -&gt; [x2,y2] 的正哈希值
        ll X &#x3D; px[x2 - x1 + 1], Y &#x3D; py[y2 - y1 + 1];
        return h[x2][y2] - h[x2][y1 - 1] * Y - h[x1 - 1][y2] * X + h[x1 - 1][y1 - 1] * X * Y;
    &#125;;
    ll getf(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;获取矩阵区间: [x1,y1] -&gt; [x2,y2] 的反哈希值
        ll X &#x3D; px[x2 - x1 + 1],Y &#x3D; py[y2 - y1 + 1];
        return fh[x1][y1] - fh[x1][y2 + 1] * Y - fh[x2 + 1][y1] * X + fh[x2 + 1][y2 + 1] * X * Y;
    &#125;
    bool equ(int l1, int r1, int l2, int r2) &#123;&#x2F;&#x2F;判断矩阵区间: [l1,r1] -&gt; [l2,r2] 的正反哈希值是否一致
        return getz(l1, r1, l2, r2) &#x3D;&#x3D; getf(l1, r1, l2, r2);
    &#125;
&#125;h1(131,149),h2(13&#39;331,1e9 + 7);</code></pre>



<h3 id="一维哈希"><a href="#一维哈希" class="headerlink" title="一维哈希"></a>一维哈希</h3><blockquote>
<p>区间 $[l,r]$ 内的哈希值：$h[r] - h[l - 1] × pw[r - l + 1]$</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5 + 10;

int n,q;
char s[N];

struct Hash
&#123;
    int base,mod;
    vector&lt;ll&gt; h,pw;
    Hash(int _base,int _mod):base(_base),mod(_mod)&#123;&#125;

    void init()&#123;&#x2F;&#x2F;初始化
        h.resize(n + 1),pw.resize(n + 1);
        pw[0] &#x3D; 1;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   pw[i] &#x3D; pw[i - 1] * base % mod;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   h[i] &#x3D; (h[i - 1] * base % mod + s[i]) % mod;
    &#125;
    ll get(int l,int r)&#123;&#x2F;&#x2F;获取区间哈希值
        return (h[r] - h[l - 1] * pw[r - l + 1] % mod + mod) % mod;
    &#125;
    bool equ(int l1,int r1,int l2,int r2)&#123;&#x2F;&#x2F;比较两区间哈希值是否一致
        return get(l1,r1) &#x3D;&#x3D; get(l2,r2);
    &#125;
&#125;h1(131,998&#39;244&#39;353),h2(13331,1e9 + 7);

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; q;
    cin &gt;&gt; s + 1;

    h1.init();
    h2.init();

    while (q--)
    &#123;
        int l1,r1,l2,r2;
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;

        cout &lt;&lt; (h1.equ(l1,r1,l2,r2) &amp;&amp; h2.equ(l1,r1,l2,r2) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/">字符串哈希</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103729/problem/J">https://codeforces.com/gym/103729/problem/J</a></p>
<p><strong>$2023\ CCPC$ 深圳铜牌题（二分 + 哈希）：</strong> <a target="_blank" rel="noopener" href="https://vjudge.net/contest/594105#problem/G">G - 相似基因序列问题</a></p>
<h3 id="二维哈希"><a href="#二维哈希" class="headerlink" title="二维哈希"></a>二维哈希</h3><p><mark>模板题代码：</mark></p>
<p>由于这题空间卡的有点死，只有 $64M$，因此不能使用双哈希了，于是尝试了不同组合的模数，下面是单哈希代码：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
const int N &#x3D; 1010;

int n, m, a, b;
char s[N][N];

struct Hash
&#123;
    int base_x,base_y;
    vector&lt;vector&lt;ll&gt;&gt; h;
    vector&lt;ll&gt; px,py;
    Hash(int _base_x, int _base_y): base_x(_base_x), base_y(_base_y) &#123;&#125;

    void init() &#123;&#x2F;&#x2F;初始化
        h.resize(n + 1), px.resize(n + 1), py.resize(m + 1);
        for(int i &#x3D; 0;i &lt;&#x3D; n;i++)   h[i].resize(m + 1);
        px[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) px[i] &#x3D; px[i - 1] * base_x;
        py[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) py[i] &#x3D; py[i - 1] * base_y;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
            for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
                h[i][j] &#x3D; h[i - 1][j] * base_x + h[i][j - 1] * base_y - h[i - 1][j - 1] * base_x * base_y + s[i][j];
    &#125;
    ll get(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;获取矩阵区间 [x1,y1] -&gt; [x2,y2] 的哈希值
        ll X &#x3D; px[x2 - x1 + 1], Y &#x3D; py[y2 - y1 + 1];
        return h[x2][y2] - h[x2][y1 - 1] * Y - h[x1 - 1][y2] * X + h[x1 - 1][y1 - 1] * X * Y;
    &#125;;
&#125;h1(131,149),h2(13&#39;331,941);

int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;
    for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) 
    &#123;
        cin &gt;&gt; s[i] + 1;
    &#125;

    h1.init();

    unordered_set&lt;ll&gt; S;
    for(int i &#x3D; a;i &lt;&#x3D; n;i++)
    &#123;
        int x1 &#x3D; i - a + 1,x2 &#x3D; i;
        for(int j &#x3D; b;j &lt;&#x3D; m;j++)
        &#123;
            int y1 &#x3D; j - b + 1,y2 &#x3D; j;
            S.insert(h1.get(x1,y1,x2,y2));
        &#125;
    &#125;

    int q;
    cin &gt;&gt; q;
    while (q--)
    &#123;
        vector&lt;vector&lt;ll&gt;&gt; h(a + 1,vector&lt;ll&gt;(b + 1));
        for(int i &#x3D; 1;i &lt;&#x3D; a; i++)&#x2F;&#x2F;[1,1] -&gt; [a,b]
        &#123;
            cin &gt;&gt; s[i] + 1;
            for (int j &#x3D; 1; j &lt;&#x3D; b; j++) 
            &#123;
                h[i][j] &#x3D; h[i - 1][j] * h1.base_x + h[i][j - 1] * h1.base_y - h[i - 1][j - 1] * h1.base_x * h1.base_y + s[i][j];
            &#125;
        &#125;
        int x1 &#x3D; 1,y1 &#x3D; 1,x2 &#x3D; a,y2 &#x3D; b;
        ll X &#x3D; h1.px[x2 - x1 + 1], Y &#x3D; h1.py[y2 - y1 + 1];
        ll hash &#x3D; h[x2][y2] - h[x2][y1 - 1] * Y - h[x1 - 1][y2] * X + h[x1 - 1][y1 - 1] * X * Y;
        
        if(S.count(hash))    cout &lt;&lt; 1 &lt;&lt; &quot;\n&quot;;
        else    cout &lt;&lt; 0 &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/158/">矩阵</a></p>
<h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><blockquote>
<p><strong>应用：</strong>求序列的最长回文子串的长度是多少？</p>
<p><strong>算法需知：</strong></p>
<ul>
<li>在原串中，不管是奇数还是偶数的回文串，在新串中都对应长度为奇数的回文串。</li>
<li>细节方面：若原串空间为 $n(即数组下标为[0,n - 1])$，则新串空间长度需为 $2n + 3(即数组下标为[0,2n+2])$。</li>
<li><strong>具体而言，只需考虑 $[1,n]$，其中 $n$ 为更新后的长度，即 $n_{新} &#x3D; 2n_{原} + 1$ 为奇数，该区间串的内容为：”#a#a#”(以 $aa$ 字符串为例)。</strong></li>
</ul>
<p><strong>数组含义：</strong></p>
<ul>
<li>a[i]：原串</li>
<li>s[i]：新串</li>
<li>p[i]：新串中以 $i$ 为中心的最大回文串的半径是多少。</li>
</ul>
<p><strong>时间复杂度：</strong>$O(n)$</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e7 + 10;

int n;
char a[N &lt;&lt; 1],s[N &lt;&lt; 1];
int p[N &lt;&lt; 1];&#x2F;&#x2F;以i为中心的最大回文半径
void manacher()
&#123;
    n &#x3D; 0,s[0] &#x3D; &#39;$&#39;;&#x2F;&#x2F;构造新字符串
    int len &#x3D; strlen(a);
    for(int i &#x3D; 0;i &lt; len;i++) s[++n] &#x3D; &#39;#&#39;,s[++n] &#x3D; a[i];
    s[++n] &#x3D; &#39;#&#39;,s[n + 1] &#x3D; &#39;^&#39;;
    &#x2F;&#x2F;manacher匹配
    int mid &#x3D; 0,r &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        p[i] &#x3D; i &lt;&#x3D; r ? min(p[mid * 2 - i],r - i + 1) : 1;
        while(s[i - p[i]] &#x3D;&#x3D; s[i + p[i]])   p[i]++;
        if(i + p[i] - 1 &gt; r)    r &#x3D; i + p[i] - 1,mid &#x3D; i;
    &#125;
&#125;</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 2e7 + 10;

int n;
char a[N],s[N];
int p[N];&#x2F;&#x2F;以i为中心的最大回文半径

void init()
&#123;
    s[0] &#x3D; &#39;$&#39;;
    int len &#x3D; strlen(a);
    for(int i &#x3D; 0;i &lt; len;i++) s[++n] &#x3D; &#39;#&#39;,s[++n] &#x3D; a[i];
    s[++n] &#x3D; &#39;#&#39;,s[n + 1] &#x3D; &#39;^&#39;;
&#125;

void manacher()
&#123;
    init();
    int mid &#x3D; 0,r &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        p[i] &#x3D; i &lt;&#x3D; r ? min(p[mid * 2 - i],r - i + 1) : 1;
        while(s[i - p[i]] &#x3D;&#x3D; s[i + p[i]])   p[i]++;
        if(i + p[i] - 1 &gt; r)    r &#x3D; i + p[i] - 1,mid &#x3D; i;
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; a;
    
    manacher();

    int res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        res &#x3D; max(res,p[i]);
    
    cout &lt;&lt; res - 1 &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><strong>Manacher + 二分哈希探讨：</strong></p>
<ul>
<li>做题需要具备：<ul>
<li>二维Hash模板</li>
<li>一维 $manacher$ 转二维 $manacher$ 的建图方式</li>
</ul>
</li>
<li>然后对于建完后的图，讨论哪些是有效的 $n × n$ 的回文子矩阵，哈希模数取对即可。</li>
<li>还有一个细节就是开 $long long$，因为经过计算， $n × n$ 的矩阵中，最多有 $n × n + (n - 1) × (n - 1) + \cdots + 1 × 1$ 个，因此，该题极限数据 $n &#x3D; 2000$ 的情况下，是会有 $2668667000$ 个子矩阵满足条件，会超过 $int$ 的最大值（$2147483647$）。</li>
</ul>
<p><mark>代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

const int N &#x3D; 4010;
int n,m;
char a[N][N],s[N][N];

struct Hash
&#123;
    int base_x,base_y;
    vector&lt;vector&lt;ll&gt;&gt; h,fh;
    vector&lt;ll&gt; px,py;
    Hash(int _base_x, int _base_y): base_x(_base_x), base_y(_base_y) &#123;&#125;

    void init() &#123;&#x2F;&#x2F;初始化
        h.resize(n + 2), fh.resize(n + 2), px.resize(n + 1), py.resize(m + 1);
        for(int i &#x3D; 0;i &lt;&#x3D; n + 1;i++)   h[i].resize(m + 2),fh[i].resize(m + 2);
        px[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) px[i] &#x3D; px[i - 1] * base_x;
        py[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) py[i] &#x3D; py[i - 1] * base_y;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
            for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
                h[i][j] &#x3D; h[i - 1][j] * base_x + h[i][j - 1] * base_y - h[i - 1][j - 1] * base_x * base_y + s[i][j];
        for(int i &#x3D; n;i &gt;&#x3D; 1;i--)
            for(int j &#x3D; m;j &gt;&#x3D; 1;j--)
                fh[i][j] &#x3D; fh[i + 1][j] * base_x + fh[i][j + 1] * base_y - fh[i + 1][j + 1] * base_x * base_y + s[i][j];
    &#125;   
    ll getz(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;获取矩阵区间: [x1,y1] -&gt; [x2,y2] 的正哈希值
        ll X &#x3D; px[x2 - x1 + 1], Y &#x3D; py[y2 - y1 + 1];
        return h[x2][y2] - h[x2][y1 - 1] * Y - h[x1 - 1][y2] * X + h[x1 - 1][y1 - 1] * X * Y;
    &#125;;
    ll getf(int x1, int y1, int x2, int y2) &#123;&#x2F;&#x2F;获取矩阵区间: [x1,y1] -&gt; [x2,y2] 的反哈希值
        ll X &#x3D; px[x2 - x1 + 1],Y &#x3D; py[y2 - y1 + 1];
        return fh[x1][y1] - fh[x1][y2 + 1] * Y - fh[x2 + 1][y1] * X + fh[x2 + 1][y2 + 1] * X * Y;
    &#125;
    bool equ(int l1, int r1, int l2, int r2) &#123;&#x2F;&#x2F;判断矩阵区间: [l1,r1] -&gt; [l2,r2] 的正反哈希值是否一致
        return getz(l1, r1, l2, r2) &#x3D;&#x3D; getf(l1, r1, l2, r2);
    &#125;
&#125;h1(131,149),h2(13&#39;331,1e9 + 7);

int main()
&#123;
    IOS;
    cin &gt;&gt; n &gt;&gt; m;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i] + 1;

    auto init &#x3D; [&amp;]() -&gt; void
    &#123;
        n &#x3D; n * 2 + 1,m &#x3D; m * 2 + 1;
        for(int i &#x3D; 0;i &lt;&#x3D; n + 1;i++)   s[i][0] &#x3D; &#39;$&#39;;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        &#123;
            for(int j &#x3D; 1,idx &#x3D; 1;j &lt;&#x3D; m;)
            &#123;
                if(i &amp; 1)  s[i][j++] &#x3D; &#39;#&#39;;
                else    s[i][j++] &#x3D; &#39;#&#39;, s[i][j++] &#x3D; a[i &#x2F; 2][idx++];
            &#125;
        &#125;
        for(int i &#x3D; 0; i &lt;&#x3D; n + 1; i++)   s[i][m + 1] &#x3D; &#39;^&#39;;
        for(int i &#x3D; 0; i &lt;&#x3D; m; i++) s[0][i] &#x3D; &#39;$&#39;;
        for(int i &#x3D; 0; i &lt;&#x3D; m; i++) s[n + 1][i] &#x3D; &#39;^&#39;;
        s[n + 1][0] &#x3D; &#39;$&#39;;
    &#125;;

    init();
    &#x2F;&#x2F; for(int i &#x3D; 0;i &lt;&#x3D; n + 1;i++)   cout &lt;&lt; s[i] &lt;&lt; endl;

    h1.init();
    h2.init();

    auto check &#x3D; [&amp;](int l1,int r1,int l2,int r2) -&gt; bool
    &#123;
        if(l1 &lt;&#x3D; 0 || r1 &lt;&#x3D; 0 || l2 &gt; n || r2 &gt; m)    return false;
        return h1.equ(l1,r1,l2,r2) &amp;&amp; h2.equ(l1,r1,l2,r2);
    &#125;;
   
    ll res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        int mid &#x3D; 0,r &#x3D; 0;
        vector&lt;int&gt; p(m + 1);
        for(int j &#x3D; 1;j &lt;&#x3D; m;j++)
        &#123;
            p[j] &#x3D; j &lt;&#x3D; r ? min((int)p[mid * 2 - j],r - j + 1) : 1;
            while(check(i - p[j],j - p[j],i + p[j],j + p[j])) p[j]++;
            if(j + p[j] - 1 &gt; r)    r &#x3D; j + p[j] - 1,mid &#x3D; j;
            if((s[i][j] &#x3D;&#x3D; &#39;#&#39; &amp;&amp; s[i - 1][j - 1] !&#x3D; &#39;#&#39;) || s[i][j] !&#x3D; &#39;#&#39;)  res +&#x3D; p[j] &#x2F; 2;
        &#125;
    &#125;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3190/">Manacher算法</a></p>
<p><strong>$Manacher$ + 差分：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33540/A">花非花</a></p>
<p><strong>$Manacher$ + 简单 $dp$：</strong>[Link with Centrally Symmetric Strings](Link with Centrally Symmetric Strings)</p>
<p><strong>$Manacher$ + 二维哈希：</strong> <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57357/G">Beautiful Matrix</a></p>
<h2 id="回文自动机（PAM）"><a href="#回文自动机（PAM）" class="headerlink" title="回文自动机（PAM）"></a>回文自动机（PAM）</h2><blockquote>
<p>Palindrome Automaton（回文自动机，回文树）是一种能够识别所有回文子串的数据结构。</p>
<p><strong>时间复杂度：</strong>线性</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct PAM
&#123;
    int last,idx;
    vector&lt;array&lt;int,26&gt;&gt; tr;
    vector&lt;int&gt; fail,len,cnt;

    PAM():last(0),idx(0)&#123;
        fail.resize(n + 2),len.resize(n + 2),tr.resize(n + 2),cnt.resize(n + 2);
    &#125;
    int newnode(int l)&#123;&#x2F;&#x2F;新增一个结点，长度为l
        len[idx] &#x3D; l;
        tr[idx].fill(0);
        return idx++;
    &#125;
    void init()&#123;
        idx &#x3D; last &#x3D; 0;
        newnode(0),newnode(-1);&#x2F;&#x2F;偶根长度为0，奇根长度为-1
        s[0] &#x3D; -1,fail[0] &#x3D; 1;&#x2F;&#x2F;偶根的失配边指向奇根，奇根的失配边指向偶根
    &#125;
    int get_fail(int p,int i)&#123;
        while(s[i - len[p] - 1] !&#x3D; s[i])    p &#x3D; fail[p];
        return p;
    &#125;
    void insert(int i)&#123;
        int u &#x3D; s[i] - &#39;a&#39;,p &#x3D; get_fail(last,i);
        if(!tr[p][u])
        &#123;
            int now &#x3D; newnode(len[p] + 2);
            fail[now] &#x3D; tr[get_fail(fail[p],i)][u];
            tr[p][u] &#x3D; now;
        &#125;
        last &#x3D; tr[p][u];
        cnt[last]++;
    &#125;
&#125;;</code></pre>

<p><mark>模板题1代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

const int N &#x3D; 3e5 + 10;

int n;
char s[N];

struct PAM
&#123;
    int last,idx;
    vector&lt;array&lt;int,26&gt;&gt; tr;
    vector&lt;int&gt; fail,len,cnt;

    PAM():last(0),idx(0)&#123;
    fail.resize(n + 2),len.resize(n + 2),tr.resize(n + 2),cnt.resize(n + 2);
    &#125;
    int newnode(int l)&#123;&#x2F;&#x2F;新增一个结点，长度为l
        len[idx] &#x3D; l;
        tr[idx].fill(0);
        return idx++;
    &#125;
    void init()&#123;
        idx &#x3D; last &#x3D; 0;
        newnode(0),newnode(-1);&#x2F;&#x2F;偶根长度为0，奇根长度为-1
        s[0] &#x3D; -1,fail[0] &#x3D; 1;&#x2F;&#x2F;偶根的失配边指向奇根，奇根的失配边指向偶根
    &#125;
    int get_fail(int p,int i)&#123;
        while(s[i - len[p] - 1] !&#x3D; s[i])    p &#x3D; fail[p];
        return p;
    &#125;
    void insert(int i)&#123;
        int u &#x3D; s[i] - &#39;a&#39;,p &#x3D; get_fail(last,i);
        if(!tr[p][u])&#123;
            int now &#x3D; newnode(len[p] + 2);
            fail[now] &#x3D; tr[get_fail(fail[p],i)][u];
            tr[p][u] &#x3D; now;
        &#125;
        last &#x3D; tr[p][u];
        cnt[last]++;
    &#125;
&#125;;

int main()
&#123;
    IOS;
    cin &gt;&gt; n &gt;&gt; s + 1;

    PAM pam;
    pam.init();

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   pam.insert(i);

    for(int i &#x3D; pam.idx - 1;~i;i--)
        pam.cnt[pam.fail[i]] +&#x3D; pam.cnt[i];

    ll res &#x3D; 0;
    for(int i &#x3D; 2;i &lt; pam.idx;i++)  res &#x3D; max(res,(ll)pam.len[i] * pam.cnt[i]);

    cout &lt;&lt; res;
    return 0;
&#125;</code></pre>

<p><mark>模板题2代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

const int N &#x3D; 3e5 + 10;

int n;
char s[N];

struct PAM
&#123;
    int last,idx;
    vector&lt;array&lt;int,26&gt;&gt; tr;
    vector&lt;int&gt; fail,len,cnt,mask;

    PAM():last(0),idx(0)&#123;
    fail.resize(n + 2),len.resize(n + 2),tr.resize(n + 2),mask.resize(n + 2),cnt.resize(n + 2);
    &#125;
    int newnode(int l)&#123;&#x2F;&#x2F;新增一个结点，长度为l
        len[idx] &#x3D; l;
        tr[idx].fill(0);
        return idx++;
    &#125;
    void init()&#123;
        idx &#x3D; last &#x3D; 0;
        newnode(0),newnode(-1);&#x2F;&#x2F;偶根长度为0，奇根长度为-1
        s[0] &#x3D; -1,fail[0] &#x3D; 1;&#x2F;&#x2F;偶根的失配边指向奇根，奇根的失配边指向偶根
    &#125;
    int get_fail(int p,int i)&#123;
        while(s[i - len[p] - 1] !&#x3D; s[i])    p &#x3D; fail[p];
        return p;
    &#125;
    void insert(int i)&#123;
        int u &#x3D; s[i] - &#39;a&#39;,p &#x3D; get_fail(last,i);
        if(!tr[p][u])&#123;
            int now &#x3D; newnode(len[p] + 2);
            mask[now] &#x3D; mask[p] | (1 &lt;&lt; u);
            fail[now] &#x3D; tr[get_fail(fail[p],i)][u];
            tr[p][u] &#x3D; now;   
        &#125;
        last &#x3D; tr[p][u];
        cnt[last]++;
    &#125;
&#125;;

int main()
&#123;
    IOS;
    cin &gt;&gt; s + 1;
    n &#x3D; strlen(s + 1);

    PAM pam;
    pam.init();

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   pam.insert(i);

    auto count &#x3D; [&amp;](int x) -&gt; int
    &#123;
        int res &#x3D; 0;
        while(x)    x -&#x3D; (x &amp; -x),res++;
        return res;
    &#125;;

    for(int i &#x3D; pam.idx - 1;~i;i--)
        pam.cnt[pam.fail[i]] +&#x3D; pam.cnt[i];
    
    ll res &#x3D; 0;
    for(int i &#x3D; 2;i &lt; pam.idx;i++)
    &#123;
        res +&#x3D; pam.cnt[i] * count(pam.mask[i]);
    &#125;
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark><br><strong>模板题1：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33548/F">[APIO2014]回文串</a></p>
<p><strong>模板题2：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33548/G">Colorful String</a></p>
<p><strong>PAM + Hash：</strong><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7327">String Magic (Hard Version)</a></p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><blockquote>
<p>字典树。用来存储和查询字符串（01串）。</p>
</blockquote>
<p><mark>模板：</mark></p>
<h3 id="存储字符串"><a href="#存储字符串" class="headerlink" title="存储字符串"></a>存储字符串</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10,M &#x3D; N * 26;

int n,idx;
int son[N][26],sz[N];

void insert(string s)
&#123;
    int p &#x3D; 0;
    for(int i &#x3D; 0;i &lt; s.size();i++)
    &#123;
        int u &#x3D; s[i] - &#39;a&#39;;
        if(!son[p][u])  son[p][u] &#x3D; ++idx;
        p &#x3D; son[p][u];
    &#125;
    sz[p]++;
&#125;

int query(string s)
&#123;
    int p &#x3D; 0;
    for(int i &#x3D; 0;i &lt; s.size();i++)
    &#123;
        int u &#x3D; s[i] - &#39;a&#39;;
        if(!son[p][u])  return 0;
        else    p &#x3D; son[p][u];
    &#125;
    return sz[p];
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;

    while (n--)
    &#123;
        char op;
        string s;
        cin &gt;&gt; op &gt;&gt; s;
        if(op &#x3D;&#x3D; &#39;I&#39;)   insert(s);
        else    cout &lt;&lt; query(s) &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<h3 id="存储01串"><a href="#存储01串" class="headerlink" title="存储01串"></a>存储01串</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int N &#x3D; 1e5+10,M &#x3D; 31 * N;
int a[N];
int son[M][2];
int n,idx;
void insert(int x)
&#123;
    int p &#x3D; 0;
    for(int i &#x3D; 30;i &gt;&#x3D; 0;i--)
    &#123;
        int u &#x3D; x &gt;&gt; i &amp; 1;
        if(!son[p][u])  son[p][u] &#x3D; ++idx;
        p &#x3D; son[p][u];
    &#125;
&#125;
int query(int x)
&#123;
    int p &#x3D; 0,res &#x3D; 0;
    for(int i &#x3D; 30;i &gt;&#x3D; 0;i--)
    &#123;
        int u &#x3D; x &gt;&gt; i &amp; 1;
        if(son[p][!u])
        &#123;
            p &#x3D; son[p][!u];
            res &#x3D; res * 2 + !u;
        &#125;
        else
        &#123;
            p &#x3D; son[p][u];
            res &#x3D; res * 2 + u;
        &#125;
    &#125;
    return res;
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;,&amp;n);
    int ans &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        insert(a[i]);
        int t &#x3D; query(a[i]);
        ans &#x3D; max(ans,a[i] ^ t);
    &#125;
    printf(&quot;%d\n&quot;,ans);
&#125;</code></pre>

<h3 id="可持久化Trie"><a href="#可持久化Trie" class="headerlink" title="可持久化Trie"></a>可持久化Trie</h3><blockquote>
<p>可持久化的前提：本身的拓扑结构不变。</p>
</blockquote>
<p><strong>最大异或和思路：</strong></p>
<ul>
<li>公式可转化为：$a[p] \oplus a[p + 1] \oplus \cdots \oplus a[N] \oplus x &#x3D; s[N] \oplus s[p - 1] \oplus x &#x3D; s[p - 1] \oplus b$，其中 $b &#x3D; s[N] \oplus x$ 为定值，即在区间 $[l - 1,r - 1]$ 之间找一个位置，使得 $s[p - 1] \oplus b$ 最大。 </li>
<li>对于$[1,R]$ 查询与 $x$ 异或的最大值，只需看 $root[R - 1]$ 这个版本即可；而题目要求的是 $[L,R]$ 这个区间，因此，需要判断最优的那个结点里面是否最大值下标是大于等于 $L - 1$ 的，因此需要在每个结点里面存一个最大下标。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 6e5 + 10,M &#x3D; N * 25;

int n,m;
int s[N];
int tr[M][2],max_id[M];
int root[N],idx;

void insert(int i,int k,int p,int q)
&#123;
    if(k &lt; 0)
    &#123;
        max_id[q] &#x3D; i;
        return;
    &#125;
    int v &#x3D; s[i] &gt;&gt; k &amp; 1;
    if(p)   tr[q][v ^ 1] &#x3D; tr[p][v ^ 1];
    tr[q][v] &#x3D; ++idx;
    insert(i,k - 1,tr[p][v],tr[q][v]);
    max_id[q] &#x3D; max(max_id[tr[q][0]],max_id[tr[q][1]]);
&#125;

int query(int root,int C,int L)
&#123;
    int p &#x3D; root;
    for(int i &#x3D; 23;i &gt;&#x3D; 0;i--)
    &#123;
        int v &#x3D; C &gt;&gt; i &amp; 1;
        if(max_id[tr[p][v ^ 1]] &gt;&#x3D; L)   p &#x3D; tr[p][v ^ 1];
        else    p &#x3D; tr[p][v];
    &#125;
    return C ^ s[max_id[p]];
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; m;
    max_id[0] &#x3D; -1;
    root[0] &#x3D; ++idx;
    insert(0,23,0,root[0]);

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        int x;
        cin &gt;&gt; x;
        s[i] &#x3D; s[i - 1] ^ x;
        root[i] &#x3D; ++idx;
        insert(i,23,root[i - 1],root[i]);
    &#125;

    char op[2];
    int l,r,x;
    while (m--)
    &#123;
        cin &gt;&gt; op;
        if(*op &#x3D;&#x3D; &#39;A&#39;)
        &#123;
            cin &gt;&gt; x;
            n++;
            s[n] &#x3D; s[n - 1] ^ x;
            root[n] &#x3D; ++idx;
            insert(n,23,root[n - 1],root[n]);
        &#125;
        else
        &#123;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
            cout &lt;&lt; query(root[r - 1],s[n] ^ x,l - 1) &lt;&lt; &quot;\n&quot;;
        &#125;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<ul>
<li><strong>模板题1（存储字符串）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></li>
<li><strong>模板题2（存储01串）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/145/">最大异或对</a></li>
<li><strong>模板题3（可持久化Trie）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/258/">最大异或和</a></li>
</ul>
<p><strong>区间异或和最大值：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1847/problem/C">C. Vampiric Powers, anyone?</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1851/problem/F">F. Lisa and the Martians</a></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
struct DSU &#123;
    vector&lt;T&gt; p, sz;
    DSU(T n) : p(n), sz(n, 1) &#123; iota(p.begin(), p.end(), 0); &#125;
    void init(int n) &#123;&#x2F;&#x2F;初始化
    p.resize(n);
    iota(p.begin(), p.end(), 0);
    sz.assign(n, 1);
    &#125;
    T find(T x) &#123; &#x2F;&#x2F;找父节点
       while (x !&#x3D; p[x]) x &#x3D; p[x] &#x3D; p[p[x]];
       return x;
    &#125;
    bool merge(T x, T y) &#123; &#x2F;&#x2F;合并集合
       x &#x3D; find(x);
       y &#x3D; find(y);
       if (x &#x3D;&#x3D; y) return false;
       sz[x] +&#x3D; sz[y];
       p[y] &#x3D; x;
       return true;
    &#125;
    bool same(T x, T y) &#123; return find(x) &#x3D;&#x3D; find(y); &#125;&#x2F;&#x2F;判断是否在同一集合
    T size(T x) &#123; return sz[find(x)]; &#125;&#x2F;&#x2F;获取集合大小
&#125;;</code></pre>

<p><mark>一般形式：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void init(int n)
&#123;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)	p[i] &#x3D; i;
&#125;

int find(int x)
&#123;
	return x &#x3D;&#x3D; p[x] ? p[x] &#x3D; find(p[x]);
&#125;</code></pre>

<p><mark>维护 $size$ 的并查集：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">bool merge(T x, T y) &#123; &#x2F;&#x2F;合并集合
    x &#x3D; find(x);
    y &#x3D; find(y);
    if (x &#x3D;&#x3D; y) return false;
    sz[x] +&#x3D; sz[y]; &#x2F;&#x2F; 关键代码
    p[y] &#x3D; x; &#x2F;&#x2F; 关键代码
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>并查集 + 坐标转换：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1252/">格子游戏</a></p>
<p><strong>维护 $size$ 的并查集：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/722/problem/C">C. Destroying Array</a></p>
<p><strong>补充：二维坐标转化为一维坐标公式：</strong></p>
<p>当(x,y)是从(0,0)点开始的时候：x * n + y	(0,1,2,3,4,5,6,7,8,……)</p>
<p>当(x,y)是从(1,1)点开始的时候：(x - 1) * n + y	(1,2,3,4,5,6,7,8,9,……)</p>
<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><blockquote>
<p>特点：它的每一条边都记录了每个节点到根节点的一个权值。</p>
</blockquote>
<p>集合合并时，需要更新  $d[px]$ 的值，更新过程如下：</p>
<p><img src="/images/3.png"></p>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">function&lt;int(int)&gt; find &#x3D; [&amp;](int x) -&gt; int
&#123;
    if(x !&#x3D; p[x])
    &#123;
        int t &#x3D; find(p[x]);
        dist[x] +&#x3D; dist[p[x]];
        p[x] &#x3D; t;
    &#125;
    return p[x];
&#125;;

auto merge &#x3D; [&amp;](int a,int b,int d) -&gt; void
&#123;
    int pa &#x3D; find(a),pb &#x3D; find(b);
    if(pa !&#x3D; pb)
    &#123;
        p[pa] &#x3D; pb;
        dist[pa] &#x3D; dist[b] - dist[a] + d;
    &#125;
&#125;;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/242/">食物链</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1850/problem/H">H. The Third Letter</a></p>
<h3 id="拓展域并查集"><a href="#拓展域并查集" class="headerlink" title="拓展域并查集"></a>拓展域并查集</h3><p>该题也可以以食物链为参考，见这个视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yW4y1r7Aq/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=3d7e149b792ef13210101958098b6da2">扩展域并查集及其应用</a></p>
<p><strong>解析：</strong></p>
<p>将A（本身）定义为 $1-n$，B（食物）定义为 $2-2n$，C（天敌）定义为 $3-3n$。</p>
<p>三种关系，开三倍空间；</p>
<p>如果 $x$ 与 $y$ 是同类关系，需要更新三个关系：</p>
<ul>
<li>$x$ 与 $y$ 是同类；</li>
<li>$x + n$ 与 $y + n$ 是同类；</li>
<li>$x + n + n$ 与 $y + n + n$ 是同类；</li>
</ul>
<p>如果是 $x$ 吃 $y$ 的关系，则需要更新以下三个关系：</p>
<ul>
<li>$x + n$ 与 $y$ 是同类；</li>
<li>$y + n+n$ 与 $x$ 是同类；</li>
<li>$x + n + n$ 与 $y + n$ 是同类；</li>
</ul>
<p>因此，即可完成本道题。需要注意的是：判断是用其他情况来判断本身情况的，即只要不矛盾，就是真。</p>
<p><mark>代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int n, m;
	cin &gt;&gt; n &gt;&gt; m;

	vector&lt;int&gt; p(3 * n + 1);
	iota(p.begin(), p.end(), 0);

	function&lt;int(int)&gt; find &#x3D; [&amp;](int x) -&gt; int
	&#123;
		return x &#x3D;&#x3D; p[x] ? x : p[x] &#x3D; find(p[x]);
	&#125;;

	int res &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
	&#123;
		int op, x, y;
		cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;
		if (x &gt; n || y &gt; n)	
		&#123;
			res ++;
			continue;
		&#125;
		if (op &#x3D;&#x3D; 1)
		&#123;
			if (find(x + n) &#x3D;&#x3D; find(y) || find(x + 2 * n) &#x3D;&#x3D; find(y))	
			&#123;
				res++;
				continue;
			&#125;
			p[find(x)] &#x3D; find(y);
			p[find(x + n)] &#x3D; find(y + n);
			p[find(x + 2 * n)] &#x3D; find(y + 2 * n);
		&#125;
		else
		&#123;
			if (find(x) &#x3D;&#x3D; find(y) || find(y) &#x3D;&#x3D; find(x + 2 * n))	
			&#123;
				res++;
				continue;
			&#125;
			p[find(x + n)] &#x3D; find(y);
			p[find(y + 2 * n)] &#x3D; find(x);
			p[find(x + 2 * n)] &#x3D; find(y + n);
		&#125;
	&#125;

	cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/242/">食物链</a></p>
<h2 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h2><blockquote>
<p><strong>基本思想：</strong>将小的集合，合并到大的集合里。</p>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
</blockquote>
<p><strong>模板题讲解：</strong></p>
<ul>
<li><strong>题意：</strong><ul>
<li>给点 $n$ 个数，定义数字相同的为同一颜色，连续相同颜色的数为一段。</li>
<li>询问1：将所有数 $x$ 修改为 $y$；</li>
<li>询问2：一共有多少段？</li>
</ul>
</li>
<li><strong>思路：</strong><ol>
<li>如何统计答案？<ul>
<li>定义两个临界，即 $a[0]$ 与 $a[n]$ 颜色都为 $0$，则临界位置是和上一个位置的颜色是不同的（通俗讲就是第二段颜色的第一个和第一段颜色的最后一个的颜色一定是不相同的），同一段颜色内部（不算第一个）是和上一个位置颜色是相同的。故基于此想法，假设应该有 $n$ 段，用公式：$ans +&#x3D; a[i] \neq a[i - 1]$ 后，可以得到 $n - 1$ 段，为了减少处理边界的情况，人为定义 $a[0]$ 与 $a[n]$ 段是一个不存在的颜色，即又增加了 $2$ 段，故最终正确段数答案应为 $ans - 1$。</li>
</ul>
</li>
<li>将颜色 $x$ 合并到颜色 $y$ 中。<ul>
<li>若 $size|x| \le size|y|$，正常处理即可；</li>
<li>若 $size|x| &gt; size|y|$，则会将 $y$ 合并到 $x$ 中，而中间有个映射转换，下面将细讲：<ul>
<li>将 $y$ 中的颜色对应下标都放到 $x$ 中，并将对应下标都改成与 $x$ 一致，此时原数组中的所有本是 $y$ 颜色的却全部变成了 $x$ 的颜色，这里暂时没什么问题；</li>
<li>下次如果再用到 $y$ 颜色，本身应该是有 $y$ 颜色的，但原数组是没有 $y$ 颜色的， 但是 $pos[y]$ 是有大小的（上一次是将 $pos[x]$ 给清空了，很符合 将 $x$ 合并成 $y$），因此映射转换在这里。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

int main()
&#123;
    IOS;
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n + 2);
    vector&lt;vector&lt;int&gt;&gt; pos(1e6 + 10);

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        cin &gt;&gt; a[i];
        pos[a[i]].push_back(i);
    &#125;

    int ans &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n + 1;i++)
        ans +&#x3D; a[i] !&#x3D; a[i - 1];
    
    while (m--)
    &#123;
        int op,x,y;
        cin &gt;&gt; op;
        if(op &#x3D;&#x3D; 1)
        &#123;
            cin &gt;&gt; x &gt;&gt; y;
            if(x &#x3D;&#x3D; y)  continue;
            if(pos[x].size() &gt; pos[y].size())   swap(pos[x],pos[y]);
            if(pos[y].empty())  continue;

            int color &#x3D; a[pos[y][0]];

            auto modify &#x3D; [&amp;](int p,int color) -&gt; void
            &#123;
                ans -&#x3D; (a[p] !&#x3D; a[p - 1]) + (a[p] !&#x3D; a[p + 1]);
                a[p] &#x3D; color;
                ans +&#x3D; (a[p] !&#x3D; a[p - 1]) + (a[p] !&#x3D; a[p + 1]);
            &#125;;

            for(auto p : pos[x])
            &#123;
                modify(p,color);
                pos[y].push_back(p);
            &#125;
            pos[x].clear();
        &#125;
        else    cout &lt;&lt; ans - 1 &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2156/">梦幻布丁</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1851/problem/G">G. Vlad and the Mountains</a></p>
<h3 id="DSU-on-tree"><a href="#DSU-on-tree" class="headerlink" title="DSU on tree"></a>DSU on tree</h3><blockquote>
<p>本质上：启发式合并（跟 $DSU$ 关系不大）</p>
</blockquote>
<p><mark>模板题（解决子树问题）代码：</mark></p>
<ul>
<li><strong>问题：</strong>树上每个点都有颜色，问以每个点为根的子树主要颜色之和为多少？定义主要颜色为该子树出现次数最多的颜色，颜色可能多个。</li>
<li><strong>思路：</strong><ul>
<li>复用重子树的信息，利用树链剖分的重链剖分思想，将时间复杂度优化为：$O(NlogN)$。</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; color(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; color[i];

    vector&lt;vector&lt;int&gt;&gt; g(n + 1);
    for (int i &#x3D; 1; i &lt; n; i++)
    &#123;
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        g[u].push_back(v);
        g[v].push_back(u);
    &#125;

    vector&lt;int&gt; sz(n + 1), heav_son(n + 1);
    vector&lt;int&gt; l(n + 1), r(n + 1), id(n + 1);
    int idx &#x3D; 0;
    function&lt;void(int, int)&gt; dfs1 &#x3D; [&amp;](int u, int fa) -&gt; void
    &#123;
        l[u] &#x3D; ++idx, id[idx] &#x3D; u, sz[u] &#x3D; 1;
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa)    continue;
            dfs1(v, u);
            sz[u] +&#x3D; sz[v];
            if (sz[v] &gt; sz[heav_son[u]])
                heav_son[u] &#x3D; v;
        &#125;
        r[u] &#x3D; idx;
    &#125;;

    dfs1(1, -1);

    vector&lt;ll&gt; cnt(n + 1), res(n + 1);
    ll mx &#x3D; 0, ans &#x3D; 0;
    auto add &#x3D; [&amp;](int u) -&gt; void
    &#123;
        int col &#x3D; color[u];
        cnt[col]++;
        if (cnt[col] &gt; mx)
        &#123;
            mx &#x3D; cnt[col];
            ans &#x3D; col;
        &#125;
        else if (cnt[col] &#x3D;&#x3D; mx)
        &#123;
            ans +&#x3D; col;
        &#125;
    &#125;;

    auto del &#x3D; [&amp;](int u) -&gt; void
    &#123;
        int col &#x3D; color[u];
        cnt[col]--;
    &#125;;

    function&lt;void(int, int, int)&gt; dfs2 &#x3D; [&amp;](int u, int fa, int keep) -&gt; void
    &#123;
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa || v &#x3D;&#x3D; heav_son[u])    continue;
            dfs2(v, u, 0);
        &#125;

        if (heav_son[u])    dfs2(heav_son[u], u, 1);

        add(u);
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa || v &#x3D;&#x3D; heav_son[u])    continue;
            for (int i &#x3D; l[v]; i &lt;&#x3D; r[v]; i++)  add(id[i]);
        &#125;

        res[u] &#x3D; ans;
        if (!keep)
        &#123;
            del(u);
            for (auto v : g[u])
            &#123;
                if (v &#x3D;&#x3D; fa)    continue;
                for (int i &#x3D; l[v]; i &lt;&#x3D; r[v]; i++)  del(id[i]);
            &#125;
            ans &#x3D; mx &#x3D; 0;
        &#125;
    &#125;;

    dfs2(1, -1, 0);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cout &lt;&lt; res[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];

    return 0;
&#125;</code></pre>

<p><mark>解决路径问题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n,k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; g(n + 1);
    for(int i &#x3D; 1;i &lt; n;i++)
    &#123;
        int a,b,w;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
        a++,b++;
        g[a].push_back(&#123;b,w&#125;);
        g[b].push_back(&#123;a,w&#125;);
    &#125;

    vector&lt;int&gt; l(n + 1),r(n + 1),id(n + 1),sz(n + 1),son(n + 1);
    int tot &#x3D; 0;
    vector&lt;int&gt; dep1(n + 1);&#x2F;&#x2F;边长度
    vector&lt;ll&gt; dep2(n + 1);&#x2F;&#x2F;权值
    function&lt;void(int,int)&gt; dfs1 &#x3D; [&amp;](int u,int fa) -&gt; void
    &#123;
        l[u] &#x3D; ++tot, id[tot] &#x3D; u, sz[u] &#x3D; 1;

        for(auto [v,w] : g[u])
        &#123;
            if(v &#x3D;&#x3D; fa) continue;
            dep1[v] &#x3D; dep1[u] + 1;
            dep2[v] &#x3D; dep2[u] + w;
            
            dfs1(v,u);
            sz[u] +&#x3D; sz[v];
            if(sz[son[u]] &lt; sz[v])  son[u] &#x3D; v;
        &#125;
        r[u] &#x3D; tot;
    &#125;;

    dfs1(1,-1);

    map&lt;ll,int&gt; mp;
    int ans &#x3D; n + 1;
    function&lt;void(int,int,bool)&gt; dfs2 &#x3D; [&amp;](int u,int fa,bool keep) -&gt; void
    &#123;
        for(auto [v,w] : g[u])
        &#123;
            if(v !&#x3D; fa &amp;&amp; v !&#x3D; son[u])  dfs2(v,u,false);
        &#125;

        if(son[u])  dfs2(son[u],u,true);

        auto query &#x3D; [&amp;](int v) -&gt; void
        &#123;
            ll d2 &#x3D; k - dep2[v] + 2 * dep2[u]; 
            if(mp.count(d2))
            &#123;
                ans &#x3D; min(ans,mp[d2] + dep1[v] - 2 * dep1[u]);
            &#125;
        &#125;;

        auto add &#x3D; [&amp;](int v) -&gt; void
        &#123;
            if(mp.count(dep2[v]))   
                mp[dep2[v]] &#x3D; min(mp[dep2[v]],dep1[v]);
            else    mp[dep2[v]] &#x3D; dep1[v];
        &#125;;

        for(auto [v,w] : g[u])
        &#123;
            if(v &#x3D;&#x3D; fa || v &#x3D;&#x3D; son[u])  continue;
            for(int x &#x3D; l[v];x &lt;&#x3D; r[v];x++) query(id[x]);
            for(int x &#x3D; l[v];x &lt;&#x3D; r[v];x++) add(id[x]);
        &#125;

        query(u),add(u);
        if(!keep)   mp.clear();
    &#125;;

    
    dfs2(1,-1,false);
    if(ans &gt;&#x3D; n + 1)    ans &#x3D; -1;
    
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题（解决子树问题）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3191/">Lomsat gelral</a>	</p>
<p><strong>模板题（解决路径问题）：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4149">Race</a></p>
<p><strong>$2023$ 蓝桥杯 $A$ 组省赛题（统计方法跟模板题类似）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5001/">颜色平衡树</a></p>
<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><blockquote>
<p>判断两个头尾相接字符串（循环同构字符串）是否相同，并可以求出最小字典序的表示法。</p>
<p>时间复杂度：O（n）</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;

using namespace std;

const int N &#x3D; 2e6 + 10;

int n;
char a[N],b[N];

int get_min(char s[])
&#123;
    int i &#x3D; 0,j &#x3D; 1;
    while (i &lt; n &amp;&amp; j &lt; n)
    &#123;
        int k &#x3D; 0;
        while(k &lt; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k])  k++;
        if(k &#x3D;&#x3D; n)  break;
        if(s[i + k] &gt; s[j + k]) i +&#x3D; k + 1;
        else  j +&#x3D; k + 1;
        if(i &#x3D;&#x3D; j)  j++;
    &#125;
    int k &#x3D; min(i,j);
    s[k + n] &#x3D; 0;
    return k;
&#125;

int main()
&#123;
    cin &gt;&gt; a &gt;&gt; b;
    n &#x3D; strlen(a);
    memcpy(a + n,a,n);
    memcpy(b + n,b,n);

    int x &#x3D; get_min(a),y &#x3D; get_min(b);
    if(strcmp(a + x,b + y)) puts(&quot;No&quot;);
    else
    &#123;
        puts(&quot;Yes&quot;);
        puts(a + x);
    &#125;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/160/">项链</a></p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><blockquote>
<p><strong>树状数组</strong>，又以其发明者命名为<strong>Fenwick</strong>树。现多用于高效计算数列的前缀和， 区间和。</p>
<p><mark>注意：</mark>区间最小是从1开始，不能从0开始（否则会死循环）。</p>
</blockquote>
<p><mark>常用函数：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">ll lowbit(ll x)
&#123;
	return x &amp; -x;
&#125;

void add(int x,ll c)
&#123;
    for(int i &#x3D; x;i &lt;&#x3D; n;i +&#x3D; lowbit(i))
    &#123;
        tr[i] +&#x3D; c;
    &#125;
&#125;

ll sum(int x)
&#123;
    ll res &#x3D; 0;
    for(int i &#x3D; x;i ;i -&#x3D; lowbit(i))
    &#123;
        res +&#x3D; tr[i];
    &#125;
    return res;
&#125;</code></pre>

<p><mark>封装树状数组：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
struct Fenwick&#x2F;&#x2F;树状数组
&#123;
	const int n;
	vector&lt;T&gt; tr;
	Fenwick(int n):n(n),tr(n + 1)&#123;&#125;
	void init()&#123;    &#x2F;&#x2F;清空树状数组
        for(int i &#x3D; 0;i &lt;&#x3D; n;i++)	tr[i] &#x3D; 0;
    &#125;
	void add(int x,T c)&#123;
        for(int i &#x3D; x;i &lt;&#x3D; n;i +&#x3D; i &amp; -i)	tr[i] +&#x3D; c;
    &#125;
   	void add_range(int l,int r,T c)&#123;&#x2F;&#x2F;在区间[l,r]内加上数c
        add(l,c);
        add(r + 1,-c);
    &#125;
	T sum(int x)&#123;
        T res &#x3D; 0;	
        for(int i &#x3D; x;i ;i -&#x3D; i &amp; -i)	res +&#x3D; tr[i];	
        return res;
    &#125;
&#125;;</code></pre>

<p><mark>树状数组查询区间种类数模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

template &lt;typename T&gt;
struct Fenwick
&#123;
    const int n;
    vector&lt;T&gt; tr;
    Fenwick(int n):n(n),tr(n + 1)&#123;&#125;
    void init()&#123;&#x2F;&#x2F;清空树状数组
    for(int i &#x3D; 0;i &lt;&#x3D; n;i++)   tr[i] &#x3D; 0;
    &#125;
    void add(int x,T c)&#123;
        for(int i &#x3D; x;i &lt;&#x3D; n;i +&#x3D; i &amp; -i)   tr[i] +&#x3D; c;
    &#125;
    void add_range(int l,int r,T c)&#123;&#x2F;&#x2F;在区间[l,r]内加上数c
        add(l,c);
        add(r + 1,-c);
    &#125;
    T sum(int x)&#123;
        T res &#x3D; 0;
        for(int i &#x3D; x;i ;i -&#x3D; i &amp; -i)   res +&#x3D; tr[i];
        return res;
    &#125;
&#125;;

struct Q
&#123;
    int l, r, id;
&#125;;


int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
    
    int m;
    cin &gt;&gt; m;
    
    vector&lt;Q&gt; q(m + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
        q[i].id &#x3D; i;
    &#125;

    sort(q.begin() + 1, q.end(), [&amp;](Q a, Q b) -&gt; bool&#123;
        return a.r &lt; b.r;
    &#125;);

    Fenwick&lt;int&gt; fen(n + 1);

    vector&lt;int&gt; ans(m + 1);
    vector&lt;int&gt; st(1e6 + 1);
    for (int i &#x3D; 1, j &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        for (; j &lt;&#x3D; q[i].r; j++) 
        &#123;
            if (st[a[j]])   fen.add(st[a[j]], -1);
            fen.add(j, 1);
            st[a[j]] &#x3D; j;   
        &#125;
        ans[q[i].id] &#x3D; fen.sum(q[i].r) - fen.sum(q[i].l - 1);
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        cout &lt;&lt; ans[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>树状数组求逆序对的数量：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/243/">楼兰图腾</a></p>
<p><strong>树状数组查询区间种类数模板：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2494/">HH的项链</a></p>
<p><strong>2023CCPC桂林站铜牌题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/I">I. Barkley II</a></p>
<p><mark>2023CCPC桂林站铜牌题分析（有很重要的细节）：</mark></p>
<blockquote>
<p><strong>思路：</strong></p>
<p>1、枚举 $mex$ ，其余不含 $mex$ 的极长区间存下来，离线处理；</p>
<ul>
<li>这里时间复杂度不太好想，$mex$ 的种类多的话，极长区间小；$mex$ 的种类少的话，极长区间大；</li>
</ul>
<p>2、用莫队 &#x2F; 树状数组离线处理，个人感觉树状数组的时间复杂度比较优，推荐使用；</p>
<p>3、细节部分：题目说对于 $\sum{m}$ 没有限制，但是每个 $m$ 最多是 $5e5$，表面上看没什么问题，但如果用 $vector$ 动态去开空间的话，每次 $vector<int> 5e5$，一共 $t$ 次，我会在<strong>开空间的时候超时！</strong>因此可以使用 $map$，或者开全局数组，用到的时候清空数组再使用！</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

template &lt;typename T&gt;
struct Fenwick
&#123;
    const int n;
    vector&lt;T&gt; tr;
    Fenwick(int n):n(n),tr(n + 1)&#123;&#125;
    void init()&#123;&#x2F;&#x2F;清空树状数组
    for(int i &#x3D; 0;i &lt;&#x3D; n;i++)   tr[i] &#x3D; 0;
    &#125;
    void add(int x,T c)&#123;
        for(int i &#x3D; x;i &lt;&#x3D; n;i +&#x3D; i &amp; -i)   tr[i] +&#x3D; c;
    &#125;
    void add_range(int l,int r,T c)&#123;&#x2F;&#x2F;在区间[l,r]内加上数c
        add(l,c);
        add(r + 1,-c);
    &#125;
    T sum(int x)&#123;
        T res &#x3D; 0;
        for(int i &#x3D; x;i ;i -&#x3D; i &amp; -i)   res +&#x3D; tr[i];
        return res;
    &#125;
&#125;;

struct Q
&#123;
    int l, r, mex;
&#125;;


void solve()
&#123;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n + 1);
    map&lt;int, vector&lt;int&gt;&gt; mp;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        cin &gt;&gt; a[i];
        if (!mp[a[i]].size())   mp[a[i]].push_back(0);
        mp[a[i]].push_back(i);
    &#125;

    vector&lt;Q&gt; q;
    for (auto &amp;[x, v] : mp)
    &#123;  
        v.push_back(n + 1);
        for (int i &#x3D; 1; i &lt; v.size(); i++)
        &#123;
            &#x2F;&#x2F;mp[x][i - 1] + 1, mp[x][i] - 1
            int l &#x3D; mp[x][i - 1] + 1, r &#x3D; mp[x][i] - 1;
            if (l &gt; r)  continue;
            q.push_back(&#123;l ,r, x&#125;);
            &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;
    set&lt;int&gt; S;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        S.insert(a[i]);
    
    int mex &#x3D; 0;
    for (int i &#x3D; 1; i; i++)
        if (!S.count(i))
        &#123;
            mex &#x3D; i;
            break;
        &#125;
    q.push_back(&#123;1, n, mex&#125;);

    sort(q.begin(), q.end(), [&amp;](Q a, Q b) -&gt; bool&#123;
        return a.r &lt; b.r;
    &#125;);

    Fenwick&lt;int&gt; fen(n + 1);

    int res &#x3D; -1e9;
    map&lt;int, int&gt; st;
    for (int i &#x3D; 0, j &#x3D; 1; i &lt; q.size(); i++)
    &#123;
        for (; j &lt;&#x3D; q[i].r; j++) 
        &#123;
            if (st.count(a[j]))   fen.add(st[a[j]], -1);
            fen.add(j, 1);
            st[a[j]] &#x3D; j;
        &#125;
        res &#x3D; max(res, fen.sum(q[i].r) - fen.sum(q[i].l - 1) - q[i].mex);
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><strong>对于对模板题：<mark>区间加乘</mark>分析：</strong></p>
<ul>
<li><p>懒标记有两种更新方式，即先乘后加和先加后乘，其中<strong>先乘后加</strong>容易维护懒标记，而另一种不容易维护，故采用前者方式，即表示为：$sum × mul + add $，初始默认 $mul$ 为 $1$，$add$ 为 $0$。</p>
<ul>
<li>对于加法：$sum × mul + add + add’$，只需将 $add$ 更新为 $add + add’$ 即可，非常容易维护；</li>
<li>对于乘法：$(sum × mul + add) × mul’ &#x3D; sum × mul × mul’ + add × mul’$，即将 $mul$ 更新为 $mul × mul’$，将 $add$ 更新为 $add × mul’$即可，也非常好维护。</li>
</ul>
</li>
<li><p>因此 $pushdown$ 的具体如下：</p>
<ul>
<li>$sum &#x3D; sum × mul + add × len$，其中 $len$ 为该区间的长度；</li>
<li>更新 $mul$：$u.mul &#x3D; u.mul * mul$；</li>
<li>更新 $add$：由于先乘后加，因此 $u.add × mul + add$；</li>
</ul>
</li>
<li><p>由于既有加的修改，又有乘的修改，这里采用了一个小技巧，即合并这两个修改为一个 $modify$，对于 $sum &#x3D; sum × mul + add$：</p>
<ul>
<li>加法：$sum &#x3D; sum × 1 + add &#x3D; sum + add$；</li>
<li>乘法：$sum &#x3D; sum × mul + 0 &#x3D; sum × add$；</li>
</ul>
<p>因此，即把单独的加法与乘法综合为既有加法，又有乘法的修改：</p>
<ul>
<li>加法：$mul$ 为 $1$，add不变</li>
<li>乘法：mul不变，add为 $0$</li>
</ul>
</li>
<li><p>故综上所述，代码如下：</p>
</li>
</ul>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)

const int N &#x3D; 1e5 + 10;

int n,m,p;
int a[N];
struct Node
&#123;
    int l,r;
    ll sum;
    ll add,mul;
&#125;tr[N &lt;&lt; 2];

void pushup(int u)
&#123;
    tr[u].sum &#x3D; (tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum) % p;
&#125;

void eval(Node&amp; u,int add,int mul)
&#123;
    u.sum &#x3D; (((ll)u.sum * mul) % p + add * ((ll)u.r - u.l + 1) % p) % p;
    u.mul &#x3D; (ll)u.mul * mul % p;
    u.add &#x3D; ((ll)u.add * mul + add) % p;
&#125;

void pushdown(int u)
&#123;
    eval(tr[u &lt;&lt; 1],tr[u].add,tr[u].mul);
    eval(tr[u &lt;&lt; 1 | 1],tr[u].add,tr[u].mul);
    tr[u].add &#x3D; 0,tr[u].mul &#x3D; 1;
&#125;

void build(int u,int l,int r)
&#123;
    tr[u] &#x3D; &#123;l,r,0,0,1&#125;;
    if(l &#x3D;&#x3D; r)  tr[u].sum &#x3D; a[l];
    else
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;
&#125;

void modify(int u,int l,int r,int add,int mul)
&#123;
    if(tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)
    &#123;
        eval(tr[u],add,mul);
        return ;
    &#125;
    pushdown(u);
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;&#x3D; mid)    modify(u &lt;&lt; 1,l,r,add,mul);
    if(r &gt; mid) modify(u &lt;&lt; 1 | 1,l,r,add,mul);
    pushup(u);
&#125;

ll query(int u,int l,int r)
&#123;
    if(tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)
    &#123;
        return tr[u].sum;
    &#125;
    pushdown(u);
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    ll res &#x3D; 0;
    if(l &lt;&#x3D; mid)    res &#x3D; query(u &lt;&lt; 1,l,r);
    if(r &gt; mid) res &#x3D; (res + query(u &lt;&lt; 1 | 1,l,r)) % p;
    return res;
&#125;

int main()
&#123;
    IOS;
    cin &gt;&gt; n &gt;&gt; p;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i];

    build(1,1,n);

    cin &gt;&gt; m;
    while (m--)
    &#123;
        int op,l,r,c;
        cin &gt;&gt; op;
        if(op &#x3D;&#x3D; 1)
        &#123;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;
            modify(1,l,r,0,c);
        &#125;
        else if(op &#x3D;&#x3D; 2)
        &#123;
            cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;
            modify(1,l,r,c,1);
        &#125;
        else
        &#123;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; query(1,l,r) &lt;&lt; &quot;\n&quot;;
        &#125;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题（区间最大连续子段和 + 单点修改）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a></p>
<p><strong>模板题（区间加乘操作）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1279/">维护序列</a></p>
<p><strong>抽象出加乘公式：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57356/H">0 and 1 in BIT</a></p>
<p><strong>区间加乘 + 势能线段树：</strong><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7284">Easy problem I</a></p>
<p><strong>带懒标记的线段树：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1881/problem/G">G. Anya and the Mysterious String</a></p>
<p><strong>带两个懒标记的线段树 &#x2F; 用区间加乘模板思想（区间赋值、区间加减、求区间最值）：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1253">扶苏的问题</a></p>
<p><strong>洛谷题单：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/training/1124">Limit の线段树题单</a></p>
<h3 id="主席树（可持久化线段树）"><a href="#主席树（可持久化线段树）" class="headerlink" title="主席树（可持久化线段树）"></a>主席树（可持久化线段树）</h3><blockquote>
<p><strong>模板题题意：</strong>询问区间第 $k$ 小的数是多少？</p>
<p><strong>思路：</strong></p>
<ul>
<li>离散化</li>
<li>在数值上建立线段树，维护每个数值区间中一共有多少数。</li>
</ul>
<p><strong>具体计算：</strong></p>
</blockquote>
<blockquote>
<ul>
<li>对于区间 $[1, r]$ 内第 $k$ 小的数，先取 $mid$，如果 $[1,mid]$ 内有 $cnt &gt;&#x3D; k$ 个数，则递归到左半边，否则右半边。</li>
<li>如果对于区间 $[l, r]$ 内的第 $k$ 小数：首先对于区间 $[1,r]$，刚好加完前 $r$ 个版本的线段树是什么，即它的根节点是 $root[r]$。对于第 $R$ 个版本的线段树：其区间 $[l,r]$ 的数量为 $cnt_1$，而对于第 $L - 1$ 版本的线段树：其区间 $[l,r]$ 的数量为 $cnt_2$。那么 $cnt_1$ 表示：前 $R$ 个数中，值在区间 $[l,r]$ 内的个数，$cnt_2$ 表示：前 $l - 1$ 个数中，值在 $[l,r]$ 内的个数。因此：$cnt_1 - cnt_2$ 表示：在区间 $[L,R]$ 内值在区间 $[l,r]$ 的数的个数。</li>
</ul>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
<p><strong>空间复杂度：</strong>$O(4N + MlogN)$，其中 $M$ 是操作次数，即 $insert$ 次数！</p>
<p><strong>算法学习推荐：</strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/560085421">数据结构学习笔记(7) 主席树</a>	<strong>算法模板推荐：</strong>Acwing</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10,M &#x3D; 1e4 + 10;

int n,m;
int a[N];
vector&lt;int&gt; nums;
struct Node
&#123;
    int l,r;
    int cnt;
&#125;tr[N * 4 + N * 17];&#x2F;&#x2F;每次会修改log n 个区间，对线段树的操作是n次
int root[N],idx;

int find(int x)
&#123;
    return lower_bound(nums.begin(),nums.end(),x) - nums.begin();
&#125;

int build(int l,int r)
&#123;
    int p &#x3D; ++idx; 
    if(l &#x3D;&#x3D; r)  return p;
    int mid &#x3D; l + r &gt;&gt; 1;
    tr[p].l &#x3D; build(l,mid),tr[p].r &#x3D; build(mid + 1,r); &#x2F;&#x2F; l,r不是左右边界，而是左右儿子
    return p;
&#125;

int insert(int p,int l,int r,int x)
&#123;
    int q &#x3D; ++idx;
    tr[q] &#x3D; tr[p];
    if(l &#x3D;&#x3D; r)
    &#123;
        tr[q].cnt++;
        return q;
    &#125;
    int mid &#x3D; l + r &gt;&gt; 1;
    if(x &lt;&#x3D; mid)    tr[q].l &#x3D; insert(tr[p].l,l,mid,x);
    else    tr[q].r &#x3D; insert(tr[p].r,mid + 1,r,x);
    tr[q].cnt &#x3D; tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
&#125;

int query(int q,int p,int l,int r,int k)
&#123;
    if(l &#x3D;&#x3D; r)  return r;
    int cnt &#x3D; tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid &#x3D; l + r &gt;&gt; 1;
    if(k &lt;&#x3D; cnt)    return query(tr[q].l,tr[p].l,l,mid,k);
    else    return query(tr[q].r,tr[p].r,mid + 1,r,k - cnt);
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin  &gt;&gt; n &gt;&gt; m;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        cin &gt;&gt; a[i];
        nums.push_back(a[i]);
    &#125;

    sort(nums.begin(),nums.end());
    nums.erase(unique(nums.begin(),nums.end()),nums.end());

    root[0] &#x3D; build(0,nums.size() - 1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        root[i] &#x3D; insert(root[i - 1],0,nums.size() - 1,find(a[i]));

    while (m--)
    &#123;
        int l,r,k;
        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
        cout &lt;&lt; nums[query(root[r],root[l - 1],0,nums.size() - 1,k)] &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/257/">第K小数</a></p>
<p><strong>武汉大学2023年新生程序设计竞赛（同步赛）：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/66651/B">B 开组会</a></p>
<p><strong>与上面一样，应该是出自该 $cf$ 原题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/893/problem/F">F. Subtree Minimum Query</a></p>
<p><strong>$2023$ 年 $CCPC$ 网络赛：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104651/problem/L">L. Partially Free Meal</a></p>
<p><strong>$2024\ ICPC$ 湖北省赛金牌题（出题者初心：想放道数据结构在省赛中，于是主席树就来了qwq）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/105139/problem/F">F. Enchanted</a>，此外这题好像有一个数据结构典（中等数据结构的那种典）的表现。</p>
<ul>
<li>这题还没补，武汉邀请赛打铁了，感觉学这么多花里胡哨的算法没什么用了，这题补不起了，只能挂着了qwq。</li>
</ul>
<hr>
<p><mark>F. Subtree Minimum Query讲解：</mark></p>
<blockquote>
<p><strong>数组：</strong></p>
<ul>
<li>$root[i]$：插入了前 $i$ 个深度的点的线段树版本的根节点。</li>
</ul>
<p><strong>函数：</strong></p>
<ul>
<li><p>插入：$insert(新版本,前版本,起始序列编号,终止序列编号,指定序列,该序列对应的值)$</p>
</li>
<li><p>查询：$query(深度版本,起始序列编号,终止序列编号,顶点的起始dfs序,顶点的终止dfs序)$</p>
</li>
</ul>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10;

int n, rt;
int a[N];
int l[N], r[N], node_idx, idx;
int depth[N];
int root[N];
vector&lt;int&gt; adj[N];
vector&lt;int&gt; d[N];
struct Node
&#123;
	int l, r;
	int mn;
&#125;tr[N * 4 + N * 17];


void dfs(int u, int fa)
&#123;
	l[u] &#x3D; ++node_idx;
	depth[u] &#x3D; depth[fa] + 1;
	for (auto v : adj[u])
	&#123;
		if (v &#x3D;&#x3D; fa)	continue;
		dfs(v, u);
	&#125;
	r[u] &#x3D; node_idx;
&#125;

int build(int l, int r)
&#123;
	int p &#x3D; ++ idx;
	tr[p].mn &#x3D; 2e9;
	if (l &#x3D;&#x3D; r)	return p;
	int mid &#x3D; l + r &gt;&gt; 1;
	tr[p].l &#x3D; build(l, mid), tr[p].r &#x3D; build(mid + 1, r);
	return p;
&#125;

int insert(int q, int p, int l, int r, int pos, int x)
&#123;
	q &#x3D; ++ idx;
	tr[q] &#x3D; tr[p];
	tr[q].mn &#x3D; min(tr[q].mn, x);
	if (l &#x3D;&#x3D; r)	return q;

	int mid &#x3D; l + r &gt;&gt; 1;
	if (pos &lt;&#x3D; mid)	tr[q].l &#x3D; insert(tr[q].l, tr[p].l, l, mid, pos, x);
	else	tr[q].r &#x3D; insert(tr[q].r ,tr[p].r, mid + 1, r,pos, x);
	tr[q].mn &#x3D; min(tr[tr[q].l].mn, tr[tr[q].r].mn);
	return q;
&#125;

int query(int p, int l, int r, int ql, int qr)
&#123;
	if (ql &lt;&#x3D; l &amp;&amp; qr &gt;&#x3D; r)	return tr[p].mn;

	int res &#x3D; 2e9;
	int mid &#x3D; l + r &gt;&gt; 1;
	if (ql &lt;&#x3D; mid)	res &#x3D; min(res, query(tr[p].l, l, mid, ql, qr));
	if (qr &gt; mid)	res &#x3D; min(res, query(tr[p].r, mid + 1, r, ql, qr));
	return res;
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	cin &gt;&gt; n &gt;&gt; rt;

	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	cin &gt;&gt; a[i];

	for (int i &#x3D; 1; i &lt; n; i++)
	&#123;
		int a, b;
		cin &gt;&gt; a &gt;&gt; b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	&#125;

	dfs(rt, 0);

	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
		d[depth[i]].push_back(i);

	root[0] &#x3D; build(1, n);

	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		root[i] &#x3D; root[i - 1];
		for (auto x : d[i])
			root[i] &#x3D; insert(root[i], root[i], 1, n, l[x], a[x]);
	&#125;

	int q;
	cin &gt;&gt; q;

	int res &#x3D; 0;
	while (q--)
	&#123;
		int x, k;
		cin &gt;&gt; x &gt;&gt; k;

		x &#x3D; (x + res) % n + 1, k &#x3D; (k + res) % n;
		k &#x3D; min(depth[x] + k, n);

		res &#x3D; query(root[k], 1, n, l[x], r[x]);
		cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
	&#125;
	
	return 0;
&#125;</code></pre>

<p><mark>$2023$ 年 $CCPC$ 网络赛讲解：</mark></p>
<blockquote>
<p><strong>知识点：</strong>主席树 + 分治（决策单调性优化，<strong>推荐模板题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/868/problem/F">F. Yet Another Minimization Problem</a>）</p>
<p><strong>题解：</strong>首先考虑如何计算固定的 <em>k</em> 的答案。将所有盘子按照 <em>b</em> 从小到大排序，枚举第 <em>x</em> (<em>k</em> <em>≤</em> <em>x</em> <em>≤</em></p>
<p><em>n</em>) 个盘子作为选中的 <em>b</em> 最大的盘子，那么剩下的 <em>k</em> <em>−</em> 1 个盘子显然是贪心选择前 <em>x</em> <em>−</em> 1 个盘子</p>
<p>中 <em>a</em> 最小的 <em>k</em> <em>−</em> 1 个。给定 <em>k</em> 和 <em>x</em>，可以通过可持久线段树在 <em>O</em>(log <em>n</em>) 的时间内求出对应方案</p>
<p>的值 <em>w</em>(<em>k, x</em>)。</p>
<p>令 <em>f</em>(<em>k</em>) 表示使 <em>k</em> 取到最优解的 <em>x</em>。对于两个不同的决策 <em>x, y</em> (<em>x &lt; y</em>)，若 <em>w</em>(<em>k, x</em>) <em>≥</em> <em>w</em>(<em>k, y</em>)，</p>
<p>那么增大 <em>k</em> 之后由于 <em>y</em> 的可选择范围严格包含了 <em>x</em> 的可选择范围，因此 <em>y</em> 新选的 <em>a</em> 值一定不</p>
<p>大于 <em>x</em> 所选的，即 <em>w</em>(<em>k</em> <em>′</em> <em>, x</em>) <em>≥</em> <em>w</em>(<em>k</em> <em>′</em> <em>, y</em>) 对于 <em>k</em> <em>≤</em> <em>k</em> <em>′</em> <em>≤</em> <em>n</em> 恒成立。由此可得 <em>f</em>(1) <em>≤</em> <em>f</em>(2) <em>≤</em> <em>f</em>(3) <em>≤</em></p>
<p><em>· · · ≤</em> <em>f</em>(<em>n</em>)，最优决策具有单调性，可以分治求解，共需计算 </p>
<p><em>O</em>(<em>n</em> log <em>n</em>) 个 <em>w</em>(<em>k, x</em>) 的值。</p>
<p><strong>时间复杂度：</strong> $O(n log_2 n)$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 2e5 + 10;
int n, m;
pii v[N];
int root[N], idx;
vector&lt;int&gt; nums; 

struct Node
&#123;
    int l, r;
    ll cnt, sum;
&#125;tr[N * 4 + N * 18];

int build(int l, int r)
&#123;
    int p &#x3D; ++ idx;
    if (l &#x3D;&#x3D; r) return p;
    int mid &#x3D; l + r &gt;&gt; 1;
    tr[p].l &#x3D; build(l, mid), tr[p].r &#x3D; build(mid + 1, r);
    return p;
&#125;

int insert(int q, int p, int l, int r, int x)
&#123;
    q &#x3D; ++ idx;
    tr[q] &#x3D; tr[p];
    if (l &#x3D;&#x3D; r)
    &#123;
        tr[q].cnt ++;
        tr[q].sum +&#x3D; nums[x];
        return q;
    &#125;
    int mid &#x3D; l + r &gt;&gt; 1;
    if (x &lt;&#x3D; mid)   tr[q].l &#x3D; insert(tr[q].l, tr[p].l, l, mid, x);
    else    tr[q].r &#x3D; insert(tr[q].r, tr[p].r, mid + 1, r, x);
    tr[q].sum &#x3D; tr[tr[q].l].sum + tr[tr[q].r].sum;
    tr[q].cnt &#x3D; tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
&#125;

ll query(int q, int l, int r, int k)
&#123;
    if (l &#x3D;&#x3D; r) return (ll)k * nums[l];
    int mid &#x3D; l + r &gt;&gt; 1;
    int cnt &#x3D; tr[tr[q].l].cnt;
    if (k &lt;&#x3D; cnt)   return query(tr[q].l, l, mid, k);
    else    return tr[tr[q].l].sum + query(tr[q].r, mid + 1, r, k - cnt);
&#125;

ll f[N];

void solve(int l, int r, int ql, int qr)
&#123;
    if (l &gt; r)  return;
    int mid &#x3D; l + r &gt;&gt; 1, qm;
    ll mn &#x3D; 2e18;
    for (int i &#x3D; max(ql, mid); i &lt;&#x3D; qr; i++)
    &#123;
        ll t &#x3D; query(root[i], 0, m, mid) + v[i].second;
        if (t &lt; mn)
        &#123;
            mn &#x3D; t;
            qm &#x3D; i;
        &#125;
    &#125;
    f[mid] &#x3D; mn;
    solve(l, mid - 1, ql, qm);
    solve(mid + 1, r, qm, qr);
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        cin &gt;&gt; v[i].first &gt;&gt; v[i].second;
        nums.push_back(v[i].first);
    &#125;

    sort(v + 1, v + n + 1, [&amp;](pii a, pii b) -&gt; bool&#123;
        return a.second &lt; b.second;
    &#125;);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    m &#x3D; nums.size() - 1;
    root[0] &#x3D; build(0, m);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        v[i].first &#x3D; lower_bound(nums.begin(), nums.end(), v[i].first) - nums.begin();
    &#125;

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        root[i] &#x3D; insert(root[i], root[i - 1], 0, m, v[i].first);
    &#125;
    
    solve(1, n, 1, n);

    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        cout &lt;&lt; f[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<h3 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h3><p><mark>推荐题单：</mark></p>
<h3 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h3><p><mark>模板题1（逆序对）代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 5e5 + 10;

int n,idx,root;
int a[N];
struct Node
&#123;
    int l,r;
    int cnt;
&#125;tr[N * 24];

void modify(int &amp;u,int l,int r,int pos)
&#123;
    if(!u)  u &#x3D; ++idx;
    tr[u].cnt++;
    if(l &#x3D;&#x3D; r)  return;
    int mid &#x3D; l + r &gt;&gt; 1;
    if(pos &lt;&#x3D; mid)  modify(tr[u].l,l,mid,pos);
    else    modify(tr[u].r,mid + 1,r,pos);
&#125;

int query(int u,int l,int r,int ql,int qr)
&#123;
    if(!u)  return 0;
    if(ql &lt;&#x3D; l &amp;&amp; qr &gt;&#x3D; r)  return tr[u].cnt;
    int mid &#x3D; l + r &gt;&gt; 1;
    int res &#x3D; 0;
    if(ql &lt;&#x3D; mid)  res +&#x3D; query(tr[u].l,l,mid,ql,qr);
    if(qr &gt; mid)    res +&#x3D; query(tr[u].r,mid + 1,r,ql,qr);
    return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n;

    ll res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   
    &#123;
        cin &gt;&gt; a[i];
        modify(root,0,1e9,a[i]);
        res +&#x3D; query(root,0,1e9,a[i] + 1,1e9);
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><strong>模板题2思路：</strong></p>
<p><strong>题意：</strong>	给定 $n$ 个数，问有多少个不同的连续区间，满足其区间和在 $[L,R]$ 范围内？</p>
<p><strong>思路：</strong>	$L \le sum[r] - sum[l - 1] \le R$，即 $sum[r] - R \le sum[l - 1] \le sum[r] - L$。即每插入一个数（假设下标为 $pos$），则询问前面 $[0,pos - 1]$ 内，有多少数在 $[sum[pos] - R,sum[pos] - L]$ 内。</p>
<p><mark>模板题2代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5 + 10;
int n,idx,L,R,root;
int a[N];
ll sum[N];
ll lc &#x3D; -1e10,rc &#x3D; 1e10;
struct Node
&#123;
    int l,r;
    int cnt;
&#125;tr[N * 21];

void modify(int &amp;u,ll l,ll r,ll pos)
&#123;
    if(!u)  u &#x3D; ++idx;
    tr[u].cnt ++;
    if(l &#x3D;&#x3D; r)  return;
    ll mid &#x3D; l + r &gt;&gt; 1;
    if(pos &lt;&#x3D; mid)  modify(tr[u].l,l,mid,pos);
    else    modify(tr[u].r,mid + 1,r,pos);
&#125;

int query(int u,ll l,ll r,ll ql,ll qr)
&#123;
    if(!u)  return 0;
    if(ql &lt;&#x3D; l &amp;&amp; qr &gt;&#x3D; r)  return tr[u].cnt;
    ll mid &#x3D; l + r &gt;&gt; 1;
    int res &#x3D; 0;
    if(ql &lt;&#x3D; mid)   res +&#x3D; query(tr[u].l,l,mid,ql,qr);
    if(qr &gt; mid)    res +&#x3D; query(tr[u].r,mid + 1,r,ql,qr);
    return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i],sum[i] &#x3D; sum[i - 1] + a[i];

    modify(root,lc,rc,0);

    ll res &#x3D; 0;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        res +&#x3D; query(root,lc,rc,sum[i] - R,sum[i] - L);
        modify(root,lc,rc,sum[i]);
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题1：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1908">逆序对</a></p>
<p><strong>模板题2：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5459">回转寿司</a></p>
<h3 id="势能线段树"><a href="#势能线段树" class="headerlink" title="势能线段树"></a>势能线段树</h3><p><strong>问题引入：</strong></p>
<p>​	1、给定一个区间[l,r]，将其中每个数开根号并向下取整。</p>
<p>​	2、查询区间和。</p>
<p><mark>思路：</mark></p>
<p>​	可以发现，对于一个数1e9，每次将其开根号，可以依次得到：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">1000000000
31622
177
13
3
1</code></pre>

<p>​	所以每个数最多开5次根号即可变成1，因此我们需要维护一个区间最大值，当最大值为1时，之后就不再进行修改了。所以可以在modify递归的时候去”暴力“进行计算取根号，递归到叶子节点后修改下数值，一但一段区间的最大值为1，就不用再递归修改了。</p>
<blockquote>
<p>因为区间中每个数字都是不相同的，就算知道了区间和sum，也不知道开方后的区间和sum，所以区间开方不支持使用lazy的本质在于，无法使用懒标记快速更新整段区间信息。</p>
</blockquote>
<p><mark>模板题1代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 2e5 + 10;

int n,m;
int a[N];

struct Node
&#123;
    int l,r;
    ll sum;
    int mx;&#x2F;&#x2F;mx:区间最大值
&#125;tr[N &lt;&lt; 2];

void pushup(int u)
&#123;
    tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    tr[u].mx &#x3D; max(tr[u  &lt;&lt; 1].mx,tr[u &lt;&lt; 1 | 1].mx);
&#125;

void build(int u,int l,int r)
&#123;
    tr[u] &#x3D; &#123;l,r&#125;;
    if(l &#x3D;&#x3D; r)  tr[u].sum &#x3D; tr[u].mx &#x3D; a[l];
    else
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;
&#125;

void modify(int u,int l,int r)
&#123;
    if(tr[u].mx &#x3D;&#x3D; 1)   return;
    if(tr[u].l &#x3D;&#x3D; tr[u].r)  tr[u].sum &#x3D; tr[u].mx &#x3D; sqrt(tr[u].sum);
    else
    &#123;
        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
        if(l &lt;&#x3D; mid)    modify(u &lt;&lt; 1,l,r);
        if(r &gt; mid) modify(u &lt;&lt; 1 | 1,l,r);
        pushup(u);
    &#125;
&#125;

ll query(int u,int l,int r)
&#123;
    if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return tr[u].sum;
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    ll res &#x3D; 0;
    if(l &lt;&#x3D; mid)    res +&#x3D; query(u &lt;&lt; 1,l,r);
    if(r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1,l,r);
    return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; m;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i];
    build(1,1,n);

    while (m--)
    &#123;
        int op,l,r;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
        if(op &#x3D;&#x3D; 1) modify(1,l,r);
        else    cout &lt;&lt; query(1,l,r) &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>模板题2代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt; 

using namespace std;

typedef long long ll;

const int N &#x3D; 2e5 + 10;

int n,m;
int a[N];

struct Node
&#123;
    int l,r;
    ll mx,mi;&#x2F;&#x2F;区间最大、最小值
    ll sum,lazy;&#x2F;&#x2F;懒标记:区间加
&#125;tr[N &lt;&lt; 2];

void pushup(int u)
&#123;
    tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    tr[u].mx &#x3D; max(tr[u &lt;&lt; 1].mx,tr[u &lt;&lt; 1 | 1].mx);
    tr[u].mi &#x3D; min(tr[u &lt;&lt; 1].mi,tr[u &lt;&lt; 1 | 1].mi);
&#125;

void eval(int u,ll add)
&#123;
    tr[u].lazy +&#x3D; add;
    tr[u].mi +&#x3D; add,tr[u].mx +&#x3D; add;
    tr[u].sum +&#x3D; (tr[u].r - tr[u].l + 1) * add;
&#125;

void pushdown(int u)
&#123;
    if(tr[u].lazy)
    &#123;
        eval(u &lt;&lt; 1,tr[u].lazy);
        eval(u &lt;&lt; 1 | 1,tr[u].lazy);
        tr[u].lazy &#x3D; 0;
    &#125;
&#125;

void build(int u,int l,int r)
&#123;
    tr[u] &#x3D; &#123;l,r&#125;;
    if(l &#x3D;&#x3D; r)      tr[u].sum &#x3D; tr[u].mi &#x3D; tr[u].mx &#x3D; a[l];
    else
    &#123;
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid),build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;
&#125;

void modify_sqrt(int u,int l,int r)
&#123;
    if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)
    &#123;&#x2F;&#x2F;好秀的diff啊(sqrt需强转)
        int diff1 &#x3D; tr[u].mx - (ll)sqrt(tr[u].mx);
        int diff2 &#x3D; tr[u].mi - (ll)sqrt(tr[u].mi);
        if (diff1 &#x3D;&#x3D; diff2) return eval(u, -diff1);
    &#125;
    pushdown(u);
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;&#x3D; mid)    modify_sqrt(u &lt;&lt; 1,l,r);
    if(r &gt; mid) modify_sqrt(u &lt;&lt; 1 | 1,l,r);
    pushup(u);
&#125;

void modify_add(int u,int l,int r,int delta)
&#123;
    if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return eval(u,delta);
    pushdown(u);
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;&#x3D; mid)    modify_add(u &lt;&lt; 1,l,r,delta);
    if(r &gt; mid) modify_add(u &lt;&lt; 1 | 1,l,r,delta);
    pushup(u);
&#125;

ll query(int u,int l,int r)
&#123;
    if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return tr[u].sum;
    pushdown(u);
    ll res &#x3D; 0;
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if(l &lt;&#x3D; mid)    res +&#x3D; query(u &lt;&lt; 1,l,r);
    if(r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1,l,r);
    return res;
&#125;

int main()
&#123;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   scanf(&quot;%d&quot;,a + i);

    build(1,1,n);

    while (m--)
    &#123;
        int op,l,r,add;
        scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r);
        if(op &#x3D;&#x3D; 1) modify_sqrt(1,l,r);
        else if(op &#x3D;&#x3D; 2)
        &#123;
            scanf(&quot;%d&quot;,&amp;add);
            modify_add(1,l,r,add);
        &#125;
        else    printf(&quot;%lld\n&quot;,query(1,l,r));
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题1：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/19917/D">势能线段树模板题一</a></p>
<p><strong>模板题2：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/19917/C">势能线段树模板题二</a></p>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7284">Easy problem I</a></p>
<h3 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h3><h3 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h3><p><img src="/images/16.png"></p>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;functional&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;ll,int&gt; pli;

const int N &#x3D; 100010, M &#x3D; 17 * N + N * 4 * 4 + 2 * N, P &#x3D; 400000;
const ll INF &#x3D; 1e18;

struct Node &#123;
    int l, r;
&#125;tr[N &lt;&lt; 3]; &#x2F;&#x2F; 两棵树一起开 同一个真实结点在两棵树里面的叶子结点编号差值相同 用偏移量
int e[M], ne[M], h[N &lt;&lt; 3], idx;
int w[M]; 
int mp[N]; &#x2F;&#x2F; 真实结点编号到线段树结点编号的映射
int n, m, S;
ll dis[N &lt;&lt; 3];
bool st[N &lt;&lt; 3];

void insert(int u, int v, int d) &#123;
    e[idx] &#x3D; v, ne[idx] &#x3D; h[u], w[idx] &#x3D; d, h[u] &#x3D; idx++;
&#125;

void build(int u, int l, int r) &#123;
    tr[u] &#x3D; &#123;l, r&#125;;
    if (l &#x3D;&#x3D; r) return void(mp[l] &#x3D; u);
    int mid &#x3D; l + r &gt;&gt; 1;
    insert(u, u &lt;&lt; 1, 0), insert(u, u &lt;&lt; 1 | 1, 0); &#x2F;&#x2F; 出树往子节点连
    insert((u &lt;&lt; 1) + P, u + P, 0), insert((u &lt;&lt; 1 | 1) + P, u + P, 0); &#x2F;&#x2F; 入树往父节点连
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
&#125;

void modify(int u, int l, int r, int v, int w, int op) &#123;
    if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) &#123; &#x2F;&#x2F; 连边区间完全包含结点区间
        if (op &#x3D;&#x3D; 2) insert(v + P, u, w); &#x2F;&#x2F; 入树叶子结点连出树区间结点
        if (op &#x3D;&#x3D; 3) insert(u + P, v, w); &#x2F;&#x2F; 入树区间结点连出树叶子结点
        return;
    &#125;
    int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
    if (l &lt;&#x3D; mid) modify(u &lt;&lt; 1, l, r, v, w, op);
    if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v, w, op);
&#125;

int main() &#123;
    cin.tie(0), cout.tie(0)-&gt;sync_with_stdio(false);
    
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S;
    
    memset(h, -1, sizeof h);
    build(1, 1, n);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        insert(mp[i], mp[i] + P, 0);
        insert(mp[i] + P, mp[i], 0); &#x2F;&#x2F; 入树出树叶子结点互连
    &#125;
    
    while (m--) &#123;
        int op, u, v, l, r, w;
        cin &gt;&gt; op;
        if (op &#x3D;&#x3D; 1) cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, insert(mp[u] + P, mp[v], w); &#x2F;&#x2F; 单点连单点直接连
        else cin &gt;&gt; v &gt;&gt; l &gt;&gt; r &gt;&gt; w, modify(1, l, r, mp[v], w, op);
    &#125;
    
    function&lt;void(int)&gt; dijkstra &#x3D; [&amp;](int S) &#123;
        memset(dis, 0x3f, sizeof dis);
        priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt;&gt; heap;
        dis[S] &#x3D; 0;
        heap.push(&#123;0, S&#125;);
        while (heap.size()) &#123;
            auto tt &#x3D; heap.top();
            heap.pop();
            int t &#x3D; tt.second;
            if (st[t]) continue;
            st[t] &#x3D; true;
            for (int i &#x3D; h[t]; ~i; i &#x3D; ne[i]) &#123;
                int j &#x3D; e[i];
                if (dis[j] &gt; dis[t] + w[i]) &#123;
                    dis[j] &#x3D; dis[t] + w[i];
                    heap.push(&#123;dis[j], j&#125;);
                &#125;
            &#125;
        &#125;
    &#125;;

    dijkstra(mp[S] + P);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
        if (dis[mp[i]] &gt; INF &#x2F; 2) cout &lt;&lt; &quot;-1 &quot;;
        else cout &lt;&lt; dis[mp[i]] &lt;&lt; &#39; &#39;;
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF786B">Legacy</a></p>
<h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(22));
vector&lt;int&gt; LG2(n + 1);
auto _init &#x3D; [&amp;]() -&gt; void
&#123;
    LG2[1] &#x3D; 0;
    for(int i &#x3D; 2;i &lt;&#x3D; n;i++)   LG2[i]  &#x3D;LG2[i &gt;&gt; 1] + 1;

    for(int j &#x3D; 0;j &lt;&#x3D; LG2[n];j++)
        for(int i &#x3D; 1;i + (1 &lt;&lt; j) - 1 &lt;&#x3D; n;i++)
            if(!j)  f[i][j] &#x3D; a[i];
            else    f[i][j] &#x3D; max(f[i][j - 1],f[i + (1 &lt;&lt; j - 1)][j - 1]);  
    return ;
&#125;;
auto query &#x3D; [&amp;](int l, int r) -&gt; int
&#123;
    int k &#x3D; LG2[r - l + 1];
    return max(f[l][k],f[r - (1 &lt;&lt; k) + 1][k]);
&#125;;</code></pre>



<blockquote>
<p><strong>RMQ</strong>（Range Maximum&#x2F;Minimum Query）问题，即区间最值查询问题，是指对于长度为 n 的数组a，查询数组a中下标在 [ i , j ] 里的最大值或最小值。</p>
<p>ST算法是一个非常有名的在线处理RMQ问题的算法，它在 O ( n log ⁡ n ) 时间内进行预处理，然后可以在 O ( 1 )  时间内回答每个查询，其本质是倍增与动态规划的思想。要注意的是：ST算法只适用于静态区间求最值。</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

const int N &#x3D; 2e5 + 10,M &#x3D; 18;

int n,m;
int a[N];
int f[N][M];&#x2F;&#x2F;f[i][j]:从i开始,长度是2^j的区间中,最大值是多少?
int LG2[N];

void init()
&#123;
    LG2[1] &#x3D; 0;
    for(int i &#x3D; 2;i &lt;&#x3D; n;i++)   LG2[i]  &#x3D;LG2[i &gt;&gt; 1] + 1;

    for(int j &#x3D; 0;j &lt;&#x3D; LG2[n];j++)&#x2F;&#x2F;类似区间DP，循环长度
        for(int i &#x3D; 1;i + (1 &lt;&lt; j) - 1 &lt;&#x3D; n;i++)&#x2F;&#x2F;因为集合含义是从i开始,长度为2^j的区间的最大值,右边界是i + 2^j - 1
            if(!j)  f[i][j] &#x3D; a[i];
            else    f[i][j] &#x3D; max(f[i][j - 1],f[i + (1 &lt;&lt; j - 1)][j - 1]);  
    return ;
&#125;&#x2F;&#x2F;f[i][j] &#x3D; max(f[i][j - 1],f[i + 2^(j - 1)][j - 1]);

int query(int l,int r)
&#123;
    int k &#x3D; LG2[r - l + 1];
    return max(f[l][k],f[r - (1 &lt;&lt; k) + 1][k]);
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i];

    init();

    cin &gt;&gt; m;
    while(m--)
    &#123;
        int l,r;
        cin &gt;&gt; l &gt;&gt; r;
        cout &lt;&lt; query(l,r) &lt;&lt; &quot;\n&quot;;
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1275/">天才的记忆</a></p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><blockquote>
<p>问题引入：给点长度为 $n$ 的数组，询问 $m$ 次区间内有多少个数满足 $cnt[x] &#x3D; x$？</p>
<p>处理方法：莫队离线做法。</p>
<p><strong>时间复杂度：</strong>$O(n\sqrt{n})$</p>
<p><mark>时间复杂度证明：</mark></p>
<p>首先，双关键字排序是按照：先按照所在块从小到大排序，然后按照右端点从小到大排序。</p>
<p>假设一个块的大小为： $\sqrt n$ ，下面讨论左右指针移动次数：</p>
<ul>
<li>右指针（$r$）：在一个块内，右指针是单调递增的，最多移动 $n$ 次，一共有 $\sqrt n$ 块，故时间复杂度：$O(n\sqrt n)$；</li>
<li>左指针（$l$）：</li>
<li>块内：一次操作最多会移动 $\sqrt n$ 次，一共 $m$ 次操作，故时间复杂度：$O(m\sqrt n)$；</li>
<li>块间：一次块间移动最多会移动 $2\sqrt n$ 次，最多块间移动 $\sqrt n - 1$ 次，故时间复杂度：$O(2n)$；</li>
</ul>
<p>为了最优化来确定块的大小，不妨设块的大小为 $len$，则有：</p>
<ul>
<li>右指针（$r$）：一个块内，最多移动 $n$ 次，一共有 $\frac{n}{len}$ 块，故共有：$\frac{n^2}{len}$；</li>
<li>左指针（$l$）：只讨论块内，一次操作最多移动 $len$ 次，共 $m$ 次操作，故共有：$m\times len$；</li>
</ul>
<p>根据数学不等式，取等时有最小值：$\frac{n^2}{len} &#x3D; m\times len$，解得：$len &#x3D; \sqrt \frac{n^2}{m}$</p>
</blockquote>
<p><mark>模板题2代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    int block &#x3D; max(1, int(sqrt(n)));

    vector&lt;array&lt;int, 3&gt;&gt; que(m);
    for (int i &#x3D; 0; i &lt; m; i++)
    &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        que[i] &#x3D; &#123;l, r, i&#125;;
    &#125;

    sort(que.begin(), que.end(), [&amp;](array&lt;int, 3&gt; a, array&lt;int, 3&gt; b) -&gt; bool&#123;
        int al &#x3D; a[0] &#x2F; block, bl &#x3D; b[0] &#x2F; block;
        if (al !&#x3D; bl)   return al &lt; bl;
        if (al &amp; 1) return a[1] &lt; b[1]; &#x2F;&#x2F; 奇偶优化
        return a[1] &gt; b[1];
    &#125;);

    vector&lt;int&gt; ans(m + 1);

    int res &#x3D; 0;
    vector&lt;int&gt; cnt(1e5 + 2);
    auto add &#x3D; [&amp;](int x) -&gt; void
    &#123;
        x &#x3D; a[x];
        if (x &gt; 1e5)    return;
        if (cnt[x] &#x3D;&#x3D; x) 
        &#123;
            res--;
            cnt[x]++;
        &#125;
        else
        &#123;
            cnt[x]++;
            if (x &#x3D;&#x3D; cnt[x]) res++;
        &#125;
    &#125;;

    auto del &#x3D; [&amp;](int x) -&gt; void
    &#123;
        x &#x3D; a[x];
        if (x &gt; 1e5)    return;
        if (cnt[x] &#x3D;&#x3D; x) 
        &#123;
            res--;
            cnt[x]--;
        &#125;
        else
        &#123;
            cnt[x]--;
            if (cnt[x] &#x3D;&#x3D; x) res++;
        &#125;
    &#125;;

    for (int k &#x3D; 0, l &#x3D; 1, r &#x3D; 0; k &lt; m; k++)
    &#123;
        auto [ql, qr, id] &#x3D; que[k];
        while (l &gt; ql)  add(--l);
        while (r &lt; qr)  add(++r);
        while (l &lt; ql)  del(l++);
        while (r &gt; qr)  del(r--);
        ans[id] &#x3D; res;
    &#125;
    
    for (int i &#x3D; 0; i &lt; m; i++)    cout &lt;&lt; ans[i] &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>模板题1：HH的项链</mark></p>
<blockquote>
<p><strong>题意：</strong>给定长度为 $n$ 的数组，$q$ 次询问，问区间 $[l, r]$ 内不同数的个数？</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 50010,M &#x3D; 200010,S &#x3D; 1000010;
int n,m,len;
int w[N],ans[M];
struct Query
&#123;
    int id,l,r;
&#125;q[M];
int cnt[S];

int get(int x)
&#123;
    return x &#x2F; len;
&#125;

bool cmp(const Query&amp; a,const Query&amp; b)
&#123;
    int i &#x3D; get(a.l),j &#x3D; get(b.l);
    if(i !&#x3D; j)  return i &lt; j;
    return a.r &lt; b.r;
&#125;

void add(int x,int&amp; res)
&#123;
    if(!cnt[x]) res++;
    cnt[x]++;
&#125;

void del(int x,int&amp; res)
&#123;
    cnt[x]--;
    if(!cnt[x]) res--;
&#125;

int main()
&#123;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   scanf(&quot;%d&quot;,&amp;w[i]);
    scanf(&quot;%d&quot;,&amp;m);
    len &#x3D; max(1,(int)sqrt((double) n * n &#x2F; m));

    for(int i &#x3D; 0;i &lt; m;i++)
    &#123;
        int l,r;
        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);
        q[i] &#x3D; &#123;i,l,r&#125;;
    &#125;
    sort(q,q + m,cmp);

    for(int k &#x3D; 0,i &#x3D; 0,j &#x3D; 1,res &#x3D; 0;k &lt; m;k++)
    &#123;
        int id &#x3D; q[k].id,l &#x3D; q[k].l,r &#x3D; q[k].r;
        while(i &lt; r)    add(w[++i],res);
        while(i &gt; r)    del(w[i--],res);
        while(j &lt; l)    del(w[j++],res);
        while(j &gt; l)    add(w[--j],res);
        ans[id] &#x3D; res;
    &#125;

    for(int i &#x3D; 0;i &lt; m;i++)    printf(&quot;%d\n&quot;,ans[i]);
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2494/">HH的项链</a>     <a target="_blank" rel="noopener" href="https://codeforces.com/contest/220/problem/B">B. Little Elephant and Array</a></p>
<h3 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h3><p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2523/">数颜色</a></p>
<h3 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h3><p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2536/">树上计数2</a></p>
<p><strong>$2023\ A$ 组蓝桥杯省赛（启发式合并（主要），树上莫队也可做）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/5001/">颜色平衡树</a></p>
<h3 id="二次离线莫队"><a href="#二次离线莫队" class="headerlink" title="二次离线莫队"></a>二次离线莫队</h3><p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2537/">二次离线莫队</a></p>
<h2 id="珂朵莉树"><a href="#珂朵莉树" class="headerlink" title="珂朵莉树"></a>珂朵莉树</h2><p><strong>珂朵莉树</strong>（Chtholly Tree）起源于<a target="_blank" rel="noopener" href="https://codeforces.com/contest/896/problem/C">CF896C</a>，那道题要求我们实现一种数据结构，可以较快地实现：</p>
<ul>
<li><p>区间加</p>
</li>
<li><p>区间赋值</p>
</li>
<li><p>求区间第k大值</p>
</li>
<li><p>求区间n次方和</p>
<p><img src="/images/9.webp"></p>
</li>
</ul>
<p><mark>模板题：</mark></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/896/problem/C">C. Willem, Chtholly and Seniorious</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF915E">Physical Education Lessons</a></p>
<p><mark>应用：</mark></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1638/problem/E">E. Colorful Operations</a></p>
<p><mark>封装珂朵莉树：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
struct ODT&#x2F;&#x2F;珂朵莉树
&#123;
    struct Node
    &#123;
        int l,r;
        mutable T v;
        Node(int _l,int _r &#x3D; -1,T _v &#x3D; 0):l(_l),r(_r),v(_v)&#123;&#125;
        bool operator&lt;(const Node&amp;o) const &#123;return l &lt; o.l;&#125;
    &#125;;
    set&lt;Node&gt; S;
    void insert(int l,int r,T v)&#123;&#x2F;&#x2F;往set中插入结点
        S.insert(Node(l,r,v));
    &#125;
    auto split(int pos)&#123;&#x2F;&#x2F;断开区间
        auto it &#x3D; S.lower_bound(Node(pos));
        if(it !&#x3D; S.end() &amp;&amp; it-&gt;l &#x3D;&#x3D; pos)   return it;
        --it;
        int l &#x3D; it-&gt;l,r &#x3D; it-&gt;r;
        T v &#x3D; it-&gt;v;
        S.erase(it);
        S.insert(Node(l,pos - 1,v));
        return S.insert(Node(pos,r,v)).first;
    &#125;
    void add(int l,int r,T v)&#123;  &#x2F;&#x2F;区间加
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)
            it-&gt;v +&#x3D; v;
    &#125;
    void assign(int l,int r,T v)&#123;   &#x2F;&#x2F;区间赋值
        auto end &#x3D; split(r + 1),begin &#x3D; split(l);
        S.erase(begin,end);
        S.insert(Node(l,r,v));
    &#125;
    T get_k(int l,int r,int k)&#123; &#x2F;&#x2F;区间第k大的数
        vector&lt;pair&lt;T,int&gt;&gt; v;
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)&#123;
            v.push_back(&#123;it-&gt;v,it-&gt;r - it-&gt;l + 1&#125;);
        &#125;
        sort(v.begin(),v.end());
        for(auto x : v)&#123;
            k -&#x3D; x.second;
            if(k &lt;&#x3D; 0)  return x.first;
        &#125;
        return -1;
    &#125;
    T sum_pow(int l,int r,int k,int p)&#123; &#x2F;&#x2F;区间[l,r]的k次幂之和
        ll res &#x3D; 0;
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)&#123;
            res &#x3D; (res + 1ll * (it-&gt;r - it-&gt;l + 1) * fpow(it-&gt;v,k,p) % p) % p;
        &#125;
        return res;
    &#125;
&#125;;</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5 + 10,mod &#x3D; 1e9 + 7;
int n,m,seed,vmax;
int a[N];

ll fpow(ll a,ll b,ll p)
&#123;
    a %&#x3D; p;
    ll res &#x3D; 1;
    while (b)
    &#123;
        if(b &amp; 1)   res &#x3D; res * a % p;
        a &#x3D; a * a % p;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

template&lt;typename T&gt;
struct ODT&#x2F;&#x2F;珂朵莉树
&#123;
    struct Node
    &#123;
        int l,r;
        mutable T v;
        Node(int _l,int _r &#x3D; -1,T _v &#x3D; 0):l(_l),r(_r),v(_v)&#123;&#125;
        bool operator&lt;(const Node&amp;o) const &#123;return l &lt; o.l;&#125;
    &#125;;
    set&lt;Node&gt; S;
    void insert(int l,int r,T v)&#123;&#x2F;&#x2F;往set中插入结点
        S.insert(Node(l,r,v));
    &#125;
    auto split(int pos)&#123;&#x2F;&#x2F;断开区间
        auto it &#x3D; S.lower_bound(Node(pos));
        if(it !&#x3D; S.end() &amp;&amp; it-&gt;l &#x3D;&#x3D; pos)   return it;
        --it;
        int l &#x3D; it-&gt;l,r &#x3D; it-&gt;r;
        ll v &#x3D; it-&gt;v;
        S.erase(it);
        S.insert(Node(l,pos - 1,v));
        return S.insert(Node(pos,r,v)).first;
    &#125;
    void add(int l,int r,T v)&#123;  &#x2F;&#x2F;区间加
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)
            it-&gt;v +&#x3D; v;
    &#125;
    void assign(int l,int r,T v)&#123;   &#x2F;&#x2F;区间赋值
        auto end &#x3D; split(r + 1),begin &#x3D; split(l);
        S.erase(begin,end);
        S.insert(Node(l,r,v));
    &#125;
    T get_k(int l,int r,int k)&#123; &#x2F;&#x2F;区间第k大的数
        vector&lt;pair&lt;T,int&gt;&gt; v;
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)&#123;
            v.push_back(&#123;it-&gt;v,it-&gt;r - it-&gt;l + 1&#125;);
        &#125;
        sort(v.begin(),v.end());
        for(auto x : v)&#123;
            k -&#x3D; x.second;
            if(k &lt;&#x3D; 0)  return x.first;
        &#125;
        return -1;
    &#125;
    T sum_pow(int l,int r,int k,int p)&#123; &#x2F;&#x2F;区间[l,r]的k次幂之和
        ll res &#x3D; 0;
        for(auto end &#x3D; split(r + 1),it &#x3D; split(l);it !&#x3D; end;it++)&#123;
            res &#x3D; (res + 1ll * (it-&gt;r - it-&gt;l + 1) * fpow(it-&gt;v,k,p) % p) % p;
        &#125;
        return res;
    &#125;
&#125;;

int rnd()
&#123;
    int ret &#x3D; seed;
    seed &#x3D; (seed * 7ll + 13) % mod;
    return ret;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed &gt;&gt; vmax;
    ODT&lt;ll&gt; odt;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   
    &#123;
        a[i] &#x3D; (rnd() % vmax) + 1;
        odt.insert(i,i,a[i]);
    &#125;

    int op,l,r,x,y;
    while (m--)
    &#123;
        op &#x3D; (rnd() % 4) + 1;
        l &#x3D; (rnd() % n) + 1;
        r &#x3D; (rnd() % n) + 1;
        
        if(l &gt; r)   swap(l,r);
        if(op &#x3D;&#x3D; 3)
        &#123;
            x &#x3D; (rnd() % (r - l + 1)) + 1;
            cout &lt;&lt; odt.get_k(l,r,x) &lt;&lt; &quot;\n&quot;;
        &#125;
        else
        &#123;
            x &#x3D; (rnd() % vmax) + 1;
            if(op &#x3D;&#x3D; 1) odt.add(l,r,x);
            else if(op &#x3D;&#x3D; 2)    odt.assign(l,r,x);
            else
            &#123;
                y &#x3D; (rnd() % vmax) + 1;
                cout &lt;&lt; odt.sum_pow(l,r,x,y) &lt;&lt; &quot;\n&quot;;
            &#125;
        &#125;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><strong>注意：</strong> 往集合里插入结构体的时候，如果有缺省的构造函数，即如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">Node(int _l,int _r &#x3D; -1,ll _v &#x3D; 0):l(_l),r(_r),v(_v)&#123;&#125;</code></pre>

<p>并且使用如下方式插入：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">S.insert(&#123;i,i,a[i]&#125;);</code></pre>

<p>则会出现问题！即它只接收我第一个参数，后面的全给忽视了！！！</p>
<p><img src="/images/5.png" alt="5"></p>
<p>因此一定要注意插入的时候用带上结构体。当然如果不定义构造函数，就可以直接用大括号插入。</p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><h3 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h3><p>Treap &#x3D; Tree + Heap</p>
<p>右旋：</p>
<p><img src="/images/8.gif" alt="右旋"></p>
<p>左旋：</p>
<p><img src="/images/7.gif" alt="左旋"></p>
<p>模板题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/255/">普通平衡树</a></p>
<p><mark>模板代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10,INF &#x3D; 1e8;

int n;
struct Node
&#123;
    int l,r;&#x2F;&#x2F;左右边界
    int key,val;&#x2F;&#x2F;key:二叉搜索树的权值;val:堆的权值
    int cnt,size;&#x2F;&#x2F;这个数出现多少次;size:每个子树里面一共有多少个数,方便求排名
&#125;tr[N];

int root,idx;&#x2F;&#x2F;root:表示根节点;idx:当前分配到了第几个节点

void pushup(int p)&#x2F;&#x2F;用p的两个儿子来算p的信息
&#123;
    tr[p].size &#x3D; tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
&#125;

int get_node(int key)&#x2F;&#x2F;创建并取得节点
&#123;
    tr[++idx].key &#x3D; key;
    tr[idx].val &#x3D; rand();&#x2F;&#x2F;随机值
    tr[idx].cnt &#x3D; tr[idx].size &#x3D; 1;&#x2F;&#x2F;创建的时候默认是叶节点
    return idx;
&#125;

void build()&#x2F;&#x2F;初始化
&#123;
    get_node(-INF),get_node(INF);&#x2F;&#x2F;插入两个哨兵
    root &#x3D; 1,tr[1].r &#x3D; 2;&#x2F;&#x2F;根节点是1号点,1号点右儿子是2号点
    pushup(root);&#x2F;&#x2F;已经有两个值了,pushup一下
&#125;

void zig(int &amp;p)    &#x2F;&#x2F;右旋
&#123;
    int q &#x3D; tr[p].l;&#x2F;&#x2F;q是p的儿子
    tr[p].l &#x3D; tr[q].r,tr[q].r &#x3D; p,p &#x3D; q;&#x2F;&#x2F;p的左儿子变成q的右儿子
    pushup(tr[p].r),pushup(p);
&#125;

void zag(int &amp;p)    &#x2F;&#x2F;左旋
&#123;
    int q &#x3D; tr[p].r;
    tr[p].r &#x3D; tr[q].l,tr[q].l &#x3D; p,p &#x3D; q;
    pushup(tr[p].l),pushup(p);
&#125;

void insert(int &amp;p,int key)&#x2F;&#x2F;记得传引用
&#123;
    if(!p)  p &#x3D; get_node(key);
    else if(tr[p].key &#x3D;&#x3D; key)   tr[p].cnt++;
    else if(tr[p].key &gt; key)    
    &#123;
        insert(tr[p].l,key);
        if(tr[tr[p].l].val &gt; tr[p].val) zig(p);&#x2F;&#x2F;左子树的值大于当前的值,右旋一下 
    &#125;
    else&#x2F;&#x2F;同理
    &#123;
        insert(tr[p].r,key);
        if(tr[tr[p].r].val &gt; tr[p].val) zag(p);
    &#125;
    pushup(p);&#x2F;&#x2F;更新一下当前的值
&#125;

void remove(int &amp;p,int key)
&#123;
    if(!p)  return ;&#x2F;&#x2F;如果要删除的值不存在,就不用管
    if(tr[p].key &#x3D;&#x3D; key)
    &#123;
        if(tr[p].cnt &gt; 1)   tr[p].cnt --;
        else if(tr[p].l || tr[p].r)&#x2F;&#x2F;如果不是叶子节点的话
        &#123;
            if(!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val)&#x2F;&#x2F;如果右子树是空的或者左子树的val大于右子树的val
            &#123;
                zig(p);&#x2F;&#x2F;右旋
                remove(tr[p].r,key);&#x2F;&#x2F;删除右子树
            &#125;
            else
            &#123;
                zag(p);
                remove(tr[p].l,key);
            &#125;
        &#125;
        else    p &#x3D; 0;&#x2F;&#x2F;是叶子节点,直接删除
    &#125;
    else if(tr[p].key &gt; key)    remove(tr[p].l,key);&#x2F;&#x2F;去左边删
    else    remove(tr[p].r,key);&#x2F;&#x2F;去右边删

    pushup(p);&#x2F;&#x2F;更新p
&#125;
&#x2F;&#x2F;下面四个函数只有查询没有修改,就不用传引用了
int get_rank_by_key(int p,int key) &#x2F;&#x2F;通过数值找排名
&#123;
    if(!p)  return 0;   &#x2F;&#x2F;本题中不会发生次情况
    if(tr[p].key &#x3D;&#x3D; key)   return tr[tr[p].l].size + 1;
    if(tr[p].key &gt; key) return get_rank_by_key(tr[p].l,key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r,key);

&#125;

int get_key_by_rank(int p,int rank)    &#x2F;&#x2F;通过排名找数值
&#123;
    if(!p)  return INF;&#x2F;&#x2F;本题中不会发生次情况
    if(tr[tr[p].l].size &gt;&#x3D; rank)    return get_key_by_rank(tr[p].l,rank);&#x2F;&#x2F;左边数的个数大于等于rank的话,说明第rank个数在左边
    if(tr[tr[p].l].size + tr[p].cnt &gt;&#x3D; rank)    return tr[p].key;&#x2F;&#x2F;如果左边数的个数加上当前数的个数是大于等于rank,说明第rank个数必然是当前数自己
    return get_key_by_rank(tr[p].r,rank - tr[tr[p].l].size - tr[p].cnt);&#x2F;&#x2F;返回右子树,先减去左子树里数的个数再减去p的个数
&#125;

int get_prev(int p,int key)    &#x2F;&#x2F;找到严格小于key的最大数
&#123;
    if(!p)  return -INF;
    if(tr[p].key &gt;&#x3D; key)    return get_prev(tr[p].l,key);
    return max(tr[p].key,get_prev(tr[p].r,key));
&#125;

int get_next(int p,int key) &#x2F;&#x2F;找到严格大于key的最小数
&#123;
    if(!p)  return INF;
    if(tr[p].key &lt;&#x3D; key)    return get_next(tr[p].r,key);
    return min(tr[p].key,get_next(tr[p].l,key));
&#125;

int main()
&#123;
    build();&#x2F;&#x2F;创建一棵树

    scanf(&quot;%d&quot;,&amp;n);&#x2F;&#x2F;读入n个操作
    while(n--)
    &#123;
        int opt,x;
        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);
        if(opt &#x3D;&#x3D; 1)    insert(root,x);&#x2F;&#x2F;插入一个数x
        else if(opt &#x3D;&#x3D; 2)   remove(root,x);&#x2F;&#x2F;删除x
        else if(opt &#x3D;&#x3D; 3)   printf(&quot;%d\n&quot;,get_rank_by_key(root,x) - 1);&#x2F;&#x2F;根据数值找排名(因为多了-INF这个哨兵的存在,所以真实排名需要减1)
        else if(opt &#x3D;&#x3D; 4)   printf(&quot;%d\n&quot;,get_key_by_rank(root,x + 1));&#x2F;&#x2F;根据排名找数值(因为多了一个最小值,因此需要加上1)
        else if(opt &#x3D;&#x3D; 5)   printf(&quot;%d\n&quot;,get_prev(root,x));&#x2F;&#x2F;找数值的前驱
        else    printf(&quot;%d\n&quot;,get_next(root,x));&#x2F;&#x2F;找后继
    &#125;
    return 0;
&#125;</code></pre>

<h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h3><p>Splay保证中序遍历是当前序列的顺序。</p>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e5 + 10;
struct HLD
&#123;
    int a[N], cnt;
    int sz[N], top[N], dep[N], fa[N], son[N], id[N], nw[N];
    vector&lt;int&gt; g[N];
    struct Tree                          
    &#123;
        int l, r;
        ll add, sum;
    &#125;tr[N &lt;&lt; 2];

    void dfs1(int u, int father, int depth) &#123;
        dep[u] &#x3D; depth, fa[u] &#x3D; father, sz[u] &#x3D; 1;
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; father) continue;
            dfs1(v, u, depth + 1);
            sz[u] +&#x3D; sz[v];
            if (sz[son[u]] &lt; sz[v])  son[u] &#x3D; v;
        &#125;
    &#125;

    void dfs2(int u, int t)
    &#123;
        id[u] &#x3D; ++cnt, nw[cnt] &#x3D; a[u], top[u] &#x3D; t;
        if (!son[u]) return;
        dfs2(son[u], t);
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa[u] || v &#x3D;&#x3D; son[u])   continue;
            dfs2(v, v);
        &#125;
    &#125;
    
    int lca(int u, int v) &#123;
        while (top[u] !&#x3D; top[v]) &#123;
            if (dep[top[u]] &gt; dep[top[v]]) &#123;
                u &#x3D; fa[top[u]];
            &#125;
            else &#123;
                v &#x3D; fa[top[v]];
            &#125;
        &#125;
        return dep[u] &lt; dep[v] ? u : v;
    &#125;

    void pushup(int u)
    &#123;
        tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    &#125;

    void eval(Tree &amp;u,ll add)
    &#123;
        u.add +&#x3D; add;
        u.sum +&#x3D; (u.r - u.l + 1) * add;
    &#125;

    void pushdown(int u)
    &#123;
        eval(tr[u &lt;&lt; 1], tr[u].add);
        eval(tr[u &lt;&lt; 1 | 1], tr[u].add);
        tr[u].add &#x3D; 0;
    &#125;

    void build(int u,int l,int r)
    &#123;
        tr[u] &#x3D; &#123;l, r&#125;;
        if (l &#x3D;&#x3D; r)  return tr[u].sum &#x3D; nw[l], void();
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid), build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;

    void update(int u, int l, int r, int k)
    &#123;
        if (l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    
        &#123;   
            eval(tr[u], k);
        &#125;
        else
        &#123;
            pushdown(u);
            int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
            if (l &lt;&#x3D; mid)    update(u &lt;&lt; 1, l, r, k);
            if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k);
            pushup(u);
        &#125;
    &#125;

    ll query(int u,int l,int r)
    &#123;
        if (l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return  tr[u].sum;
        pushdown(u);
        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
        ll res &#x3D; 0;
        if (l &lt;&#x3D; mid)    res +&#x3D; query(u &lt;&lt; 1, l, r);
        if (r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);
        return res;
    &#125;

    void update_path(int u,int v,int k)
    &#123;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
            update(1, id[top[u]], id[u], k);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u, v);
        update(1, id[v], id[u], k);
    &#125;

    void update_tree(int u,int k)
    &#123;
        update(1, id[u], id[u] + sz[u] - 1, k);
    &#125;

    ll query_path(int u,int v)
    &#123;
        ll res &#x3D; 0;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]])   swap(u, v);
            res +&#x3D; query(1, id[top[u]], id[u]);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u,v);
        res +&#x3D; query(1, id[v], id[u]);
        return res;
    &#125;

    ll query_tree(int u)
    &#123;
        return query(1, id[u], id[u] + sz[u] - 1);
    &#125;
&#125;hld;</code></pre>



<blockquote>
<p>算法流程：<br>        1、通过dfs1确定深度、父节点、子树大小；</p>
<p>​     2、通过dfs2确定dfs序：id[]、dfs序所对应的权值：nw[]、重链的顶点：top[]；</p>
<p>​     3、树链剖分的思想类似于最近公共祖先（lca），其是通过重链往上爬的，确定的dfs序：id[]方便得知线段树对应的区间，从而将树上路径的问题转换成线段树区间上的问题。</p>
</blockquote>
<p><mark>树链剖分的作用：</mark></p>
<p>把树转化成一个序列，这样树中 任意一条路径 就转换到 <strong>log⁡n</strong> 段的 连续区间。</p>
<p>然后就可以使用各种 维护区间信息 的 数据结构了。</p>
<p><mark>细节：</mark></p>
<p>dfs序：优先遍历重儿子。</p>
<p>重链的开头一定是个轻儿子。</p>
<p><mark>树链剖分中的几个定义：</mark></p>
<p>重&#x2F;轻儿子：节点个数最多的子树，该节点为其父节点的 重儿子，其余都为 轻儿子（叶节点没有轻重儿子概念）。</p>
<p>重&#x2F;轻边：重儿子和它父节点的边称为 重边，轻儿子和它父节点的边称为 轻边。</p>
<p>重链：由 重边 构成的 <strong>极大</strong>路径。</p>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5 + 10;
struct HLD
&#123;
    int a[N], cnt;
    int sz[N], top[N], dep[N], fa[N], son[N], id[N], nw[N];
    vector&lt;int&gt; g[N];
    struct Tree                          
    &#123;
        int l, r;
        ll add, sum;
    &#125;tr[N &lt;&lt; 2];

    void dfs1(int u, int father, int depth) &#123;
        dep[u] &#x3D; depth, fa[u] &#x3D; father, sz[u] &#x3D; 1;
        for (auto v : g[u])
        &#123;
            if(v &#x3D;&#x3D; father) continue;
            dfs1(v, u, depth + 1);
            sz[u] +&#x3D; sz[v];
            if (sz[son[u]] &lt; sz[v])  son[u] &#x3D; v;
        &#125;
    &#125;

    void dfs2(int u, int t)
    &#123;
        id[u] &#x3D; ++cnt, nw[cnt] &#x3D; a[u], top[u] &#x3D; t;
        if (!son[u]) return;
        dfs2(son[u], t);
        for (auto v : g[u])
        &#123;
            if (v &#x3D;&#x3D; fa[u] || v &#x3D;&#x3D; son[u])   continue;
            dfs2(v, v);
        &#125;
    &#125;
    
    int lca(int u, int v) &#123;
        while (top[u] !&#x3D; top[v]) &#123;
            if (dep[top[u]] &gt; dep[top[v]]) &#123;
                u &#x3D; fa[top[u]];
            &#125;
            else &#123;
                v &#x3D; fa[top[v]];
            &#125;
        &#125;
        return dep[u] &lt; dep[v] ? u : v;
    &#125;

    void pushup(int u)
    &#123;
        tr[u].sum &#x3D; tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
    &#125;

    void eval(Tree &amp;u,ll add)
    &#123;
        u.add +&#x3D; add;
        u.sum +&#x3D; (u.r - u.l + 1) * add;
    &#125;

    void pushdown(int u)
    &#123;
        eval(tr[u &lt;&lt; 1], tr[u].add);
        eval(tr[u &lt;&lt; 1 | 1], tr[u].add);
        tr[u].add &#x3D; 0;
    &#125;

    void build(int u,int l,int r)
    &#123;
        tr[u] &#x3D; &#123;l, r&#125;;
        if (l &#x3D;&#x3D; r)  return tr[u].sum &#x3D; nw[l], void();
        int mid &#x3D; l + r &gt;&gt; 1;
        build(u &lt;&lt; 1,l,mid), build(u &lt;&lt; 1 | 1,mid + 1,r);
        pushup(u);
    &#125;

    void update(int u, int l, int r, int k)
    &#123;
        if(l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    
        &#123;   
            eval(tr[u], k);
        &#125;
        else
        &#123;
            pushdown(u);
            int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
            if (l &lt;&#x3D; mid)    update(u &lt;&lt; 1, l, r, k);
            if (r &gt; mid) update(u &lt;&lt; 1 | 1, l, r, k);
            pushup(u);
        &#125;
    &#125;

    ll query(int u,int l,int r)
    &#123;
        if (l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)    return  tr[u].sum;
        pushdown(u);
        int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;
        ll res &#x3D; 0;
        if (l &lt;&#x3D; mid)    res +&#x3D; query(u &lt;&lt; 1, l, r);
        if (r &gt; mid) res +&#x3D; query(u &lt;&lt; 1 | 1, l, r);
        return res;
    &#125;

    void update_path(int u,int v,int k)
    &#123;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]]) swap(u, v);
            update(1, id[top[u]], id[u], k);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u, v);
        update(1, id[v], id[u], k);
    &#125;

    void update_tree(int u,int k)
    &#123;
        update(1, id[u], id[u] + sz[u] - 1, k);
    &#125;

    ll query_path(int u,int v)
    &#123;
        ll res &#x3D; 0;
        while (top[u] !&#x3D; top[v])
        &#123;
            if (dep[top[u]] &lt; dep[top[v]])   swap(u, v);
            res +&#x3D; query(1, id[top[u]], id[u]);
            u &#x3D; fa[top[u]];
        &#125;
        if (dep[u] &lt; dep[v]) swap(u,v);
        res +&#x3D; query(1, id[v], id[u]);
        return res;
    &#125;

    ll query_tree(int u)
    &#123;
        return query(1, id[u], id[u] + sz[u] - 1);
    &#125;

    void solve()
    &#123;
        int n;
        cin &gt;&gt; n;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];
        for (int i &#x3D; 1; i &lt; n; i++)
        &#123;
            int a, b;
            cin &gt;&gt; a &gt;&gt; b;
            g[a].push_back(b);
            g[b].push_back(a);
        &#125;

        dfs1(1, -1, 1);
        dfs2(1, 1);
        build(1, 1, n);

        int m;
        cin &gt;&gt; m;
        while (m--)
        &#123;
            int op, u, v, k;
            cin &gt;&gt; op;
            if (op &#x3D;&#x3D; 1)
            &#123;
                cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;
                update_path(u, v, k);
            &#125;
            else if (op &#x3D;&#x3D; 2)
            &#123;
                cin &gt;&gt; u &gt;&gt; k;
                update_tree(u, k);
            &#125;
            else if (op &#x3D;&#x3D; 3)
            &#123;
                cin &gt;&gt; u &gt;&gt; v;
                cout &lt;&lt; query_path(u, v) &lt;&lt; &quot;\n&quot;;
            &#125;
            else
            &#123;
                cin &gt;&gt; u;
                cout &lt;&lt; query_tree(u) &lt;&lt; &quot;\n&quot;;
            &#125;
        &#125;
        
    &#125;
&#125;hld;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    hld.solve();
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2570/">树链剖分</a></p>
<p><strong>树链剖分 + 区间最大&#x2F;最小子段和：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1843/problem/F2">F2. Omsk Metro (hard version)</a></p>
<p><strong>$2023$ 蓝桥杯 $b$ 组省赛最后一题</strong>：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4966/">砍树</a></p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><blockquote>
<p>很神奇的是，AC自动机均可被后缀自动机取代（不过后缀自动机的空间比较大，这个需要注意）！</p>
<p><strong>模板使用介绍：</strong></p>
<ul>
<li>首先每次插入字符串；</li>
<li>可同时确定该结点对应的字符串编号、长度等等；</li>
<li>然后必须记得 $build()$（必做）；</li>
<li>$query$ 函数只是个使用实例，不具任何通用性！</li>
<li><strong>注意：</strong>如果添加或修改了新数组，$clear$ 函数要对针对性的清空！</li>
</ul>
</blockquote>
<p><mark>封装模板：</mark></p>
<ul>
<li><strong>注意：</strong>这里队列用数组实现，因为队列实现完成后具有拓扑的意义，便于解决很多问题！</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e6 + 10;
template&lt;typename T&gt;
struct AC_automation &#123;
    T cnt[N], len[N], ne[N], q[N];
    int tr[N][26], idx;

    AC_automation(): idx(0) &#123; &#125;
    void clear() &#123; &#x2F;&#x2F; 清空数组
        for (int i &#x3D; 0; i &lt;&#x3D; idx; i++) &#123;
            cnt[i] &#x3D; len[i] &#x3D; ne[i] &#x3D; q[i] &#x3D; 0;
            for (int j &#x3D; 0; j &lt; 26; j++) &#123;
                tr[i][j] &#x3D; 0;
            &#125;
        &#125;
        idx &#x3D; 0;
    &#125;
    void insert(string s) &#123;
        int p &#x3D; 0;
        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;
            int c &#x3D; s[i] - &#39;a&#39;;
            if (!tr[p][c])  tr[p][c] &#x3D; ++idx;
            p &#x3D; tr[p][c];
        &#125;
        cnt[p]++, len[p] &#x3D; s.size();
    &#125;
    void build() &#123;
        int hh &#x3D; 0, tt &#x3D; -1;
        for (int i &#x3D; 0; i &lt; 26; i++)
            if (tr[0][i])
                q[++tt] &#x3D; tr[0][i];

        while (hh &lt;&#x3D; tt) &#123;
            auto t &#x3D; q[hh++];

            for (int i &#x3D; 0; i &lt; 26; i++) &#123;
                int &amp;p &#x3D; tr[t][i];
                if (!p) p &#x3D; tr[ne[t]][i];
                else &#123;
                    ne[p] &#x3D; tr[ne[t]][i];
                    q[++tt] &#x3D; p;
                &#125;
            &#125;
        &#125;
    &#125;
    T query(string s) &#123;
        T res &#x3D; 0;
        for (int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;
            int c &#x3D; s[i] - &#39;a&#39;;
            j &#x3D; tr[j][c];

            int p &#x3D; j;
            while (p &amp;&amp; ~cnt[p]) &#123;
                res +&#x3D; cnt[p];
                cnt[p] &#x3D; -1;
                p &#x3D; ne[p];
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
AC_automation&lt;int&gt; AC;</code></pre>

<p><mark>模板题（搜索关键词）代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;
template&lt;typename T&gt;
struct AC_automation &#123;
    T cnt[N], len[N], ne[N];
    int tr[N][26], idx;

    AC_automation(): idx(0) &#123; &#125;
    void clear() &#123; &#x2F;&#x2F; 清空数组
        for (int i &#x3D; 0; i &lt;&#x3D; idx; i++) &#123;
            cnt[i] &#x3D; len[i] &#x3D; ne[i] &#x3D; 0;
            for (int j &#x3D; 0; j &lt; 26; j++) &#123;
                tr[i][j] &#x3D; 0;
            &#125;
        &#125;
        idx &#x3D; 0;
    &#125;
    void insert(string s) &#123;
        int p &#x3D; 0;
        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;
            int c &#x3D; s[i] - &#39;a&#39;;
            if (!tr[p][c])  tr[p][c] &#x3D; ++idx;
            p &#x3D; tr[p][c];
        &#125;
        cnt[p]++, len[p] &#x3D; s.size();
    &#125;
    void build() &#123;
        queue&lt;int&gt; q;
        for (int i &#x3D; 0; i &lt; 26; i++)
            if (tr[0][i])
                q.push(tr[0][i]);

        while (!q.empty()) &#123;
            auto t &#x3D; q.front();
            q.pop();

            for (int i &#x3D; 0; i &lt; 26; i++) &#123;
                int &amp;p &#x3D; tr[t][i];
                if (!p) p &#x3D; tr[ne[t]][i];
                else &#123;
                    ne[p] &#x3D; tr[ne[t]][i];
                    q.push(p);
                &#125;
            &#125;
        &#125;
    &#125;
    T query(string s) &#123;
        T res &#x3D; 0;
        for (int i &#x3D; 0, j &#x3D; 0; i &lt; s.size(); i++) &#123;
            int c &#x3D; s[i] - &#39;a&#39;;
            j &#x3D; tr[j][c];

            int p &#x3D; j;
            while (p &amp;&amp; ~cnt[p]) &#123;
                res +&#x3D; cnt[p];
                cnt[p] &#x3D; -1;
                p &#x3D; ne[p];
            &#125;
        &#125;
        return res;
    &#125;

    void solve() 
    &#123;
        int n;
        cin &gt;&gt; n;

        string s;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            cin &gt;&gt; s;
            insert(s);
        &#125;

        build();
        cin &gt;&gt; s;

        cout &lt;&lt; query(s) &lt;&lt; &quot;\n&quot;;
        clear();
    &#125;
&#125;;
AC_automation&lt;int&gt; AC;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t &#x3D; 1;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        AC.solve();
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>模板题（单词）代码（AC自动机写法）：</mark></p>
<ul>
<li>记录每个前缀出现的次数；</li>
<li>队列的顺序为拓扑排序（可用于倒序递推）；</li>
<li>递推（dp）即可。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;
template&lt;typename T&gt;
struct AC_automation &#123;
    T ne[N], id[N], f[N], q[N];
    int tr[N][26], idx;

    AC_automation(): idx(0) &#123; &#125;
    void insert(string s, int index) &#123;
        int p &#x3D; 0;
        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;
            int c &#x3D; s[i] - &#39;a&#39;;
            if (!tr[p][c])  tr[p][c] &#x3D; ++idx;
            p &#x3D; tr[p][c];
            f[p]++;
        &#125;
        id[index] &#x3D; p;
    &#125;
    void build() &#123;
        int hh &#x3D; 0, tt &#x3D; -1;
        for (int i &#x3D; 0; i &lt; 26; i++)
            if (tr[0][i])
                q[++tt] &#x3D; tr[0][i];

        while (hh &lt;&#x3D; tt) &#123;
            auto t &#x3D; q[hh++];

            for (int i &#x3D; 0; i &lt; 26; i++) &#123;
                int &amp;p &#x3D; tr[t][i];
                if (!p) p &#x3D; tr[ne[t]][i];
                else &#123;
                    ne[p] &#x3D; tr[ne[t]][i];
                    q[++tt] &#x3D; p;
                &#125;
            &#125;
        &#125;
    &#125;
    void solve()
    &#123;
        int n;
        cin &gt;&gt; n;

        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            string s;
            cin &gt;&gt; s;
            insert(s, i);
        &#125;

        build();

        for (int i &#x3D; idx - 1; i &gt;&#x3D; 0; i--)
            f[ne[q[i]]] +&#x3D; f[q[i]];
        
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            cout &lt;&lt; f[id[i]] &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;;
AC_automation&lt;int&gt; AC;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    AC.solve();

    return 0;
&#125;</code></pre>

<p><mark>模板题（单词）代码（后缀自动机写法）：</mark></p>
<ul>
<li>类似后缀自动机的第一个模板题；</li>
<li>每个字符串之间用未出现过的字符间隔；</li>
<li>一个字符串对应的结点编号可以遍历一遍获取（新的来自于后缀自动机知识点）！</li>
<li>最后需要注意的是：空间再额外开 200！因为我们给字符串有间隔，是需要消耗空间的！</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; (1e6 + 200) * 2 + 10; &#x2F;&#x2F; 空间开2倍

struct SAM
&#123;
    int tot, last, f[N];
    struct Node
    &#123;
        int len, fa;
        int ch[27];
        void init() &#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch, 0, sizeof(ch));
        &#125;
    &#125;node[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125;
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        f[tot] &#x3D; 1;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;

    void solve()
    &#123;
        int n;
        cin &gt;&gt; n;

        vector&lt;string&gt; str(n + 1);
        int sum &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            cin &gt;&gt; str[i];
            sum +&#x3D; str[i].size();
            for (auto c : str[i])    extend(c - &#39;a&#39;);
            extend(26);
        &#125;

        vector&lt;vector&lt;int&gt;&gt; g(tot + 1);
        for (int i &#x3D; 2; i &lt;&#x3D; tot; i++)
            g[node[i].fa].push_back(i);
        function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
        &#123;
            for (auto v : g[u])
            &#123;
                dfs(v);
                f[u] +&#x3D; f[v];
            &#125;
        &#125;;

        dfs(1);
        
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            int p &#x3D; 1;
            for (auto c : str[i])
                p &#x3D; node[p].ch[c - &#39;a&#39;];
            cout &lt;&lt; f[p] &lt;&lt; &quot;\n&quot;;
        &#125;
    &#125;
&#125;sam;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    sam.solve();
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong> <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/1284/">搜索关键词</a>	<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/1287/">单词</a></p>
<p><strong>模板题加强版(严格O(n))：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3808">【模板】AC 自动机（简单版）</a></p>
<p><strong>$2023\ CCPC$ 女生赛：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104725/problem/H">H. 字符串游戏</a></p>
<p><strong>$2023$ 湖南省省赛：</strong><a target="_blank" rel="noopener" href="https://cpc.csgrandeur.cn/csgoj/problemset/problem?pid=1199">1199 : Substrings Same as Prefix</a></p>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><blockquote>
<p><strong>算法步骤：</strong></p>
<ol>
<li>进行基数排序获得 $sa[i]$；</li>
<li>获得 $height$ 数组；</li>
</ol>
<p><strong>性质：</strong></p>
<ol>
<li><p>$lcp(i, j) &#x3D; min(lcp(i, k), lcp(k, j)),i \le k \le j$</p>
</li>
<li><p>令 $h[i] &#x3D; height[rk[i]]$，表示第 $i$ 个字符与排名在第 $i$ 个字符前面一个的字符的 $lcp$，则可以得出：</p>
</li>
</ol>
<p>$h[i] \ge h[i - 1] - 1$</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e6 + 10;
struct SuffixArray
&#123;
    string s;
    int n, m, sa[N], rk[N], height[N], x[N], y[N], c[N];

    void init(string t) &#123; &#x2F;&#x2F; 必须先初始化
        n &#x3D; t.size(), s &#x3D; &quot; &quot; + t, m &#x3D; &#39;z&#39;;
    &#125;

    void get_sa() &#123;
		&#x2F;&#x2F; 第一次基数排序
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i] &#x3D; s[i]]++;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
        for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[i]]--] &#x3D; i;
		&#x2F;&#x2F; 倍增多轮
        for (int k &#x3D; 1; k &lt;&#x3D; n; k &lt;&lt;&#x3D; 1) &#123;
            int num &#x3D; 0;
			&#x2F;&#x2F; 第二关键字基数排序
            for (int i &#x3D; n - k + 1; i &lt;&#x3D; n; i++)    y[++num] &#x3D; i;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                if (sa[i] &gt; k)
                    y[++num] &#x3D; sa[i] - k;
			&#x2F;&#x2F; 第一关键字基数排序
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] &#x3D; 0;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i]]++;
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
            for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[y[i]]]--] &#x3D; y[i], y[i] &#x3D; 0;
            swap(x, y);
			&#x2F;&#x2F; 离散化
            x[sa[1]] &#x3D; 1, num &#x3D; 1;
            for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
                x[sa[i]] &#x3D; (y[sa[i]] &#x3D;&#x3D; y[sa[i - 1]] &amp;&amp; y[sa[i] + k] &#x3D;&#x3D; y[sa[i - 1] + k] ? num : ++num);   

            if (num &#x3D;&#x3D; n) break; &#x2F;&#x2F; 说明本次排序，没有出现相等的数，则每个数的大小关系都已经确定
			m &#x3D; num;
        &#125;
    &#125;

    void get_height() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    rk[sa[i]] &#x3D; i; &#x2F;&#x2F; 排名为i的字符的排名为i
        &#x2F;&#x2F; 根据 h() -&gt; height
        for (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++) &#123;
            if (rk[i] &#x3D;&#x3D; 1) continue;
            if (k)  k--;
            int j &#x3D; sa[rk[i] - 1];
            while (i + k &lt;&#x3D; n &amp;&amp; j + k &lt;&#x3D; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k])    k++;
            height[rk[i]] &#x3D; k;
        &#125;
    &#125;
&#125;SA;</code></pre>

<p><mark>模板题（带注释版）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;

int n, m;
char s[N];
int sa[N], x[N], y[N], c[N], rk[N], height[N];
&#x2F;**
 * sa[i]: 排名为i是第几个后缀
 * rk[i]: 第i个后缀的排名是多少
 * height[i]: sa[i] 与 sa[i - 1]的最长公共前缀是多少(即lcp(sa[i - 1],sa[i]))
 * x[]:第一关键字
 * y[]:第二关键字
 * c[]:每个关键字的个数
*&#x2F;
void get_sa()
&#123;
	&#x2F;&#x2F; &#x2F;&#x2F; 按照第一关键字排序
    for (int i &#x3D; 1;i &lt;&#x3D; n;i++)   c[x[i] &#x3D; s[i]]++;
    for(int i &#x3D; 2;i &lt;&#x3D; m;i++)   c[i] +&#x3D; c[i - 1];
    for(int i &#x3D; n;i;i--)    sa[c[x[i]]--] &#x3D; i; 
	&#x2F;&#x2F; 执行logn轮
    for(int k &#x3D; 1;k &lt;&#x3D; n;k &lt;&lt;&#x3D; 1)
    &#123;
        int num &#x3D; 0;
		&#x2F;&#x2F; 将所有后缀按照第二关键字排好序
        for(int i &#x3D; n - k + 1;i &lt;&#x3D; n;i++)   y[++num] &#x3D; i; &#x2F;&#x2F;由于这段没有第二关键字, 因此在第二关键字中排名最小
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#x2F;&#x2F; i的第二关键字, 为i+k的第一关键字
            if(sa[i] &gt; k)
                y[++num] &#x3D; sa[i] - k;
        for(int i &#x3D; 1;i &lt;&#x3D; m;i++)   c[i] &#x3D; 0;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   c[x[i]]++;
        for(int i &#x3D; 2;i &lt;&#x3D; m;i++)   c[i] +&#x3D; c[i - 1];
        for(int i &#x3D; n;i;i--) &#x2F;&#x2F; 按照第二关键字的顺序，从后往前枚举
            sa[c[x[y[i]]]--] &#x3D; y[i],y[i] &#x3D; 0; &#x2F;&#x2F; y[i]: 排名第i的是哪个后缀; x[i]: 第i个后缀排名是多少
        swap(x,y); &#x2F;&#x2F; y数组没用了
		&#x2F;&#x2F; 根据前2k的关键字进行离散化处理
        x[sa[1]] &#x3D; 1,num &#x3D; 1;
        for(int i &#x3D; 2;i &lt;&#x3D; n;i++)  
            x[sa[i]] &#x3D; (y[sa[i]] &#x3D;&#x3D; y[sa[i - 1]] &amp;&amp; y[sa[i] + k] &#x3D;&#x3D; y[sa[i - 1] + k]) ? num : ++num;
        if(num &#x3D;&#x3D; n)    break;
        m &#x3D; num;
    &#125;
&#125;

void get_height()
&#123;
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   rk[sa[i]] &#x3D; i;
    for(int i &#x3D; 1, k &#x3D; 0;i &lt;&#x3D; n;i++)
    &#123;
        if(rk[i] &#x3D;&#x3D; 1)  continue;
        if(k)   k--;
        int j &#x3D; sa[rk[i] - 1];
        while(i + k &lt;&#x3D; n &amp;&amp; j + k &lt;&#x3D; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k]) k++;
        height[rk[i]] &#x3D; k;
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; s + 1;
    n &#x3D; strlen(s + 1), m &#x3D; &#39;z&#39;;
    get_sa();
    get_height();

    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)   cout &lt;&lt; sa[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)   cout &lt;&lt; height[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];
    return 0;
&#125;</code></pre>

<p><mark>模板题（含封装模板）代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;
struct SuffixArray
&#123;
    string s;
    int n, m, sa[N], rk[N], height[N], x[N], y[N], c[N];

    void init(string t) &#123; &#x2F;&#x2F; 必须先初始化
        n &#x3D; t.size(), s &#x3D; &quot; &quot; + t, m &#x3D; &#39;z&#39;;
    &#125;

    void get_sa() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i] &#x3D; s[i]]++;
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
        for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[i]]--] &#x3D; i;

        for (int k &#x3D; 1; k &lt;&#x3D; n; k &lt;&lt;&#x3D; 1) &#123;
            int num &#x3D; 0;
            for (int i &#x3D; n - k + 1; i &lt;&#x3D; n; i++)    y[++num] &#x3D; i;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
                if (sa[i] &gt; k)
                    y[++num] &#x3D; sa[i] - k;
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] &#x3D; 0;
            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    c[x[i]]++;
            for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    c[i] +&#x3D; c[i - 1];
            for (int i &#x3D; n; i &gt;&#x3D; 1; i--)    sa[c[x[y[i]]]--] &#x3D; y[i], y[i] &#x3D; 0;
            swap(x, y);
            x[sa[1]] &#x3D; 1, num &#x3D; 1;
            for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
                x[sa[i]] &#x3D; (y[sa[i]] &#x3D;&#x3D; y[sa[i - 1]] &amp;&amp; y[sa[i] + k] &#x3D;&#x3D; y[sa[i - 1] + k] ? num : ++num);   

            m &#x3D; num;
            if (m &#x3D;&#x3D; n) break;
        &#125;
    &#125;

    void get_height() &#123;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    rk[sa[i]] &#x3D; i; &#x2F;&#x2F; 排名为i的字符的排名为i
        
        for (int i &#x3D; 1, k &#x3D; 0; i &lt;&#x3D; n; i++) &#123;
            if (rk[i] &#x3D;&#x3D; 1) continue;
            if (k)  k--;
            int j &#x3D; sa[rk[i] - 1];
            while (i + k &lt;&#x3D; n &amp;&amp; j + k &lt;&#x3D; n &amp;&amp; s[i + k] &#x3D;&#x3D; s[j + k])    k++;
            height[rk[i]] &#x3D; k;
        &#125;
    &#125;
&#125;SA;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    cin &gt;&gt; s;

    SA.init(s);
    SA.get_sa();
    SA.get_height();

    for (int i &#x3D; 1; i &lt;&#x3D; SA.n; i++) cout &lt;&lt; SA.sa[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; SA.n];
    for (int i &#x3D; 1; i &lt;&#x3D; SA.n; i++) cout &lt;&lt; SA.height[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; SA.n];
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2717/">后缀数组</a></p>
<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><blockquote>
<p><strong>一、基本信息：</strong></p>
<ol>
<li>一个 $SAM$ 最多有 $2n-1$ 个节点和 $3n-4$ 条转移边。不过<mark>只用开 $2$ 倍空间即可</mark>，每个点只有一个 $fa$ 的边，因此那个所谓的转移边的个数可以忽略。</li>
</ol>
<p><strong>二、功能非常强大的数据结构，主要应用如下：</strong></p>
<ol>
<li>求模式串 $p$ 有没有在字符串 $s$ 中出现过。</li>
<li>求模式串 $p$ 在字符串 $s$ 中出现的次数。</li>
<li>求字符串 $s$ 的最小表示法（循环同构字符串中字典序最小的一个）。</li>
<li>求 $s$ 的本质不同子串个数。</li>
<li>最长公共子串。</li>
</ol>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e6 * 2 + 10; &#x2F;&#x2F; 空间开2倍
struct SAM
&#123;
    int tot,last;
    struct Node
    &#123;
        int len,fa;
        int ch[26];
        void init()&#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch,0,sizeof(ch));
        &#125;
    &#125;node[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125; &#x2F;&#x2F; tot: 1号点是空点
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;
&#125;sam;</code></pre>

<h3 id="2-求模式串-p-在字符串-s-中出现的次数"><a href="#2-求模式串-p-在字符串-s-中出现的次数" class="headerlink" title="2.求模式串 $p$ 在字符串 $s$ 中出现的次数"></a>2.求模式串 $p$ 在字符串 $s$ 中出现的次数</h3><p><mark>模板题代码（包含：“求模式串 $p$ 在字符串 $s$ 中出现的次数”的做法）：</mark></p>
<p><strong>$tip:$</strong> 后面有新的码风所对应的代码！</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 2e6 + 10;

int tot &#x3D; 1,last &#x3D; 1;&#x2F;&#x2F;tot:当前用到哪个点了;last:上一个点的编号;1号点是一个空点!!!
struct Node
&#123;
    int len,fa;&#x2F;&#x2F;这个状态里所有子串的最大长度;fa:绿色边(link)
    int ch[26];&#x2F;&#x2F;所有儿子
&#125;node[N];
char str[N];
ll f[N],ans;
int h[N],e[N],ne[N],idx;

void extend(int c)
&#123;
    int p &#x3D; last,np &#x3D; last &#x3D; ++tot;&#x2F;&#x2F;p为上一次插入的状态,np表示我们当前插入的新状态
    f[tot] &#x3D; 1;
    node[np].len &#x3D; node[p].len + 1;
    for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)&#x2F;&#x2F;存在父子关系节点包含的子串有后缀关系
        node[p].ch[c] &#x3D; np;&#x2F;&#x2F;只要p不是空的并且p是没有c这个儿子的,那么p就往前走
    if(!p)  node[np].fa &#x3D; 1;&#x2F;&#x2F;整个到根节点的路径全都没有c这个儿子,特判一下,将其置为1(空,即连向起始点)
    else
    &#123;
        int q &#x3D; node[p].ch[c];&#x2F;&#x2F;用q表示当前这个点的c这条边
        if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
        else
        &#123;&#x2F;&#x2F;看它听不听话,如果不听话就换一个人！
            int nq &#x3D; ++ tot;&#x2F;&#x2F;新建一个新的q
            node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;&#x2F;&#x2F;新的q完全把旧的q复制过来
            node[q].fa &#x3D; node[np].fa &#x3D; nq;&#x2F;&#x2F;把np指向新的听话的这个人
            for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
        &#125;&#x2F;&#x2F;把所有p的c这个儿子替换成听话的这个
    &#125;
&#125;

void add(int a,int b)
&#123;
    e[idx] &#x3D; b,ne[idx] &#x3D; h[a],h[a] &#x3D; idx++;
&#125;

void dfs(int u)
&#123;
    for(int i &#x3D; h[u]; ~i;i &#x3D; ne[i])
    &#123;
        dfs(e[i]);
        f[u] +&#x3D; f[e[i]];
    &#125;
    if(f[u] &gt; 1)    ans &#x3D; max(ans,f[u] * node[u].len);
&#125;

int main()
&#123;
    scanf(&quot;%s&quot;,str);
    for(int i &#x3D; 0;str[i];i++)   extend(str[i] - &#39;a&#39;);&#x2F;&#x2F;将新的字符扩展一遍
    memset(h,-1,sizeof(h));
    for(int i &#x3D; 2;i &lt;&#x3D; tot;i++) add(node[i].fa,i);&#x2F;&#x2F;1号点是没有父节点的;当前点的父节点向当前点连一条边
    dfs(1);
    printf(&quot;%lld\n&quot;,ans);
&#125;</code></pre>

<p><mark>新码风代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e6 * 2 + 10;
struct SAM
&#123;
    int tot,last;
    struct Node
    &#123;
        int len,fa;
        int ch[26];
        void init()&#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch,0,sizeof(ch));
        &#125;
    &#125;node[N];
    int f[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125;
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        f[tot] &#x3D; 1;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;

    int h[N], e[N], ne[N], idx;

    void add(int a, int b) &#123;
        e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
    &#125;
    ll res &#x3D; 0;
    void dfs(int u) &#123;
        for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i]) &#123;
            int v &#x3D; e[i];
            dfs(v);
            f[u] +&#x3D; f[v];
        &#125;
        if (f[u] &gt; 1)   res &#x3D; max(res, (ll)f[u] * node[u].len);
    &#125;

    void solve() &#123;
        memset(h, -1, sizeof(h));
        for (int i &#x3D; 2; i &lt;&#x3D; tot; i++)
            add(node[i].fa, i);

        dfs(1);

        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;sam;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    cin &gt;&gt; s;

    for (auto c : s)    sam.extend(c - &#39;a&#39;);

    sam.solve();
    return 0;
&#125;</code></pre>



<h3 id="3-求字符串-s-的最小表示法（循环同构字符串中字典序最小的一个）"><a href="#3-求字符串-s-的最小表示法（循环同构字符串中字典序最小的一个）" class="headerlink" title="3.求字符串 $s$ 的最小表示法（循环同构字符串中字典序最小的一个）"></a>3.求字符串 $s$ 的最小表示法（循环同构字符串中字典序最小的一个）</h3><p><mark>循环同构字符串最小表示法代码（求字符串 $s$ 的最小表示法（循环同构字符串中字典序最小的一个））：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 2e5 + 10;

int tot,last;
struct Node
&#123;
    int len,fa;
    int ch[26];
    void init()
    &#123;
        len &#x3D; fa &#x3D; 0;
        memset(ch,0,sizeof(ch));
    &#125;
&#125;node[N];

void extend(int c)
&#123;
    int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
    node[np].len &#x3D; node[p].len + 1;
    for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)
        node[p].ch[c] &#x3D; np;
    if(!p)  node[np].fa &#x3D; 1;
    else
    &#123;
        int q &#x3D; node[p].ch[c];
        if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
        else
        &#123;
            int nq &#x3D; ++ tot;
            node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
            node[q].fa &#x3D; node[np].fa &#x3D; nq;
            for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
        &#125;
    &#125;
&#125;

string get(string s)
&#123;
    for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
    tot &#x3D; last &#x3D; 1;
    
    for(auto c : s) extend(c - &#39;a&#39;);
    for(auto c : s) extend(c - &#39;a&#39;);

    string res;
    int p &#x3D; 1;
    for(int i &#x3D; 0;i &lt; s.size();i++)
    &#123;
        for(int j &#x3D; 0;j &lt; 26;j++)
            if(node[p].ch[j])
            &#123;
                p &#x3D; node[p].ch[j];
                res +&#x3D; char(j + &#39;a&#39;);
                break;
            &#125;
    &#125;
    return res;
&#125;

void solve()
&#123;
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;string&gt; str(n + 1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        string s;
        cin &gt;&gt; s;
        str[i] &#x3D; get(s);
    &#125;

    int q;
    cin &gt;&gt; q;

    while (q--)
    &#123;
        int a,b;
        cin &gt;&gt; a &gt;&gt; b;

        cout &lt;&lt; (str[a] &#x3D;&#x3D; str[b] ? &quot;Yes\n&quot; : &quot;No\n&quot;);
    &#125;
    
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>

<h3 id="4-求-s-的本质不同子串个数"><a href="#4-求-s-的本质不同子串个数" class="headerlink" title="4.求 $s$ 的本质不同子串个数"></a>4.求 $s$ 的本质不同子串个数</h3><p><strong>思路：</strong> 自动机的每个结点（1号点是空点，因此有效点只在 $[2,tot]$）都有一个 $minlen$ 和 $maxlen$ （结点内包含的串的长度从 $minlen$ 一直到 $maxlen$）。我们只记录了 $maxlen$，即 $Node$ 中的 $len$ 参数，其为该结点的最大长度。当然也有最小的长度，只不过可以通过 $fa$ 的链来找到，因为长度都是“无缝衔接”的，因此最小的 $minlen$ 是 $fa$ 链的最大值（即 $len$）+ 1。</p>
<p>因此答案即为自动机上每个点的 $maxlen - minlen+1$ 的总和，即：$\sum(maxlen-minlen + 1)$</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e6 * 2 + 10; &#x2F;&#x2F; 空间开2倍
struct SAM
&#123;
    int tot,last;
    struct Node
    &#123;
        int len,fa;
        int ch[26];
        void init()&#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch,0,sizeof(ch));
        &#125;
    &#125;node[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125;
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;

    void solve () &#123;
        ll res &#x3D; 0;
        for (int i &#x3D; 2; i &lt;&#x3D; tot; i++) &#123;
            res +&#x3D; (node[i].len - (node[node[i].fa].len + 1) + 1);
        &#125;
        cout &lt;&lt; res;
    &#125;
&#125;sam;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    cin &gt;&gt; s;
    for (auto c : s)    sam.extend(c - &#39;a&#39;);

    sam.solve();
    return 0;
&#125;</code></pre>



<h3 id="5-最长公共子串"><a href="#5-最长公共子串" class="headerlink" title="5.最长公共子串"></a>5.最长公共子串</h3><p><strong>思路：</strong></p>
<ul>
<li>对第一个串建立 $SAM$，即后缀自动机，之后遍历每个串，维护 $now$ 数组，表示后缀自动机的每个结点中，枚举的剩下 $n - 1$ 个字符串（中的其中一个字符串）与该结点匹配的最大长度。</li>
<li>匹配过程中，如果匹配不了就跳 $fa$ 链，类似于 $KMP$ 匹配，保证了时间复杂度。</li>
<li>与每个字符串匹配后得到的 $now$ 数组，由于 $now$ 的定义，比如对于后缀自动机的一个结点，第一次 $now$ 表示第 $2$ 个字符串与后缀自动机匹配的最大长度，那么第二次的 $now$ 是第 $3$ 个字符串与后缀自动机匹配的最大长度，因此需要满足都是公共的条件的话，就需要在所有该结点的 $now$ 中取个 $min$。</li>
<li>最后，由于每个取完 $min$ 的 $now$ 都是符合结果要求的（即为 $res$），那么只需取 $res$ 数组的最大值即为最大公共子串。</li>
</ul>
<p><strong>细节说明：</strong></p>
<ul>
<li>这里由于需要自下往上传递，$res$ 数组首先设置无穷大很正常，然后 $dfs$ 的时候不能简单的进行： $now[u] &#x3D; max(now[u],now[v])$，还需要本身与 $node[u].len$ 取个 $min$。个人感觉这才是最正常的想法，而 $y$ 总直接 $res$ 初始为 $node[u].len$ 感觉很突兀，虽然也是对的qwq。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e4 * 2 + 10; &#x2F;&#x2F; 空间开2倍

struct SAM
&#123;
    int tot,last;
    struct Node
    &#123;
        int len,fa;
        int ch[26];
        void init()&#123;&#x2F;&#x2F;结点初始化
            len &#x3D; fa &#x3D; 0;
            memset(ch,0,sizeof(ch));
        &#125;
    &#125;node[N];
    SAM() &#123;tot &#x3D; 1,last &#x3D; 1;&#125;
    void init() &#123;&#x2F;&#x2F;清空区间[1,tot]
        for(int i &#x3D; 1;i &lt;&#x3D; tot;i++) node[i].init();
        tot &#x3D; last &#x3D; 1;
    &#125;
    void extend(int c) &#123;&#x2F;&#x2F;添加一个字符(c - &#39;a&#39;)
        int p &#x3D; last,np &#x3D; last &#x3D; ++tot;
        node[np].len &#x3D; node[p].len + 1;
        for(;p &amp;&amp; !node[p].ch[c];p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; np;
        if(!p)  node[np].fa &#x3D; 1;
        else
        &#123;
            int q &#x3D; node[p].ch[c];
            if(node[q].len &#x3D;&#x3D; node[p].len + 1)   node[np].fa &#x3D; q;
            else
            &#123;
                int nq &#x3D; ++ tot;
                node[nq] &#x3D; node[q],node[nq].len &#x3D; node[p].len + 1;
                node[q].fa &#x3D; node[np].fa &#x3D; nq;
                for(;p &amp;&amp; node[p].ch[c] &#x3D;&#x3D; q;p &#x3D; node[p].fa)    node[p].ch[c] &#x3D; nq;
            &#125;
        &#125;
    &#125;
&#125;sam;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    for (auto c : s)    sam.extend(c - &#39;a&#39;);

    vector&lt;vector&lt;int&gt;&gt; g(N + 1);
    for (int i &#x3D; 2; i &lt;&#x3D; sam.tot; i++)  g[sam.node[i].fa].push_back(i);

    vector&lt;int&gt; res(N + 10, 1e9);
    for (int i &#x3D; 0; i &lt; n - 1; i++)
    &#123;
        cin &gt;&gt; s;
        vector&lt;int&gt; now(N + 10);
        function&lt;void(int)&gt; dfs &#x3D; [&amp;](int u) -&gt; void
        &#123;
            for (auto v : g[u]) 
            &#123;
                dfs(v);
                now[u] &#x3D; min(sam.node[u].len, max(now[u], now[v]));
            &#125;
        &#125;;
        int p &#x3D; 1, len &#x3D; 0;
        for (auto c : s)
        &#123;
            while (p &gt; 1 &amp;&amp; !sam.node[p].ch[c - &#39;a&#39;])   p &#x3D; sam.node[p].fa, len &#x3D; sam.node[p].len;
            if (sam.node[p].ch[c - &#39;a&#39;])    p &#x3D; sam.node[p].ch[c - &#39;a&#39;], len++;
            now[p] &#x3D; max(now[p], len);
        &#125;
        dfs(1);
        for (int i &#x3D; 1; i &lt;&#x3D; sam.tot; i++)  res[i] &#x3D; min(res[i], now[i]);
    &#125;

    cout &lt;&lt; *max_element(res.begin() + 1, res.begin() + sam.tot + 1) &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<hr>
<p>后缀自动机学了好几遍，总是难以理解，最后看了个视频，差不多理解每个变量的含义了，安利一下：<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV145411N7Qp?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=3d7e149b792ef13210101958098b6da2">[OI]完全搞懂后缀自动机(SAM)</a></p>
<p><strong>推荐博客：</strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/410131141">算法学习笔记(85): 后缀自动机</a></p>
<p><mark>推荐题单：</mark></p>
<p><strong>模板：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2768/">后缀自动机</a></p>
<p><strong>求本质不同子串个数：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/37092/H">本质不同子串个数</a></p>
<p><strong>最长公共子串：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2813/">最长公共子串</a></p>
<p><strong>线段树 + 后缀自动机：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33188/H">Hacker</a></p>
<p><strong>求解循环同构字符串的最小表示法：</strong><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7279">Cyclically Isomorphic</a></p>
<p><strong>$2023$ 湖南省省赛：</strong><a target="_blank" rel="noopener" href="https://cpc.csgrandeur.cn/csgoj/problemset/problem?pid=1199">1199 : Substrings Same as Prefix</a></p>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><blockquote>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e4 + 10, M &#x3D; N * 2;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
bool st[N];
int p[N], q[N];

void add(int a, int b, int c)
&#123;
    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

int get_size(int u, int fa)
&#123;
    if (st[u])   return 0;
    int res &#x3D; 1;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
        if (e[i] !&#x3D; fa) 
            res +&#x3D; get_size(e[i], u);
    return res;
&#125;

int get_wc(int u, int fa, int tot, int&amp; wc)
&#123;
    if (st[u])  return 0;
    int sum &#x3D; 1, ms &#x3D; 0;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if(j &#x3D;&#x3D; fa) continue;
        int t &#x3D; get_wc(j, u, tot, wc);
        ms &#x3D; max(ms, t);
        sum +&#x3D; t;
    &#125;
    ms &#x3D; max(ms, tot - sum);
    if (ms &lt;&#x3D; tot &#x2F; 2)   wc &#x3D; u;
    return sum;
&#125;

void get_dist(int u, int fa, int dist, int&amp; qt)
&#123;
    if (st[u])  return;
    q[qt ++] &#x3D; dist;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
        if(e[i] !&#x3D; fa)
            get_dist(e[i], u, dist + w[i], qt);
&#125;

int get(int a[], int k)
&#123;
    sort(a, a + k);
    int res &#x3D; 0;
    for (int i &#x3D; k - 1, j &#x3D; -1; i &gt;&#x3D; 0; i --)
    &#123;
        while (j + 1 &lt; i &amp;&amp; a[j + 1] + a[i] &lt;&#x3D; m)   j++;
        j &#x3D; min(j, i - 1);
        res +&#x3D; j + 1;
    &#125;
    return res;
&#125;

int calc(int u)
&#123;
    if (st[u])  return 0;
    int res &#x3D; 0;
    get_wc(u, -1, get_size(u, -1), u);
    st[u] &#x3D; true; &#x2F;&#x2F; 删除重心

    int pt &#x3D; 0;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i], qt &#x3D; 0;
        get_dist(j, -1, w[i], qt);
        res -&#x3D; get(q, qt);
        for (int k &#x3D; 0; k &lt; qt; k++)
        &#123;
            if(q[k] &lt;&#x3D; m)   res++;
            p[pt++] &#x3D; q[k];
        &#125;
    &#125;
    res +&#x3D; get(p, pt);

    for(int i &#x3D; h[u]; ~i; i &#x3D; ne[i])    res +&#x3D; calc(e[i]);
    return res;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    while (cin &gt;&gt; n &gt;&gt; m, n || m)
    &#123;
        memset(st, 0, sizeof(st));
        memset(h, -1, sizeof(h));
        idx &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n - 1; i++)
        &#123;
            int a, b, c;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            add(a, b, c),add(b, a, c);
        &#125;
        cout &lt;&lt; calc(0) &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark><br><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/254/">树</a></p>
<h2 id="动态树——LCT（link-cut-tree）"><a href="#动态树——LCT（link-cut-tree）" class="headerlink" title="动态树——LCT（link-cut-tree）"></a>动态树——LCT（link-cut-tree）</h2><p><strong>LCT</strong> 是用于解决 <strong>动态树问题</strong> 的数据结构。</p>
<blockquote>
<p><strong>动态树问题：</strong></p>
<p>维护一个森林，支持删除某条边，加入某条边，并保证加边，删边后仍是森林。我们要维护该森林的一些信息。<br>一般的操作有两点连通性， 两点路径权值和， 连接两点 和 切断某条边、修改信息 等</p>
</blockquote>
<p>LCT 则是用多个 Splay 来维护 多个实链，Splay 的特性就使得我们可以进行 树的合并、分割 操作。</p>
<p><strong>零散知识点：</strong></p>
<p>将所有边分为<mark>虚边</mark>和<mark>实边</mark>，用splay维护所有实边路径，其中序遍历就是要维护的路径。</p>
<p>splay本质上：维护所有实边，用splay中的后继与前驱来维护原树中的父子关系。</p>
<p>虚边：是用splay的根节点来维护。</p>
<p><strong>实链剖分：</strong></p>
<p>把树拆分成若干条实链，用splay这种动态数据结构来维护实链。通过对实链的拆分与组合，构造答案。</p>
<p>一个节点只能选一个儿子做实儿子，其他都是虚儿子。</p>
<p><strong>实边</strong>：父节点与实儿子之间的边，是双向边。</p>
<p><strong>虚边</strong>：由虚儿子指向父节点的边，是单向边。（<strong>认父不认子</strong>）</p>
<p><strong>实链</strong>：由实边构成的链。每条实链的节点深度是严格递增的。</p>
<p><strong>辅助树</strong>：由若干splay构成，与原树是等价的，只需要维护辅助树。</p>
<p><strong>性质：每条实链用一个splay维护，中序遍历按深度严格递增。</strong></p>
<p>注意：区分<strong>树根</strong>和<strong>splay的根</strong>。</p>
<p>一些辅助树构成了Link Cut Tree(LCT)，其维护的是整个森林。</p>
<p><img src="/images/6.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3690">【模板】动态树（Link Cut Tree）</a></p>
<p>给定 n 个点以及每个点的权值，要你处理接下来的 m个操作。<br>操作有四种，操作从 0 到 3 编号。点从 1 到 n 编号。</p>
<ul>
<li><code>0 x y</code> 代表询问从 x 到 y 的路径上的点的权值的 xor 和。保证 x 到 y 是联通的。</li>
<li><code>1 x y</code> 代表连接 x 到 y，若 x 到 y 已经联通则无需连接。</li>
<li><code>2 x y</code> 代表删除边 (<em>x</em>,y)，不保证边 (<em>x</em>,y) 存在。</li>
<li><code>3 x y</code> 代表将点 x上的权值变成 y。</li>
</ul>
<p><mark>代码模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

using namespace std;

const int N &#x3D; 1e5 + 10;

int n,m;
struct Node
&#123;
    int s[2],p,v;
    int sum,rev;&#x2F;&#x2F;sum:异或和,rev:旋转标记;
    &#x2F;&#x2F;这里的懒标记表示:当前结点已经旋转过了，但我的子树还未旋转(即我这个点的状态是懒标记操作之后的状态)
&#125;tr[N];
int stk[N];

void pushrev(int x)
&#123;
    swap(tr[x].s[0],tr[x].s[1]);
    tr[x].rev ^&#x3D; 1;
&#125;

void pushup(int x)
&#123;
    tr[x].sum &#x3D; tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;
&#125;

void pushdown(int x)
&#123;
    if(tr[x].rev)
    &#123;
        pushrev(tr[x].s[0]),pushrev(tr[x].s[1]);
        tr[x].rev &#x3D; 0;
    &#125;
&#125;

bool isroot(int x)  &#x2F;&#x2F;判断当前点是不是根节点
&#123;
    return tr[tr[x].p].s[0] !&#x3D; x &amp;&amp; tr[tr[x].p].s[1] !&#x3D; x;
&#125;

void rotate(int x)
&#123;
    int y &#x3D; tr[x].p,z &#x3D; tr[y].p;
    int k &#x3D; tr[y].s[1] &#x3D;&#x3D; x;
    if(!isroot(y))  tr[z].s[tr[z].s[1] &#x3D;&#x3D; y] &#x3D; x;&#x2F;&#x2F;如果y是根节点则不能更新y和它父节点的关系
    tr[x].p &#x3D; z;
    tr[y].s[k] &#x3D; tr[x].s[k ^ 1],tr[tr[x].s[k ^ 1]].p &#x3D; y;
    tr[x].s[k ^ 1] &#x3D; y,tr[y].p &#x3D; x;
    pushup(y),pushup(x);
&#125;

void splay(int x)   &#x2F;&#x2F;将x转到根节点
&#123;&#x2F;&#x2F;可能有从下往上的操作(即不是从上往下递归而来的),所以需要先将路径存到栈里，然后从上往下pushdown一遍
    int top &#x3D; 0,r &#x3D; x;
    stk[++top] &#x3D; r;
    while(!isroot(r))   stk[++top] &#x3D; r &#x3D; tr[r].p;
    while(top)  pushdown(stk[top--]);
    while(!isroot(x))
    &#123;
        int y &#x3D; tr[x].p,z &#x3D; tr[y].p;
        if(!isroot(y))
            if((tr[y].s[1] &#x3D;&#x3D; x) ^ (tr[z].s[1] &#x3D;&#x3D; y))   rotate(x);
            else    rotate(y);
        rotate(x);
    &#125;
&#125;

void access(int x)  &#x2F;&#x2F;建立一条从根到x的(实边)路径，同时将x变成splay的根节点
&#123;
    int z &#x3D; x;
    for(int y &#x3D; 0;x;y &#x3D; x,x &#x3D; tr[x].p)&#x2F;&#x2F;x沿着实边往上走
    &#123;
        splay(x);
        tr[x].s[1] &#x3D; y,pushup(x);
    &#125;
    splay(z);
&#125;

void makeroot(int x)    &#x2F;&#x2F;将x变成原树的根节点
&#123;
    access(x);
    pushrev(x);
&#125;

int findroot(int x) &#x2F;&#x2F;找到x所在原树的根节点，再将原树的根节点旋转到splay的根节点
&#123;
    access(x);
    while(tr[x].s[0])   pushdown(x),x &#x3D; tr[x].s[0];
    splay(x);
    return x;
&#125;

void split(int x,int y) &#x2F;&#x2F;给x和y之间的路径建立一个splay，其根节点是y
&#123;
    makeroot(x);
    access(y);
&#125;

void link(int x,int y)  &#x2F;&#x2F;如果x和y不连通，则加入一条x和y之间的边
&#123;
    makeroot(x);
    if(findroot(y) !&#x3D; x)    tr[x].p &#x3D; y;
&#125;

void cut(int x,int y)   &#x2F;&#x2F;如果x和y之间存在边，则删除该边
&#123;
    makeroot(x);
    if(findroot(y) &#x3D;&#x3D; x &amp;&amp; tr[y].p &#x3D;&#x3D; x &amp;&amp; !tr[y].s[0])
    &#123;
        tr[x].s[1] &#x3D; tr[y].p &#x3D; 0;
        pushup(x);
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;

    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; tr[i].v;
    while (m--)
    &#123;
        int t,x,y;
        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;
        if(t &#x3D;&#x3D; 0)
        &#123;
            split(x,y);
            cout &lt;&lt; tr[y].sum &lt;&lt; &quot;\n&quot;;
        &#125;
        else if(t &#x3D;&#x3D; 1) link(x,y);
        else if(t &#x3D;&#x3D; 2) cut(x,y);
        else
        &#123;
            splay(x);
            tr[x].v &#x3D; y;
            pushup(x);
        &#125;
    &#125;
    
    return 0;
&#125;</code></pre>

<h2 id="支配树"><a href="#支配树" class="headerlink" title="支配树"></a>支配树</h2><blockquote>
<p><strong>定义：</strong></p>
<p>对于一张有向图，我们确定一个起点 $S$，对于一个点 $k$，称 $x$ 为其支配点当且仅当，删去点 $x$ 后，$S$ 无法到达 $k$，即 $S$ 到达 $k$ 的所有路径都必须通过 $x$。</p>
<p>$Lengauer-Tarjan$ 算法分为三步：</p>
<ol>
<li>求出 $dfs$ 树，得到每个点 $k$ 的 $dfs$ 序 $d_k$。</li>
<li>求解半支配点。</li>
<li>求解支配点。</li>
</ol>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
<p><strong>使用指南：</strong></p>
<p>$idom[i]$ 数组：$i$ 的支配点是谁，即 $i$ 被谁支配；</p>
<p>$vector&lt;vector<int>&gt; domain_tree$：支配树（DAG），支配树上的点会被从根节点到该点上路径上所有的点所支配。</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct DominationTree&#x2F;&#x2F;支配树
&#123;
   int n,idx;
   vector&lt;vector&lt;int&gt;&gt; g,fg,hg,domain_tree;&#x2F;&#x2F;原图,反图,半支配树,支配树
   vector&lt;int&gt; dfn,ord,fa;&#x2F;&#x2F;ord:dfs序列;
   vector&lt;int&gt; uni,mn,idom,sdom;&#x2F;&#x2F;idom为支配点

   DominationTree(int _n):n(_n),idx(0),g(n + 1),fg(n + 1),hg(n + 1),domain_tree(n + 1)
   &#123;
       dfn.resize(n + 1),ord.resize(n + 1),fa.resize(n + 1);
       uni.resize(n + 1),mn.resize(n + 1),idom.resize(n + 1),sdom.resize(n + 1);
   &#125;
   void add(int a,int b)
   &#123;
       g[a].push_back(b);
       fg[b].push_back(a);
   &#125;
   void tarjan(int u)
   &#123;
       ord[dfn[u] &#x3D; ++idx] &#x3D; u;
       for(auto v : g[u])
           if(!dfn[v])
           &#123;
               fa[v] &#x3D; u;
               tarjan(v);
           &#125;
   &#125;
   int query_uni(int u)
   &#123;
       if(u &#x3D;&#x3D; uni[u]) return u;
       int res &#x3D; query_uni(uni[u]);
       if(dfn[sdom[mn[uni[u]]]] &lt; dfn[sdom[mn[u]]])    mn[u] &#x3D; mn[uni[u]];
       return uni[u] &#x3D; res;
   &#125;
   &#x2F;&#x2F;求以st为起点的所有点的支配点
   void contract(int st)
   &#123;
       tarjan(st);
       for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   sdom[i] &#x3D; uni[i] &#x3D; mn[i] &#x3D; i;
       for(int i &#x3D; idx;i &gt;&#x3D; 2;i--)
       &#123;
           int u &#x3D; ord[i];
           for(auto v : fg[u])
           &#123;
               if(!dfn[v]) continue;
               query_uni(v);
               if(dfn[sdom[mn[v]]] &lt; dfn[sdom[u]]) sdom[u] &#x3D; sdom[mn[v]];
           &#125;
           uni[u] &#x3D; fa[u];&#x2F;&#x2F;半支配点的求解过程
           hg[sdom[u]].push_back(u);&#x2F;&#x2F;维护半支配树
           for(auto v : hg[u &#x3D; fa[u]])
           &#123;
               query_uni(v);
               idom[v] &#x3D; u &#x3D;&#x3D; sdom[mn[v]] ? u : mn[v];
           &#125;
           hg[u].clear();
       &#125;

       for(int i &#x3D; 2;i &lt;&#x3D; idx;i++)
       &#123;
           int u &#x3D; ord[i];
           if(idom[u] ^ sdom[u])   idom[u] &#x3D; idom[idom[u]];
       &#125;

       &#x2F;&#x2F;建立支配树
       for(int i &#x3D; idx;i &gt;&#x3D; 2;i--)
           domain_tree[idom[ord[i]]].push_back(ord[i]);
       &#125;
&#125;;

int main()
&#123;
    DominationTree dtree(n);
    dtree.contract(1);&#x2F;&#x2F;调用(1为起点)
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5180">【模板】支配树</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/57357/E">Koraidon, Miraidon and DFS Shortest Path</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">重生带我走</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://318471543.github.io/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://318471543.github.io/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">重生带我走</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">数据结构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/08/%E6%95%B0%E8%AE%BA/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="数论">
                        
                        <span class="card-title">数论</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E8%AE%BA/">
                        <span class="chip bg-color">数论</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/08/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="好题精选">
                        
                        <span class="card-title">好题精选</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%A5%BD%E9%A2%98%E7%B2%BE%E9%80%89/">
                        <span class="chip bg-color">好题精选</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">重生带我走</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/318471543" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:318471543@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=318471543" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 318471543" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5545924159" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5545924159" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/shen-mu-yi-35" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/shen-mu-yi-35" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
