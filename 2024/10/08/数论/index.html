<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数论, 重生带我走">
    <meta name="description" content="线性筛法
又名：欧拉筛

封装模板：
vector&amp;lt;int&amp;gt; primes;
void init(int n)
&amp;#123;
	vector&amp;lt;int&amp;gt; st(n + 1);
	for (int i &amp;#x3D; 2;">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数论 | 重生带我走</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">重生带我走</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">重生带我走</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数论</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E8%AE%BA/">
                                <span class="chip bg-color">数论</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-10-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h2><blockquote>
<p>又名：<strong>欧拉筛</strong></p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; primes;
void init(int n)
&#123;
	vector&lt;int&gt; st(n + 1);
	for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
	&#123;
		if (!st[i])	primes.push_back(i);
		for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j++)
		&#123;
			st[primes[j] * i] &#x3D; true;
			if (i % primes[j] &#x3D;&#x3D; 0)	break;
		&#125;
	&#125;
&#125;</code></pre>

<p><mark>模板代码：</mark></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e8</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> primes<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">;</span>
<span class="token keyword">bool</span> st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">get_prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token comment">//线性筛法</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  primes<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">/</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//从小到大枚举所有的质数</span>
        <span class="token punctuation">&#123;</span>
            st<span class="token punctuation">[</span>primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> primes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//prime[j]一定是i的最小质因子</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>
    <span class="token function">get_prime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/870/">筛质数</a></p>
<h2 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h2><h3 id="应用1：获取每个数的最大质因数"><a href="#应用1：获取每个数的最大质因数" class="headerlink" title="应用1：获取每个数的最大质因数"></a>应用1：获取每个数的最大质因数</h3><blockquote>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
<p><strong>方法：</strong>埃氏筛</p>
</blockquote>
<p><mark>封装代码：$(show\ by\ jiangly)$</mark></p>
<blockquote>
<p>$minp$：最小质因数</p>
<p>$maxp$：最大质因数</p>
<p>$cntp$：质因数个数</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt; minp, cntp, maxp, primes;
 
void sieve(int n) &#123;
    minp.assign(n + 1, 0);
    maxp.assign(n + 1, 0);
    cntp.assign(n + 1, 0);
    primes.clear();
    
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
        if (minp[i] &#x3D;&#x3D; 0) &#123;
            minp[i] &#x3D; i;
            maxp[i] &#x3D; i;
            cntp[i] &#x3D; 1;
            primes.push_back(i);
        &#125;
        
        for (auto p : primes) &#123;
            if (i * p &gt; n) &#123;
                break;
            &#125;
            minp[i * p] &#x3D; p;
            maxp[i * p] &#x3D; maxp[i];
            cntp[i * p] &#x3D; cntp[i] + 1;
            if (p &#x3D;&#x3D; minp[i]) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><mark>简单代码（容易理解版）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 2e6 + 10;
int f[N];&#x2F;&#x2F; f:每个数的最大质因数是多少
void init()
&#123;
	for (int i &#x3D; 2; i &lt;&#x3D; 2e6; i++) 
	&#123;
		if (!f[i]) 
		&#123;
			f[i] &#x3D; i;
			for (int j &#x3D; 2 * i; j &lt;&#x3D; 2e6; j +&#x3D; i)	f[j] &#x3D; i;
		&#125;
	&#125;
&#125;</code></pre>

<p><mark>题单推荐：</mark></p>
<p><strong>埃氏筛求最大质因数 + RMQ：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104493/problem/B">B. Convarge To 1</a></p>
<p><mark>埃氏筛求最大质因数 + RMQ 代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; pii;

const int N &#x3D; 2e6 + 10;
int f[N];&#x2F;&#x2F; f:每个数的最大质因数是多少

void init()
&#123;
	for (int i &#x3D; 2; i &lt;&#x3D; 2e6; i++) 
	&#123;
		if (!f[i]) 
		&#123;
			f[i] &#x3D; i;
			for (int j &#x3D; 2 * i; j &lt;&#x3D; 2e6; j +&#x3D; i)	f[j] &#x3D; i;
		&#125;
	&#125;
&#125;

void solve()
&#123;
	int n, q;
	cin &gt;&gt; n &gt;&gt; q;

	vector&lt;int&gt; a(n + 1);
	vector&lt;int&gt; time(n + 1);
	vector&lt;vector&lt;int&gt;&gt; nums(2e6 + 10);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	
	&#123;
		cin &gt;&gt; a[i];
		if (a[i] !&#x3D; 1)
			nums[a[i]].push_back(i);
	&#125;
	
	int timestamps &#x3D; 0;
	for (int i &#x3D; 2e6; i &gt;&#x3D; 2; i--)
	&#123;
		if (!nums[i].size())	continue;

		int nt &#x3D; i &#x2F; f[i];
		if (nt &#x3D;&#x3D; 1) &#x2F;&#x2F; 质数
		&#123;
			sort(nums[i].begin(), nums[i].end());
			for (int j &#x3D; 0; j &lt; nums[i].size(); j++)
			&#123;
				timestamps++;
				time[nums[i][j]] &#x3D; timestamps;
			&#125;
		&#125;
		else
		&#123;
			timestamps +&#x3D; nums[i].size();
			for (auto x : nums[i])
				nums[nt].push_back(x);
		&#125;
	&#125;

	vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(22));
	vector&lt;int&gt; LG2(n + 1);
	auto _init &#x3D; [&amp;]() -&gt; void
	&#123;
		LG2[1] &#x3D; 0;
		for(int i &#x3D; 2;i &lt;&#x3D; n;i++)   LG2[i]  &#x3D;LG2[i &gt;&gt; 1] + 1;
 
		for(int j &#x3D; 0;j &lt;&#x3D; LG2[n];j++)
			for(int i &#x3D; 1;i + (1 &lt;&lt; j) - 1 &lt;&#x3D; n;i++)
				if(!j)  f[i][j] &#x3D; time[i];
				else    f[i][j] &#x3D; max(f[i][j - 1],f[i + (1 &lt;&lt; j - 1)][j - 1]);  
		return ;
	&#125;;
	auto query &#x3D; [&amp;](int l, int r) -&gt; int
	&#123;
		int k &#x3D; LG2[r - l + 1];
		return max(f[l][k],f[r - (1 &lt;&lt; k) + 1][k]);
	&#125;;
 
	_init();
 
	while (q--)
	&#123;
		int l, r;
		cin &gt;&gt; l &gt;&gt; r;
 
		cout &lt;&lt; query(l, r) &lt;&lt; &quot;\n&quot;;
	&#125;
	
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);
	
	init();

	solve();
	
	return 0;
&#125;</code></pre>

<h3 id="应用2：高效质因数分解"><a href="#应用2：高效质因数分解" class="headerlink" title="应用2：高效质因数分解"></a>应用2：高效质因数分解</h3><p>这里有个结论：<mark>前 $N$ 个数的质数个数近似为：$\frac{N}{lnN}$</mark></p>
<p>于是乎，前 $\sqrt{1e9}$ 里面有 $3401$ 个质数，前 $1e5$ 里面有 $9592$ 个质数。 </p>
<blockquote>
<p><strong>时间复杂度：</strong>$O(\frac{\sqrt{n}}{ln(\sqrt{n})})$</p>
<p><strong>方法：</strong>线性筛优化加速</p>
<p>普通的试除法求质数的复杂度是：$O(\sqrt n)$，我们预处理了所有质数后，就是利用 $\sqrt n$ 里面的质数去筛，因此前 $\sqrt n$ 的质数近似为：$\frac{\sqrt n}{ln\sqrt n}$，故此为时间复杂度。</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

vector&lt;int&gt; primes;
void init(int n)
&#123;
	vector&lt;int&gt; st(n + 1);
	for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
	&#123;
		if (!st[i])	primes.push_back(i);
		for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j++)
		&#123;
			st[primes[j] * i] &#x3D; true;
			if (i % primes[j] &#x3D;&#x3D; 0)	break;
		&#125;
	&#125;
&#125;

void solve()
&#123;
	int n;
	cin &gt;&gt; n;

	vector&lt;int&gt; a(n + 1);
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	cin &gt;&gt; a[i];

	map&lt;int, int&gt; mp;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
		int x &#x3D; a[i];
		for (auto p : primes)
		&#123;
			if (p * p &gt; x)	break;
			if (x % p &#x3D;&#x3D; 0)
			&#123;
				mp[p]++;
				while (x % p &#x3D;&#x3D; 0)	x &#x2F;&#x3D; p;
			&#125;
		&#125;
		if (x &gt; 1)	mp[x]++;
	&#125;

	for (auto [x, y] : mp)
		if (y &gt; 1)
			return cout &lt;&lt; &quot;YES\n&quot;, void();
	cout &lt;&lt; &quot;NO\n&quot;;
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	init(sqrt(1e9));
	
	int t;
	cin &gt;&gt; t;

	while (t--)
	&#123;
		solve();
	&#125;
	
	return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1771/problem/C">C. Hossam and Trainees</a></p>
<p><strong>2023 西安区域赛铜牌题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/476283/problem/G">G. An Easy Math Problem</a></p>
<p><mark>西安铜牌题：$G. An Easy Math Problem$ 思路：</mark></p>
<ul>
<li>$10^{10}$ 内筛质数，利用高效筛法，时间复杂度为：$O(10^4)$；</li>
<li>共有 $2000$ 次询问，因此总时间复杂度：$O(2\times10^7)$，这里用数字表示。</li>
</ul>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h3><h4 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h4><blockquote>
<p><strong>时间复杂度：</strong> $O(\sqrt{N})$</p>
</blockquote>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; get_divivors(int n)
&#123;
    vector&lt;int&gt;res;
    for(int i &#x3D; 1; i &lt;&#x3D; n &#x2F; i; i++)
    &#123;
        if(n % i &#x3D;&#x3D; 0)
        &#123;
            res.push_back(i);
            if(i !&#x3D; n &#x2F; i)  res.push_back(n &#x2F; i);
        &#125;
    &#125;
    return res;
&#125;</code></pre>

<h4 id="埃氏筛求约数"><a href="#埃氏筛求约数" class="headerlink" title="埃氏筛求约数"></a>埃氏筛求约数</h4><blockquote>
<p><strong>时间复杂度：</strong>$O(NlogN)$</p>
</blockquote>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 2e5 + 10;
vector&lt;int&gt; factor[N];
void get_divivors(int n)
&#123;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    	for (int j &#x3D; i; j &lt;&#x3D; n; j +&#x3D; i) 
            factor[j].emplace_back(i);
&#125;</code></pre>



<h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><blockquote>
<p><strong>模板题题意：</strong>给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数个数，答案对 $10^9+7$ 取模。</p>
<p><strong>结论：</strong> 若数为：$N &#x3D; p_1^{a_1}\times p_2^{a_2}\times \cdots \times p_k^{a_k}$，则答案即为：$(a_1 + 1)(a_2+1)\cdots(a_k+1)$</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;
typedef long long ll;

const int mod &#x3D; 1e9+7;

int main()
&#123;
    int n;
    cin &gt;&gt; n;
    unordered_map&lt;ll,ll&gt; primes;
    while (n--)
    &#123;
        int x;
        cin &gt;&gt; x;
        for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i++)
        &#123;
            if(x % i &#x3D;&#x3D; 0)
            &#123;
                while(x % i &#x3D;&#x3D; 0)
                &#123;
                    x &#x2F;&#x3D; i;
                    primes[i]++;
                &#125;
            &#125;
        &#125;
        if(x &gt; 1)   primes[x]++;
    &#125;
    ll res &#x3D; 1;
    for(auto prime : primes)
    &#123;
        res &#x3D; res * (prime.second + 1) % mod;
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<p><mark>典题代码：</mark></p>
<blockquote>
<p><strong>题意：</strong>共有 $N$ 个整数 $a_1,a_2,\cdots,a_n$，对于每一个数 $a_i$，求其他的数中有多少个是它的约数。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

const int N &#x3D; 1e6 + 10;

int n;
int a[N],cnt[N],s[N];

int main()
&#123;
    cin &gt;&gt; n;
    for(int i &#x3D; 0;i &lt; n;i++)
    &#123;
        cin &gt;&gt; a[i];
        cnt[a[i]]++;
    &#125;
    
    for(int i &#x3D; 1;i &lt; N;i++)
        for(int j &#x3D; i;j &lt; N;j +&#x3D; i)
            s[j] +&#x3D; cnt[i];
            
    for(int i &#x3D; 0;i &lt; n;i++)    cout &lt;&lt; s[a[i]] - 1 &lt;&lt; &#39;\n&#39;;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/872/">约数个数</a></p>
<p><strong>典题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1293/">轻拍牛头</a></p>
<h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><blockquote>
<p><strong>模板题题意：</strong>给定 $n$ 个正整数 $a_i$，请你输出这些数的乘积的约数之和，答案对 $10^9+7$ 取模。</p>
<p><strong>结论：</strong>若数为：$N &#x3D; p_1^{a_1}\times p_2^{a_2}\times \cdots \times p_k^{a_k}$，则答案即为：$(p_1^{0} + p_2^{1} + \cdots \ p_1^{a_1})\times \cdots \times (p_k^{0} + p_k^{1} + \cdots \ p_k^{a_k})$</p>
<p><strong>实现技巧：</strong> <code>while(b--)	t = (t * a + 1) % mod</code></p>
<p><strong>举例：</strong></p>
<ul>
<li>$t &#x3D; 1$</li>
<li>$t &#x3D; p + 1$</li>
<li>$t &#x3D; p^2 + p + 1$</li>
<li>$\cdots$</li>
<li>$t &#x3D; p^b + p^{b - 1} + \cdots + 1$</li>
</ul>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int mod &#x3D; 1e9+7;
unordered_map&lt;int,int&gt; primes;
typedef long long ll;
int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        for(int i &#x3D; 2;i &lt;&#x3D; x &#x2F; i;i++)
        &#123;
            while(x % i &#x3D;&#x3D; 0)
            &#123;
                x &#x2F;&#x3D; i;
                primes[i]++;
            &#125;
        &#125;
        if(x &gt; 1)   primes[x]++;
    &#125;
    ll res &#x3D; 1;
    for(auto i : primes)
    &#123;
        ll t &#x3D; 1;
        int a &#x3D; i.first,b &#x3D; i.second;
        while(b--)
        &#123;
            t &#x3D; (t * a + 1) % mod;
        &#125;
        res &#x3D; res * t % mod;
    &#125;
    printf(&quot;%d\n&quot;,res);
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/873/">约数之和</a></p>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p><mark>模板代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

int gcd(int a,int b)
&#123;
    return b ? gcd(b,a % b) : a;
&#125;

int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while (n--)
    &#123;
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,gcd(a,b));
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/874/">最大公约数</a></p>
<h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><blockquote>
<p>当方程符合 $ax + by &#x3D; gcd(a,b)$ 时，可以用扩展欧几里得算法求 $(x_0,y_0)$。</p>
<p>通解（不妨令 $d$ 为 $gcd(a,b)$，其中 $c$ 为任意整数）：</p>
<ul>
<li>$x &#x3D; x_0 + \frac{b}{d}c$</li>
<li>$y &#x3D; y_0 - \frac{a}{d}c$</li>
</ul>
<p><strong>注意：</strong> <mark>参数必须保证都是正数！</mark></p>
</blockquote>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)
&#123;
    if(!b)
    &#123;
        x &#x3D; 1,y &#x3D; 0;
        return a;
    &#125;
    ll d &#x3D; exgcd(b,a % b,y,x);
    y -&#x3D; a &#x2F; b * x;
    return d;
&#125;</code></pre>

<p><mark>最精简（参考jiangly）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">array&lt;ll,3&gt; exgcd(ll a,ll b)
&#123;
    if(!b)  return &#123;a,1,0&#125;;&#x2F;&#x2F;d,x,y
    auto [d,x,y] &#x3D; exgcd(b,a % b);
    return &#123;d,y,x - a &#x2F; b * y&#125;;
&#125;</code></pre>

<p><strong>题单推荐：</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104008/problem/E">Draw a triangle</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104076/problem/E">2022 International Collegiate Programming Contest, Jinan Site</a></p>
<p><strong>$2023$ 湖北省省赛金牌题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104337/problem/I">I. Step</a></p>
<hr>
<p><mark>湖北省省赛 $Step$ 题思路：</mark></p>
<ul>
<li>首先，需要满足：$\frac{k(k+1)}{2} &#x3D; lcm(p_1,p_2,\cdots,p_n)$：<ul>
<li>即 $k(k+1) &#x3D; 2\times lcm$；</li>
<li>显然 $k$ 与 $k + 1$ 互质；</li>
<li>因此对 $2\times lcm$ 分解质因数，其中的每个质因子一定来自于不同的数（即要么是 $k$，要么是 $k+1$）；</li>
<li>有一个性质：$\prod p_i &lt;&#x3D; 10^{18}$，从最小的质数开始连乘的话，只需要 $m &#x3D; 15$ 个不同的质数，因此可以枚举这 $15$ 个质数分别属于谁的质因子，时间复杂度：$O(2^m)$。</li>
</ul>
</li>
<li>然后，对于枚举获取的两个数 $a,b$，需要满足：$k &#x3D; ax, k + 1 &#x3D; by$：<ul>
<li>则有等式：$by - ax &#x3D; 1$；</li>
<li>因为 $a,b$ 互质，因此 $gcd(a,b) &#x3D; 1$ 满足条件；</li>
<li>直接利用扩展欧几里得算法即可，注意参数必须都是正整数，然后求得的结果再取个反，找到最小的 $x$ 就行了；</li>
<li>答案即为最小的 $k$，即枚举获取最小的 $k &#x3D; ax$。</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

vector&lt;int&gt; get_prime(int n)&#x2F;&#x2F;线性筛法
&#123;
    vector&lt;int&gt; primes;
    vector&lt;bool&gt; st(n + 1);
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
    &#123;
        if(!st[i])  primes.push_back(i);
        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j++)
        &#123;
            st[primes[j] * i] &#x3D; true;
            if(i % primes[j] &#x3D;&#x3D; 0)  break;
        &#125;
    &#125;
    return primes;
&#125;

ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)
&#123;
    if(!b)
    &#123;
        x &#x3D; 1,y &#x3D; 0;
        return a;
    &#125;
    ll d &#x3D; exgcd(b,a % b,y,x);
    y -&#x3D; a &#x2F; b * x;
    return d;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    cin &gt;&gt; a[i];

    &#x2F;&#x2F; 质因数分解
    auto primes &#x3D; get_prime(1e7);
    map&lt;int, int&gt; mp;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        ll x &#x3D; a[i];
        for (int j &#x3D; 0; j &lt; primes.size(); j++)
        &#123;
            int p &#x3D; primes[j];
            if ((ll)p * p &gt; x)    break; 
            int cnt &#x3D; 0;
            while (x % p &#x3D;&#x3D; 0)
            &#123;
                x &#x2F;&#x3D; p;
                cnt++;
            &#125;
            if (cnt)    mp[p] &#x3D; max(mp[p], cnt);
        &#125;
        if (x &gt; 1)    mp[x] &#x3D; max(mp[x], 1);
    &#125;

    mp[2]++; &#x2F;&#x2F; 2倍
    map&lt;int, ll&gt; num;
    for (auto [x, y] : mp)
    &#123;
        ll t &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; y; i++)    t *&#x3D; x;
        num[x] &#x3D; t;
    &#125;

    &#x2F;&#x2F; 枚举质因数
    vector&lt;int&gt; v;
    for (auto [x, y] : mp)  
        v.push_back(x);

    int cnt &#x3D; v.size();
    ll ans &#x3D; 1e18;
    for (int i &#x3D; 0; i &lt; 1 &lt;&lt; cnt; i++)
    &#123;
        ll a &#x3D; 1, b &#x3D; 1;
        for (int j &#x3D; 0; j &lt; cnt; j++)
        &#123;
            if (i &gt;&gt; j &amp; 1) a *&#x3D; num[v[j]];
            else    b *&#x3D; num[v[j]];
        &#125;

        &#x2F;&#x2F; 判断a, b
        &#x2F;&#x2F; ax - by &#x3D; 1
        ll x, y;
        exgcd(a, b, x, y);
        ll res &#x3D; (-y % a + a) % a;
        if (!res)   res &#x3D; a;
        ans &#x3D; min(ans, res * b);
    &#125;

    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;

    return 0;
&#125;</code></pre>



<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><blockquote>
<p>$1$ ∼ $N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $ϕ(N)$。<br>若在算数基本定理中，$N&#x3D;p_1^{a_1}p_2^{a_2}…p_m^{a_m}$，则：<br>$ϕ(N) &#x3D; N×\frac{p_1−1}{p_1}×\frac{p_2−1}{p_2}×…×\frac{p_m−1}{p_m}$</p>
<p><strong>欧拉定理：</strong>若 $gcd(a,p) &#x3D; 1$，则 $a^{ϕ(p)} ≡ 1(mod\ p)$</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">auto get_euler &#x3D; [&amp;](ll x) -&gt; ll
&#123;
    ll res &#x3D; x;
    for(int i &#x3D; 2;i &lt;&#x3D; x &#x2F; i;i++)
        if(x % i &#x3D;&#x3D; 0)
        &#123;
            res &#x3D; res &#x2F; i * (i - 1);
            while(x % i &#x3D;&#x3D; 0)   x &#x2F;&#x3D; i;
        &#125;
    if(x &gt; 1)   res &#x3D; res &#x2F; x * (x - 1);
    return res;
&#125;;</code></pre>

<p><strong>模板题：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/875/">欧拉函数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/876/">筛法求欧拉函数</a></p>
<h3 id="扩展欧拉定理（欧拉降幂）"><a href="#扩展欧拉定理（欧拉降幂）" class="headerlink" title="扩展欧拉定理（欧拉降幂）"></a>扩展欧拉定理（欧拉降幂）</h3><p>$$<br>a^b\equiv<br>\begin{cases}<br>a^{b\bmod\varphi(p)},,&amp;\gcd(a,,p)&#x3D;1\<br>a^b,&amp;\gcd(a,,p)\ne1,,b&lt;\varphi(p)\<br>a^{b\bmod\varphi(p)+\varphi(p)},&amp;\gcd(a,,p)\ne1,,b\ge\varphi(p)<br>\end{cases}<br>\pmod p<br>$$</p>
<p><mark>模板题代码：</mark></p>
<ul>
<li>题意：给定整数 $x,y$，请输出 $x^y\ mod\ p$ 的值。（$0\le x\le 10^5,0\le y \le 10^{100000},10^5\le p\le 10^9 + 7$）</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

ll fpow(ll a,ll b,ll mod)
&#123;
   ll res &#x3D; 1;
   a %&#x3D; mod;
   while(b)
   &#123;
       if(b &amp; 1)   res &#x3D; res * a % mod;
       a &#x3D; a * a % mod;
       b &gt;&gt;&#x3D; 1;
   &#125;
   return res;
&#125;

ll gcd(ll a,ll b)
&#123;
    return b ? gcd(b,a % b) : a;
&#125;

void solve()
&#123;
    auto get_euler &#x3D; [&amp;](ll x) -&gt; ll
    &#123;
        ll res &#x3D; x;
        for(int i &#x3D; 2;i &lt;&#x3D; x &#x2F; i;i++)
            if(x % i &#x3D;&#x3D; 0)
            &#123;
                res &#x3D; res &#x2F; i * (i - 1);
                while(x % i &#x3D;&#x3D; 0)   x &#x2F;&#x3D; i;
            &#125;
        if(x &gt; 1)   res &#x3D; res &#x2F; x * (x - 1);
        return res;
    &#125;;

    ll a,p;
    string s;
    cin &gt;&gt; a &gt;&gt; s &gt;&gt; p;
    ll b &#x3D; 0,phi &#x3D; get_euler(p);

    bool ok &#x3D; false;
    for(int i &#x3D; 0;i &lt; s.size();i++)
    &#123;
        b &#x3D; b * 10 + s[i] - &#39;0&#39;;
        if(b &gt;&#x3D; phi)
        &#123;
            b %&#x3D; phi;
            ok &#x3D; true;
        &#125;
    &#125;
    if(ok)  b +&#x3D; phi;
    cout &lt;&lt; fpow(a,b,p) &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/30825/J">大数乘法</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33540/E">西楼暮，一帘疏雨</a></p>
<h2 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h2><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中$m_1,m_2,…m_k$两两互质)：<br>$$<br>f_{[i][j]} &#x3D;<br>\left{<br>\begin{array}{rcl}<br>x       &amp;  	\equiv    &amp; a_1(mod;m_1)\<br>x       &amp;   \equiv    &amp; a_2(mod;m_2)\<br>       &amp;   \vdots    &amp; 				 \<br>x       &amp;   \equiv    &amp; a_k(mod; m_k)\<br>\end{array} \right.<br>$$<br><mark>求x的过程：</mark></p>
<ul>
<li>计算所有模数的乘积M</li>
<li>对于第i个方程：<ul>
<li>计算$M_i &#x3D; \frac{M}{m_i}$</li>
<li>计算$M_i$在模$n_i$意义下的逆元$M_i^{-1}$</li>
</ul>
</li>
<li>方程组在模M意义下的唯一解为：$x &#x3D; \sum_{i&#x3D;1}^{k}a_iM_iM_i^{-1}(mod;n)$</li>
</ul>
<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/206/">表达整数的奇怪方式</a></p>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 110;
const double eps &#x3D; 1e-8;

int n;
double a[N][N];

int gauss()
&#123;
    int r,c;
    for(r &#x3D; 1,c &#x3D; 1;c &lt;&#x3D; n;c++)&#x2F;&#x2F;行:row;列:column
    &#123;
        &#x2F;&#x2F;找主元
        int t &#x3D; r;
        for(int i &#x3D; r + 1;i &lt;&#x3D; n;i++)
            if(abs(a[i][c]) &gt; abs(a[t][c])) 
                t &#x3D; i;

        if(abs(a[t][c]) &lt; eps)  continue;

        &#x2F;&#x2F;交换
        if(t !&#x3D; r)  swap(a[r],a[t]);

        &#x2F;&#x2F;消
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        &#123;
            if(i !&#x3D; r &amp;&amp; abs(a[i][c]) &gt; eps)
            &#123;
                double delta &#x3D; a[i][c] &#x2F; a[r][c];
                for(int k &#x3D; c;k &lt;&#x3D; n + 1;k++)
                &#123;
                    a[i][k] -&#x3D; delta * a[r][k];
                &#125;
            &#125;
        &#125;
        r++;

    &#125;

    if(r &lt;&#x3D; n)
    &#123;
        for(int i &#x3D; r;i &lt;&#x3D; n;i++)
            if(abs(a[i][n + 1]) &gt; eps)
                return -1;&#x2F;&#x2F;无解
    
        return -2;&#x2F;&#x2F;无穷解
    &#125;
    &#x2F;&#x2F;转换成单位矩阵
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
    &#123;
        a[i][n + 1] &#x2F;&#x3D; a[i][i];
        if(abs(a[i][n + 1]) &lt; eps)&#x2F;&#x2F;修正出现-0.00的情况
            a[i][n + 1] &#x3D; 0;
    &#125;
    
    return 0;
&#125;

int main()
&#123;
    cin &gt;&gt; n;
    
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)
        for(int j &#x3D; 1;j &lt;&#x3D; n + 1;j++)
            cin &gt;&gt; a[i][j];

    int t &#x3D; gauss();
    if(t &#x3D;&#x3D; -1) cout &lt;&lt; &quot;No solution&quot; &lt;&lt; &quot;\n&quot;;
    else if(t &#x3D;&#x3D; -2) cout &lt;&lt; &quot;Infinite group solutions&quot; &lt;&lt; &quot;\n&quot;;
    else
    &#123;
        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   
            cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; a[i][n + 1] &lt;&lt; &quot;\n&quot;;
    &#125;

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/885/">高斯消元解线性方程组</a></p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><blockquote>
<p><strong>前置知识点：</strong></p>
<p>$C_n^m &#x3D; \frac{n!}{m!(n - m)!}$</p>
<p>$A_n^m &#x3D; n(n-1)(n-2)\cdots (n-m+1) &#x3D; \frac{n!}{(n-m)!}$</p>
<p>$C_{n}^{m} &#x3D; C_{n}^{n-m}$</p>
<p>$C_{n}^{m} &#x3D; C_{n-1}^{m-1} + C_{n-1}^{m}$</p>
</blockquote>
<h3 id="组合数I"><a href="#组合数I" class="headerlink" title="组合数I"></a>组合数I</h3><blockquote>
<p><strong>计算：</strong>$C_a^{b}\ %\ mod$，其中 $1 \le b \le a \le 2000$ </p>
<p><strong>方法：</strong>递推：$C_{a}^{b} &#x3D; C_{a - 1}^{b - 1} + C_{a - 1}^{b}$</p>
<p><strong>时间复杂度：</strong>$O(n^2)$ </p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 2010,mod &#x3D; 1e9+7;

int c[N][N];

void init()
&#123;
    for(int i &#x3D; 0;i &lt; N;i++)
        for(int j &#x3D; 0;j &lt;&#x3D; i;j++)
            if(!j)  c[i][j] &#x3D; 1;
            else    c[i][j] &#x3D; (c[i-1][j] + c[i-1][j-1]) % mod;
&#125;

int main()
&#123;
    init();

    int n;
    scanf(&quot;%d&quot;,&amp;n);

    while (n--)
    &#123;
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,c[a][b]);
    &#125;
    
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/887/">https://www.acwing.com/problem/content/887/</a></p>
<h3 id="组合数II"><a href="#组合数II" class="headerlink" title="组合数II"></a>组合数II</h3><blockquote>
<p><strong>计算：</strong>$C_a^{b}\ %\ mod$，其中 $1 \le b \le a \le 10^5$ </p>
<p><strong>方法：</strong>公式：$C_{a}^{b} &#x3D; \frac{a!}{b!(a - b)!}$</p>
<p><strong>时间复杂度：</strong>$O(nlog(mod))$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 1e5+10,mod &#x3D; 1e9 + 7;

int fact[N],infact[N];

ll fpow(ll a,ll b)
&#123;
    ll res &#x3D; 1;
    while (b)
    &#123;
        if(b &amp; 1)   res &#x3D; res * a % mod;
        a &#x3D; a * a % mod;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

int main()
&#123;
    fact[0] &#x3D; infact[0] &#x3D; 1;&#x2F;&#x2F;0的阶乘都是1
    for(int i &#x3D; 1;i &lt; N;i++)
    &#123;
        fact[i] &#x3D; (ll)fact[i-1] * i % mod;&#x2F;&#x2F;预处理阶乘
        infact[i] &#x3D; (ll)fpow(fact[i],mod-2);&#x2F;&#x2F;预处理阶乘的逆元
    &#125;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    while (n--)
    &#123;
        int a,b;
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,(ll)fact[a]*infact[b] % mod * infact[a-b] % mod);&#x2F;&#x2F;公式得出
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/888/">求组合数 II</a></p>
<h3 id="组合数III"><a href="#组合数III" class="headerlink" title="组合数III"></a>组合数III</h3><blockquote>
<p><strong>计算：</strong>$C_a^{b}\ %\ mod$，其中 $1 \le b \le a \le 10^{18}$，$mod$ 为质数。</p>
<p><strong>$Lucas$ 定理：</strong>$C_n^m &#x3D; C_{n % p}^{m % p} \times C_{\frac{n}{p}}^{\frac{m}{p}} (mod\ p)$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

typedef long long ll;

int p;

ll fpow(ll a,ll b)
&#123;
    ll res &#x3D; 1;
    while (b)
    &#123;
        if(b&amp;1) res &#x3D; res * a % p;
        a &#x3D; a * a % p;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

int C(int a,int b)
&#123;
    int res &#x3D; 1;
    for (int i &#x3D; 1, j &#x3D; a; i &lt;&#x3D; b;i++,j--)
    &#123;
        res &#x3D; (ll)res * j % p;
        res &#x3D; (ll)res * fpow(i,p-2) % p;
    &#125;
    return res;

&#125;

int lucas(ll a,ll b)
&#123;
    if(a &lt; p &amp;&amp; b &lt; p)  return C(a,b);
    return (ll)C(a % p,b % p) * lucas(a &#x2F; p,b &#x2F; p) % p;
&#125;

int main()
&#123;
    int n;
    cin &gt;&gt; n;
    while (n--)
    &#123;
        ll a,b;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
        cout &lt;&lt; lucas(a,b) &lt;&lt; endl;
    &#125;
    return 0;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/889/">求组合数 III</a></p>
<h3 id="组合数IV"><a href="#组合数IV" class="headerlink" title="组合数IV"></a>组合数IV</h3><blockquote>
<p>输入 $a,b$，求 $C_a^b$ 的值（$1\le b \le a \le 5000$）。由于结果很大，需要使用高精度计算。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;


using namespace std;

const int N &#x3D; 5010;

int primes[N],cnt;
int sum[N];&#x2F;&#x2F;当前这个数包含的p的次数是多少
bool st[N];

void get_primes(int n)
&#123;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
    &#123;
        if(!st[i])  primes[cnt++] &#x3D; i;
        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j++)
        &#123;
            st[primes[j] * i] &#x3D; true;
            if(i % primes[j] &#x3D;&#x3D; 0)  break;
        &#125;
    &#125;
&#125;

int get(int n,int p)&#x2F;&#x2F;求n的阶乘中包含p的个数
&#123;
    int res &#x3D; 0;
    while(n)
    &#123;
        res +&#x3D; n &#x2F; p;
        n &#x2F;&#x3D; p;
    &#125;
    return res;
&#125;

vector&lt;int&gt; mul(vector&lt;int&gt; a,int b)
&#123;
    vector&lt;int&gt; C;
    int t &#x3D; 0;
    for (int i &#x3D; 0; i &lt; a.size(); i++)
    &#123;
        t +&#x3D; a[i] * b;
        C.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;
    while(t)
    &#123;
        C.push_back(t % 10);
        t &#x2F;&#x3D; 10;
    &#125;
    return C;
&#125;

int main()
&#123;
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;

    get_primes(a);

    for (int i &#x3D; 0; i &lt; cnt; i++)
    &#123;
        int p &#x3D; primes[i];
        sum[i] &#x3D; get(a,p) - get(b,p) - get(a-b,p);
    &#125;

    vector&lt;int&gt;res;
    res.push_back(1);&#x2F;&#x2F;起始用1先乘
    for (int i &#x3D; 0; i &lt; cnt; i++)
        for(int j &#x3D; 0;j &lt; sum[i];j++)&#x2F;&#x2F;每个素数的个数(乘的次数)
            res &#x3D; mul(res,primes[i]);

    for(int i &#x3D; res.size() - 1;i &gt;&#x3D; 0;i--)  printf(&quot;%d&quot;,res[i]);
    
    return 0;
&#125;
&#x2F;*方法步骤：
1、将1~5000里的素数筛出来
2、求每个质数的次数
3、用高精度乘法将所有质因子乘在一起
实现：
1、线筛
2、利用公式:Cab &#x3D; a! &#x2F; (b! * (a - b)!)一定可以写成若干素数的乘积，而且求a!中有多少个质数p可以利用
上面get函数方法计算
3、高精度模板结束
*&#x2F;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/890/">求组合数 IV</a></p>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Flinyujun%2F787954%2Fo_16.gif&refer=http%3A%2F%2Fimages.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1670726264&t=4d012cf5da77d83716f3afdce6dd9149" alt="img"></p>
<p>  　<font color='red'> 代码模板说明：</font>一般用容斥原理求的结果是多个集合的并集。但为了代码的简洁，我下面的代码求的是多个集合的并集以外的部分，即全集 - 并集的结果。因为下面的计算公式是:n - ? + ?? - ??? + ???? - …。其与求并集的”奇加偶减“相反，并且还多了个n，那么我们可以用n - (n - ? + ?? - …)，即可得到这种形式：? - ?? + ??? - …的并集！</p>
<p><mark>模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">void dfs(int i,int x,int flag)&#x2F;&#x2F;参数含义:i:数组下标,这里从1开始;x:当前的数;flag:加或减
&#123;
    if(i &#x3D;&#x3D; m + 1)&#x2F;&#x2F;m为数组的大小
    &#123;
        res +&#x3D; flag * (n &#x2F; x);
        return;
    &#125;

    dfs(i + 1,x,flag);
    if(x &lt;&#x3D; n &#x2F; v[i])    dfs(i + 1,x * v[i],-flag);
&#125;&#x2F;&#x2F;对应的调用方式：dfs(1,1,1);</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/892/">能被整除的数</a></p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><h4 id="SG打表"><a href="#SG打表" class="headerlink" title="SG打表"></a>SG打表</h4><p>​		针对打表题（推荐题单有，但为了防止该题后期无法查看，这里将详细写出题意和打表方法），内容如下：</p>
<p><strong>题意：</strong></p>
<p>​		一共有 $n$ 个敌人，有两种操作：</p>
<ul>
<li><p>如果当前连续的敌人剩余个数 $\le k$ ，则会直接消灭这些敌人；</p>
</li>
<li><p>选择连续 $k$ 个敌人破坏，但需要保证选完之后会分成左右两个非空序列（通俗讲，就是从中间拿走 $k$ 个，分成了左右两堆）。</p>
<p>谁无法操作，谁就输。问是先手的 $Alice$ 胜还是后手的 $Bob$ 胜？（数据范围：$1 \le T \le 10000,2 \le k \le 10^7,0 \le n \le 10^9$）</p>
</li>
</ul>
<p><strong>思路：</strong></p>
<p>​		看到这种数据范围，可以想到一定是个规律题，但这个需要用 $SG$ 函数打表。打表方法如下：</p>
<ul>
<li><p>记忆化搜索函数：$f[i][j]$，最初初始化为 $-1$，表示还没有使用过；</p>
</li>
<li><p>如果当前没有敌人或当前敌人数恰好为 $k + 1$，则均无法进行操作，故其 $sg$ 值为 $0$；如果当前敌人数目 $n \le k$ ，则先手必胜，即$sg$ 值赋为 $1$；</p>
</li>
<li><p>之后每次会分成两堆，枚举两堆分别为多少个，将其$sg$ 值异或放到哈希表中，最后求 $mex$ 即可。</p>
<p>下面是打表情况：</p>
</li>
</ul>
<p><img src="/images/13.png"></p>
<p><img src="/images/14.png"></p>
<p><img src="/images/15.png"></p>
<p>可以发现，第一个 $n$ 的值为 $0$，第二个 $n$ 的值为 $k + 1$，第三个为 $5k + 3$。令第三个值减去第二个值，会发现相差 $4k + 2$，而且之后相邻两项间都是相差 $4k + 2$，因此答案已知晓。</p>
<p><mark>打表代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)
&#x2F;&#x2F;0:先手必败，因为当前人没法操作

void solve()
&#123;
    &#x2F;&#x2F; int k,n;
    &#x2F;&#x2F; cin &gt;&gt; k &gt;&gt; n;
    &#x2F;&#x2F;n个敌人，1、操作 &lt;&#x3D; k; 2、操作 &#x3D;&#x3D; k
    vector&lt;vector&lt;int&gt;&gt; f(100,vector&lt;int&gt;(100,-1));
    function&lt;int(int,int)&gt; sg &#x3D; [&amp;](int n,int m) -&gt; int&#x2F;&#x2F;操作数&lt;&#x3D;n,总共m
    &#123;
        if(f[n][m] !&#x3D; -1)   return f[n][m];

        if(m &#x3D;&#x3D; 0 || m &#x3D;&#x3D; n + 1)  return f[n][m] &#x3D; 0;
        if(m &lt;&#x3D; n)  return f[n][m] &#x3D; 1;

        unordered_set&lt;int&gt; S;
        if(m &gt; n)
        &#123;
            for(int i &#x3D; 1;i &lt;&#x3D; m - n - 1;i++)
            &#123;
                S.insert(sg(n,i) ^ sg(n,m - n - i));
            &#125;
        &#125;

        for(int i &#x3D; 0;;i++)
            if(!S.count(i))
                return f[n][m] &#x3D; i;
    &#125;;

    for(int i &#x3D; 0;i &lt; 100;i++)
    &#123;
        if(!sg(4,i))    cout &lt;&lt; 4 &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
    &#125;

&#125;

int main()
&#123;
    IOS;
    int t;
    cin &gt;&gt; t;

    &#x2F;&#x2F; while(t--)  solve();
    while(t--)
    &#123;
        int k,n;
        cin &gt;&gt; k &gt;&gt; n;

        if(!n || (n - (k + 1)) % (4 * k + 2) &#x3D;&#x3D; 0)  cout &lt;&lt; &quot;Bob\n&quot;;
        else     cout &lt;&lt; &quot;Alice\n&quot;;
    &#125;

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/895/">集合-Nim游戏</a></p>
<p><strong>练习打表：</strong><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7287">Alice Game</a></p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><blockquote>
<p>假设当前层的未知数有 $n$ 个：$F_1,F_2,\cdots,F_n$，需要利用上一层状态来快速求解答案，因此我们要解公式：</p>
<p>$[F_{i_1},F_{i_2},\cdots,F_{i_n}] &#x3D; [F_{i-1_1},F_{i-1_2},\cdots,F_{i-1_n}]\times A$</p>
<p>只需解出转移矩阵 $A$ 即可。显然，有 $n$ 个未知数，$A$ 矩阵就是 $N \times N$ 大小的。</p>
<p><strong>模板使用指南：</strong></p>
<ul>
<li>矩阵中仅存有二维数组，目的是方便直接手动录入转移矩阵；</li>
<li>不过里面的二维数组每次记得要先初始化再使用！</li>
</ul>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">const int mod &#x3D; 1e9 + 7;
const int N &#x3D; 3;
struct Matrix
&#123;
    int g[N][N];
&#125;;

Matrix operator* (const Matrix&amp; a, const Matrix&amp; b) &#x2F;&#x2F; 重载 * 运算法，支持矩阵乘法
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++)
        for (int j &#x3D; 0; j &lt; N; j++)
            for (int k &#x3D; 0; k &lt; N; k++)
                res.g[i][j] &#x3D; (res.g[i][j] + (ll)a.g[i][k] * b.g[k][j] % mod) % mod;
    return res; 
&#125;

Matrix fpow(Matrix a, int b) &#x2F;&#x2F; 矩阵快速幂
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++) res.g[i][i] &#x3D; 1;
    while (b)
    &#123;
        if (b &amp; 1)  res &#x3D; res * a;
        a &#x3D; a * a;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;</code></pre>

<p><mark>封装 $2 × 2$ 矩阵乘法模板（可不作为参考，因为上一个模板更具通用性）：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">ll mod;
struct Matrix
&#123;
	ll a1, a2, b1, b2;
	Matrix(ll _a1, ll _a2, ll _b1, ll _b2): a1(_a1), a2(_a2), b1(_b1), b2(_b2) &#123;&#125;
	Matrix operator* (const Matrix &amp;y) &#123;
		Matrix ans((a1 * y.a1 + a2 * y.b1) % mod,
				   (a1 * y.a2 + a2 * y.b2) % mod,
				   (b1 * y.a1 + b2 * y.b1) % mod,
				   (b1 * y.a2 + b2 * y.b2) % mod);
		return ans;
	&#125;
&#125;;

Matrix fpow(Matrix a, ll n)
&#123;
	Matrix ans(1, 0, 0, 1);
	while (n)
	&#123;
		if (n &amp; 1)	ans &#x3D; ans * a;
		a &#x3D; a * a;
		n &gt;&gt;&#x3D; 1;
	&#125;
	return ans;
&#125;</code></pre>

<p><strong>斐波那契数列——推导过程：</strong><br>$$<br>F_n &#x3D; \left[<br> \begin{matrix}<br>   f_{n} &amp; f_{n+1} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>F_{n+1} &#x3D; \left[<br> \begin{matrix}<br>   f_{n+1} &amp; f_{n+2} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>令 F_{n+1} &#x3D; F_{n} * A<br>$$</p>
<p>$$<br>即\left[<br> \begin{matrix}<br>   f_{n+1} &amp; f_{n+2} \<br>  \end{matrix}<br>  \right]&#x3D;\left[<br> \begin{matrix}<br>   f_{n} &amp; f_{n+1} \<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   0 &amp; 1 \<br>   1 &amp; 1 \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>故 F_{n} &#x3D; F_1 * A^{n-1}<br>$$</p>
<p>$$<br>A &#x3D; \left[<br> \begin{matrix}<br>   0 &amp; 1 \<br>   1 &amp; 1 \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p><mark>代码如下：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define lowbit(x)   ((x)&amp;(-x))
#define fi first
#define se second
#define pb push_back
#define cf(_) int _;cin &gt;&gt; _;while(_--)

const int N &#x3D; 2,mod &#x3D; 1e9 + 7;

ll n;

void mul(ll c[],ll a[],ll b[][N])
&#123;
    ll temp[N] &#x3D; &#123;0&#125;;
    for(int i &#x3D; 0;i &lt; N;i++)
        for(int j &#x3D; 0;j &lt; N;j++)
            temp[i] &#x3D; (temp[i] + (ll)a[j] * b[j][i]) % mod;
    memcpy(c,temp,sizeof(temp));
&#125;

void mul(ll c[][N],ll a[][N],ll b[][N])
&#123;
    ll temp[N][N] &#x3D; &#123;0&#125;;
    for(int i &#x3D; 0;i &lt; N;i++)
        for(int j &#x3D; 0;j &lt; N;j++)
            for(int k &#x3D; 0;k &lt; N;k++)
                temp[i][j] &#x3D; (temp[i][j] + (ll)a[i][k] * a[k][j]) % mod;
    memcpy(c,temp,sizeof(temp));
&#125;

int main()
&#123;
    IOS;
    cin &gt;&gt; n;

    ll f1[N] &#x3D; &#123;1,1&#125;;
    ll a[N][N] &#x3D; &#123;
        &#123;0,1&#125;,
        &#123;1,1&#125;,
    &#125;;

    n--;
    while(n)
    &#123;
        if(n &amp; 1)   mul(f1,f1,a);
        mul(a,a,a);
        n &gt;&gt;&#x3D; 1;
    &#125;
    cout &lt;&lt; f1[0] &lt;&lt; endl;
    return 0;
&#125;</code></pre>



<p><strong>斐波那契前 n 项和——推导过程：</strong><br>$$<br>F_n &#x3D; \left[<br> \begin{matrix}<br>   f_{n} &amp; f_{n+1} &amp; S_{n} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>F_{n+1} &#x3D; \left[<br> \begin{matrix}<br>   f_{n+1} &amp; f_{n+2} &amp; S_{n+1} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>令 F_{n} * A &#x3D; F_{n+1}<br>$$</p>
<p>$$<br>即\left[<br> \begin{matrix}<br>   f_{n} &amp; f_{n+1} &amp; S_{n}\<br>  \end{matrix}<br>  \right]<br>  \left[<br> \begin{matrix}<br>   0 &amp; 1 &amp; 0\<br>   1 &amp; 1 &amp; 1\<br>   0 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>   &#x3D; \left[<br> \begin{matrix}<br>   f_{n+1} &amp; f_{n+2} &amp; S_{n+1}\<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>故 F_{n} &#x3D; F_1 * A^{n-1}<br>$$</p>
<p>$$<br>A &#x3D; \left[<br> \begin{matrix}<br>   0 &amp; 1 &amp; 0\<br>   1 &amp; 1 &amp; 1\<br>   0 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p><mark>斐波那契前 n 项和代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 3;

int n,mod;

void mul(int c[],int a[],int b[][N])
&#123;
    int temp[N] &#x3D; &#123;0&#125;;
    for(int i &#x3D; 0;i &lt; N ;i++)
        for(int j &#x3D; 0;j &lt; N;j++)
        temp[i] &#x3D; (temp[i] + (ll)a[j] * b[j][i]) % mod;
    memcpy(c,temp,sizeof(temp));
&#125;

void mul(int c[][N],int a[][N],int b[][N])
&#123;
    int temp[N][N] &#x3D; &#123;0&#125;;
    for(int i &#x3D; 0;i &lt; N;i++)
        for(int j &#x3D; 0;j &lt; N;j++)
            for(int k &#x3D; 0;k &lt; N;k++)
                temp[i][j] &#x3D; (temp[i][j] + (ll)a[i][k] * b[k][j]) % mod;
    memcpy(c,temp,sizeof(temp));
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; mod;
    
    int f1[N] &#x3D; &#123;1,1,1&#125;;
    int a[N][N] &#x3D; &#123;
      &#123;0,1,0&#125;,
      &#123;1,1,1&#125;,
      &#123;0,0,1&#125;,
    &#125;;
    
    n --;
    while(n)
    &#123;
        if(n &amp; 1)   mul(f1,f1,a);
        mul(a,a,a);
        n &gt;&gt;&#x3D; 1;
    &#125;
    
    cout &lt;&lt; f1[2] &lt;&lt; endl;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1962">斐波那契数列</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1305/">斐波那契前 n 项和</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104728/problem/I">I. Fujisaki 讨厌数学</a></p>
<p><strong>利用矩阵快速幂加速状压 $dp$：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4409/">积木画</a></p>
<hr>
<p><mark>积木画讲解：</mark></p>
<p>首先需要先递推出公式（这里忽略），直接进行矩阵快速幂部分：</p>
<ul>
<li>每一层状态都可以由上一层状态获取，因此可以矩阵快速幂；</li>
<li>有三个未知数，因此定义：$[F_{i_0},F_{i_1},F_{i_2}] &#x3D; [F_{i-1_0},F_{i-1_1},F_{i-1_2}] \times A$，显然，$A$ 是一个 $3\times3$ 的矩阵；</li>
<li>根据递推的公式，解未知数可得转移矩阵 $A$，因此得解。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 1e9 + 7;
const int N &#x3D; 3;
struct Matrix
&#123;
    int g[N][N];
&#125;;

Matrix operator* (const Matrix&amp; a, const Matrix&amp; b) &#x2F;&#x2F; 重载 * 运算法，支持矩阵乘法
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++)
        for (int j &#x3D; 0; j &lt; N; j++)
            for (int k &#x3D; 0; k &lt; N; k++)
                res.g[i][j] &#x3D; (res.g[i][j] + (ll)a.g[i][k] * b.g[k][j] % mod) % mod;
    return res; 
&#125;

Matrix fpow(Matrix a, int b)
&#123;
    Matrix res;
    memset(res.g, 0, sizeof(res.g));
    for (int i &#x3D; 0; i &lt; N; i++) res.g[i][i] &#x3D; 1;
    while (b)
    &#123;
        if (b &amp; 1)  res &#x3D; res * a;
        a &#x3D; a * a;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return res;
&#125;

Matrix A &#x3D; 
&#123;
    &#123;
        &#123;1, 2, 1&#125;,
        &#123;0, 1, 1&#125;,
        &#123;1, 0, 0&#125;
    &#125;
&#125;;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    &#x2F;**
     * res[3][3] &#x3D; init[3] * A[3][3] ^ n
    *&#x2F;
    auto res &#x3D; fpow(A, n);

    cout &lt;&lt; res.g[0][0];
    return 0;
&#125;</code></pre>

<p><mark>I. Fujisaki 讨厌数学 分析：</mark></p>
<p><strong>推导公式：</strong></p>
<p>定义 $F1,F2$ 如下：<br>$$<br>F1 &#x3D; \left[<br> \begin{matrix}<br>   x^1 + x^{-1} &amp; x^0+x^{-0} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>$$<br>F2 &#x3D; \left[<br> \begin{matrix}<br>   x^2 + x^{-2} &amp; x^1+x^{-1} \<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>则：<br>$$<br>F2 &#x3D; \left[<br> \begin{matrix}<br>   x^2 + x^{-2} &amp; x^1+x^{-1} \<br>  \end{matrix}<br>  \right] &#x3D; \left[<br> \begin{matrix}<br>   x^1 + x^{-1} &amp; x^0+x^{-0} \<br>  \end{matrix}<br>  \right]A\<br>  &#x3D; \left[\begin{matrix}x^1+x^{-1} &amp; x^0 + x^{-0}\end{matrix}\right]<br> \left[\begin{matrix}x^1 + x^{-1} &amp; 1<br> \<br> -1 &amp; 0\end{matrix}\right]<br> \<br> &#x3D; \left[\begin{matrix}x^1+x^{-1} &amp; x^0 + x^{-0}\end{matrix}\right]<br> \left[\begin{matrix}k &amp; 1<br> \<br> -1 &amp; 0\end{matrix}\right]<br> \<br>$$<br>如果转成：同为 $2 × 2$ 的矩阵与 $2 × 2$ 的矩阵相乘的话，代码会相对简短些，即改为：<br>$$<br>F_n &#x3D; F_1 × A^{n - 1} \<br>\left[\begin{matrix}x^n+x^{-n} &amp; x^{n - 1} + x^{-(n-1)}\<br>0 &amp; 0<br>\end{matrix}\right]&#x3D;<br>\left[\begin{matrix}k &amp; 2\<br>0 &amp; 0<br>\end{matrix}\right]<br> \left[\begin{matrix}k &amp; 1<br> \<br> -1 &amp; 0\end{matrix}\right]^{n-1}<br>$$<br><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

ll mod;
struct Matrix
&#123;
	ll a1, a2, b1, b2;
	Matrix(ll _a1, ll _a2, ll _b1, ll _b2): a1(_a1), a2(_a2), b1(_b1), b2(_b2) &#123;&#125;
	Matrix operator* (const Matrix &amp;y) &#123;
		Matrix ans((a1 * y.a1 + a2 * y.b1) % mod,
				   (a1 * y.a2 + a2 * y.b2) % mod,
				   (b1 * y.a1 + b2 * y.b1) % mod,
				   (b1 * y.a2 + b2 * y.b2) % mod);
		return ans;
	&#125;
&#125;;

Matrix fpow(Matrix a, ll n)
&#123;
	Matrix ans(1, 0, 0, 1);
	while (n)
	&#123;
		if (n &amp; 1)	ans &#x3D; ans * a;
		a &#x3D; a * a;
		n &gt;&gt;&#x3D; 1;
	&#125;
	return ans;
&#125;

int main()
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	ll m, k, n;
	cin &gt;&gt; m &gt;&gt; k &gt;&gt; n;
	mod &#x3D; m;
	Matrix M(k, 2, 0, 0);
	Matrix A(k, 1, -1, 0);

	if (n &#x3D;&#x3D; 0)	return cout &lt;&lt; 2, 0;

	M &#x3D; M * fpow(A, n - 1);
	cout &lt;&lt; (M.a1 + mod) % mod &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;</code></pre>



<h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><blockquote>
<p><strong>期望（<mark>下面有模板题的详细公式推导，自认为是最详细最易懂的存在</mark>）：</strong></p>
<p>如果 $X$ 是一个随机变量，它的取值分别是 $x_1,x_2,\cdots,x_n$，那么一个随机事件就可以表示为 $X &#x3D; X_i$，假设它的概率是 $P(X &#x3D; X_i) &#x3D; p_i$，那么它的期望被称为 $E(X)$，有：</p>
<p>$E(X) &#x3D; \sum_{i&#x3D;1}^{n}p_i\times x_i$</p>
<p>通俗地理解，一个随机变量的期望就是这个<strong>随机变量的所有取值与其概率的乘积之和</strong>。</p>
<p>数学期望是线性函数，它满足：</p>
<p>$E(aX+bY)&#x3D;a\times E(X)+b\times E(Y)$</p>
<p><strong>数学期望的重要性质：</strong></p>
<p>设 $C$ 为一个常数，$X$ 和 $Y$ 是两个随机变量。以下是数学期望的重要性质：</p>
<ul>
<li>$E(C) &#x3D; C$；</li>
<li>$E(CX) &#x3D; CE(X)$；</li>
<li>$E(X + Y) &#x3D; E(X) + E(Y)$；</li>
<li>当 $X$ 和 $Y$ 相互独立时，$E(XY) &#x3D; E(X)E(Y)$</li>
</ul>
<p><strong>条件概率：</strong></p>
<p>记事件 $B$ 发生的前提下，事件 $A$ 发生的概率为 $P(A|B)$，则有：$P(A | B) &#x3D; \frac{P(AB)}{P(B)}$，其中 $P(AB)$ 表示 $A$ 和 $B$ 事件同时发生的概率。</p>
<p><strong>全期望：</strong></p>
<p>$E(Y) &#x3D; E(E(Y|X))$</p>
<p><strong>重期望（感觉跟全期望一样qwq，不懂啊）：</strong></p>
<p>$E(Y) &#x3D; E(E(Y|X))$</p>
</blockquote>
<p><mark>下面对模板题：“绿豆蛙的归宿”以及“收集卡牌”进行综合分析：</mark></p>
<p><strong>绿豆蛙的归宿：</strong></p>
<ul>
<li><strong>题意：</strong>给定 $n$ 个点 $m$ 条边的<mark>有向图</mark>，每条边都有一个长度，问从 $1$ 号点到 $n$ 号点的期望长度是多少（去每条边都是等概率的）？</li>
<li><strong>思路：</strong><ul>
<li>首先需要明确一点，要获取一个状态的结果，必须把那个状态的答案计算完毕，同理要获取上个状态，需要计算完毕上上个状态，即依次递归获取，因此我们需要记忆化搜索！！</li>
<li>定义 $f[i]:$ 从 $i$ 跳到 $N$ 的期望长度。因此，边界：$f[N] &#x3D; 0$, 答案：$f[1]$；</li>
<li><mark><strong>最重要的部分：</strong></mark>假设从 $u$ 点出发能前往 $3$ 条边，分别到达 $v_1,v_2,v_3$：<ul>
<li>设事件 $X$ 为从 $u$ 点到达终点的路径长度；</li>
<li>设事件 $X_1$ 为从 $v_1$ 点到达终点的路径长度；</li>
<li>设事件 $X_2$ 为从 $v_2$ 点到达终点的路径长度；</li>
<li>设事件 $X_3$ 为从 $v_3$ 点到达终点的路径长度；</li>
<li>设事件 $A$ 为从 $u$ 点通过花费 $w_1$ 的路径长度到达 $v_1$，再到达终点的路径长度；</li>
<li>设事件 $B$ 为从 $u$ 点通过花费 $w_2$ 的路径长度到达 $v_2$，再到达终点的路径长度；</li>
<li>设事件 $C$ 为从 $u$ 点通过花费 $w_3$ 的路径长度到达 $v_3$，再到达终点的路径长度；</li>
</ul>
</li>
<li>显然，事件 $X$ 包含的是事件 $A,B,C$，而又已知：$A &#x3D; X_1 + w_1, B &#x3D; X_2 + w_2,C &#x3D; X_3 + w_3$，因此有：<ul>
<li>$X &#x3D; P_1\times A + P_2\times B + P_3\times C &#x3D; P_1(X_1+w_1) + P_2(X_2 + w_2) + P_3(X_3 + w_3)$</li>
<li>$E(X) &#x3D; E(P_1(X_1+w_1)) + E(P_2(X_2 + w_2)) + E(P_3(X_3 + w_3))$</li>
<li>$E(X) &#x3D; P_1(w_1+E(X_1)) + P_2(w_2+E(X_2)) + P_3(w_3+E(X_3))$</li>
</ul>
</li>
<li>因此，这里主要证明了对于有边权的情况下，公式：$E(X) &#x3D; \sum_{i&#x3D;1}^{n}p_i\times x_i$ 是成立的，只是看事件定义的是不是满足包含，而且是正确包含。不能错误的以为事件 $X$ 包含事件 $X_1,X_2,X_3$，实际上包含的是事件$A,B,C$！</li>
<li>最后通过这个期望公式，记忆化求解即可。</li>
</ul>
</li>
</ul>
<p><strong>收集卡牌（由于上面讲的非常详细，这里简单提供思路）：</strong></p>
<ul>
<li><strong>题意：</strong>有 $n(n \le 16)$ 个卡牌，抽到每个卡牌都有对应的概率 $p_i$，若抽到相同的卡牌会自动兑换一张万能卡，每 $k$ 张万能卡可以兑换一张任意的卡牌，问抽到所有卡牌的期望次数是多少（如果最后能一次性兑换剩余所有卡牌，则一次性兑换并停止抽卡）？</li>
<li><strong>思路：</strong><ul>
<li>用 $16$ 个二进制位表示状态，因此可以定义：$dp[state][coins]$ 为：当前状态为 $state$，且有 $coins$ 个万能卡的期望次数。</li>
<li>如果直接枚举依次枚举状态（从 $0$ 到 $1&lt;&lt;n$）可能会出现问题，因此一个状态可能从多个状态下转移过来，类似于有向图的依赖，必须先算完该状态下的结果才能利用该状态去继续进行计算，显然还是记忆化搜索。</li>
<li>最初想的是分类讨论，因为要么是抽到相同的卡，要么是抽到新卡。但有个更好写的做法，就是直接依次枚举每个二进制位，如果是 $1$，则说明我要抽到相同的卡，反之是新卡。</li>
<li>因此，对于一个状态，可以转移到 $n$ 种状态，直接写出期望公式（与上面绿豆蛙的推导一样，这里省略）：<ul>
<li>$X &#x3D; \sum p_i(X_i + 1)$</li>
<li>$E(X) &#x3D; \sum p_i(E(X_i) + 1)$</li>
<li>其中 $1$ 是花费的一次抽卡次数。</li>
</ul>
</li>
<li>最后记得特判次数达到一定数量后可不需消耗抽卡次数即可。</li>
</ul>
</li>
</ul>
<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/219/">绿豆蛙的归宿</a>						经典扑克牌数量问题：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/220/">扑克牌</a></p>
<p>与模板题“绿豆蛙的归宿”类似，自己写了 $2$ 个多小时没写出来qwq，于是决定总结好这类题目（已总结）！：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4012/">收集卡牌</a></p>
<p><strong>$2023ICPC$ 网络赛期望签到题：</strong><a target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1705510247604809728/exam/problems/1705514248467492876?type=7&page=0">The 2023 ICPC Asia Regionals Online Contest (2) M Dirty Work</a></p>
<p><strong>$2023CCPC$ 华为云计算挑战赛（简单期望题）</strong>：<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=7398">塔</a></p>
<hr>
<p><mark>l绿豆蛙的归宿代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 1e5 + 10, M &#x3D; 4e5 + 10;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
double f[N];
int d[N];

void add(int a, int b, int c)
&#123;
    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

double dp(int u, int fa)
&#123;
    if (f[u] &gt;&#x3D; 0) return f[u];
    auto&amp; v &#x3D; f[u];
    v &#x3D; 0;
    for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (j &#x3D;&#x3D; fa)    continue;
        v +&#x3D; 1.0 &#x2F; d[u] * (dp(j, u) + w[i]);
    &#125;
    return v;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    memset(h, -1, sizeof(h));
    memset(f, -1, sizeof(f));

    cin &gt;&gt; n &gt;&gt; m;
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
        d[a]++;
    &#125;
    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; dp(1, -1) &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<p><mark>收集卡牌代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 16, M &#x3D; 1 &lt;&lt; N;

int n, k;
double probility[N];
double f[M][81];

double dp(int state, int coins, int zero_cnt)
&#123;
    if (f[state][coins] &gt;&#x3D; 0)   return f[state][coins];
    auto&amp; v &#x3D; f[state][coins];
    v &#x3D; 0;
    if (coins &gt;&#x3D; zero_cnt * k)  return v;
    for (int i &#x3D; 0; i &lt; n; i++)
        if (state &gt;&gt; i &amp; 1)
            v +&#x3D; probility[i] * (dp(state, coins + 1, zero_cnt) + 1);
        else    
            v +&#x3D; probility[i] * (dp(state | (1 &lt;&lt; i), coins, zero_cnt - 1) + 1);
    return v;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    memset(f, -1, sizeof(f));
    cin &gt;&gt; n &gt;&gt; k;

    for (int i &#x3D; 0; i &lt; n; i++)    cin &gt;&gt; probility[i];    

    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; dp(0, 0, n) &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>



<p><mark>M Dirty Work 讲解：</mark></p>
<blockquote>
<p><strong>题意：</strong>有 $n$ 道题，已知每道题的第一次尝试需要的时间和第二次修改的时间（第二次修改后的代码必对）以及第一次尝试失败的概率，此外第一次失败的罚时不计，其余罚时规则与 $ICPC$ 规则一致。你可以安排这 $n$ 道题的做题顺序，问最小的期望罚时是多少？</p>
<p><strong>思路：</strong>显然，每道题的期望罚时是一定的，即 $penalty_i &#x3D; p_{false} ×(a+b) + p_{success} ×a$，而最小期望罚时的话就需要按每道题的罚时从小到大排序，故此。</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;tuple&lt;int, int, double&gt;&gt; v(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int a, b;
        double c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        v[i] &#x3D; make_tuple(a, b, c);
    &#125;

    vector&lt;double&gt; res(n + 1);
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        auto [a, b, p] &#x3D; v[i];
        res[i] &#x3D; (1 - p) * a + p * (a + b);
    &#125;

    sort(res.begin() + 1, res.end());

    double ans &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        res[i] +&#x3D; res[i - 1];
        ans +&#x3D; res[i];
    &#125;

    cout &lt;&lt; fixed &lt;&lt; setprecision(12) &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
        
    return 0;
&#125;</code></pre>



<p><mark>塔代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int,int&gt; pii;

#define IOS ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
#define cf(_) int _;cin &gt;&gt; _;while(_--)

mt19937 mrand(random_device&#123;&#125;());
int rnd(int x) &#123; return mrand() % x;&#125;
ll gcd(ll a,ll b)&#123;return b ? gcd(b,a % b) : a;&#125;
ll fpow(ll a,ll b,ll mod)&#123;ll res &#x3D; 1;a %&#x3D; mod;assert(b &gt;&#x3D; 0);while(b)&#123;if(b &amp; 1)res &#x3D; res * a % mod;a &#x3D; a * a % mod;b &gt;&gt;&#x3D; 1;&#125;return res;&#125;

const int N &#x3D; 2e5 + 10, mod &#x3D; 998244353;
ll fact[N],infact[N];

void solve()
&#123;
    int n, m, k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    auto C &#x3D; [&amp;](ll n, ll m) -&gt; ll
    &#123;
        if(m &gt; n)   return 0;
        return fact[n] * infact[n - m] % mod * infact[m] % mod;
    &#125;;

    auto inv &#x3D; [&amp;](ll x) -&gt; ll
    &#123;
        return fpow(x, mod - 2, mod);
    &#125;;

    vector&lt;ll&gt; P(k + 1);

    if (k &#x3D;&#x3D; n) return cout &lt;&lt; n &lt;&lt; &quot;\n&quot;, void();

    ll ding &#x3D; inv(C(n, k));
    for (int i &#x3D; 0; i &lt;&#x3D; k; i++)
    &#123;
        P[i] &#x3D; C(n - i - 1, k - i) * ding % mod;
    &#125;

    ll res &#x3D; 0;
    for (int i &#x3D; 0; i &lt;&#x3D; k; i++)
    &#123;
        res &#x3D; (res + P[k - i] * (n + i) % mod) % mod;
    &#125;

    res &#x3D; (n + ((res - n) % mod + mod) % mod * m % mod) % mod;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    IOS;

    fact[0] &#x3D; infact[0] &#x3D; 1;
    for (int i &#x3D; 1; i &lt; N; i++)
    &#123;
        fact[i] &#x3D; fact[i - 1] * i % mod;
        infact[i] &#x3D; fpow(fact[i], mod - 2, mod);
    &#125;
    
    int t;
    cin &gt;&gt; t;

    while(t--)  solve();

    return 0;
&#125;</code></pre>



<h2 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h2><p><strong>一、寻找规律</strong></p>
<p>当n &#x3D; 20：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
</tr>
</thead>
<tbody><tr>
<td>20</td>
<td>10</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>明显，存在很多个区间，使得某个区间内（区间长度可能为1），有连续的 $\frac{n}{i} $ 数值相同。</p>
<p><strong>二、给出结论</strong></p>
<blockquote>
    假如说一个区间的左端点是L，那么它的右端点是n / n / L。
</blockquote>


<p>例如：当L &#x3D; 7时，n &#x2F; L &#x3D; 20 &#x2F; 7 &#x3D; 2，n &#x2F; (n &#x2F; L) &#x3D; 20 &#x2F; 2 &#x3D; 10符合。</p>
<p><strong>三、给出证明</strong></p>
<p><mark>证明该式子 $\lfloor \frac{n}{i} \rfloor$ 最多只有 2$\sqrt{n}$ 个取值</mark><br>分段讨论：</p>
<ul>
<li>当 i&lt;&#x3D; $\sqrt{n}$ 时，因为 i 是 1 到 $\sqrt{n}$ 的整数，所以最多只有 $\sqrt{n}$ 个不同的$\sqrt{\frac{n}{i}}$ 值。</li>
<li>当 i &gt; $\sqrt{n}$ 时，$\sqrt{\frac{n}{i}}$ &lt;&#x3D; $\sqrt{n}$，又因为式子取整了，所以式子只能取1 到 $\sqrt{n}$ 的整数，故最多也只有 $\sqrt{n}$ 个不同的 $\sqrt{\frac{n}{i}}$ 值。</li>
</ul>
<p>综上所述， $\lfloor \frac{n}{i} \rfloor$ 最多只有 2$\sqrt{n}$ 个取值</p>
<p><strong>四、记住结论，拓展应用</strong></p>
<p>$$ \sum_{i&#x3D;1}^{n} \lfloor \frac{n}{i} \rfloor $$</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int sum &#x3D; 0;
for(int l &#x3D; 1,r;l &lt;&#x3D; n;l &#x3D; r + 1)
&#123;
    r &#x3D; n &#x2F; (n &#x2F; l);
    sum +&#x3D; (r - l + 1) * (n &#x2F; l);
&#125;</code></pre>



<p>$$ \sum_{i&#x3D;1}^{n} \lfloor \frac{n}{i} \rfloor * i $$</p>
<p>在一段区间内的 n &#x2F; i 的值是相同的，而在区间内对 i 的求和是一个明确了左端点和右端点的等差数列求和，代码如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int sum &#x3D; 0;
for(int l &#x3D; 1,r;l &lt;&#x3D; n;l &#x3D; r + 1)
&#123;
    r &#x3D; n &#x2F; (n &#x2F; l);
    sum +&#x3D; (r - l + 1) * (n &#x2F; l) * (l + r) &#x2F; 2;
&#125;</code></pre>

<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/201/">余数之和</a></p>
<p><strong>进阶题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/D2">Chopping Carrots (Hard Version)</a></p>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><blockquote>
<p>高斯消元（求线性基时，是一种<strong>离线做法</strong>）中，有 $k(k \le n)$ 个线性基：</p>
<ul>
<li>若 $k &lt; n$ ，说明这 $n$ 个向量是线性相关的，则必然可以凑出 $0$ 向量。</li>
<li>若 $k &#x3D; n$，则线性无关，无法凑出 $0$ 向量。</li>
</ul>
</blockquote>
<p><mark>封装模板：</mark></p>
<ul>
<li><strong>高斯消元版（离线）</strong></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
struct Linear_basis
&#123;
    int n, k;
    vector&lt;T&gt; a;

    Linear_basis(const vector&lt;T&gt; &amp;a): a(a), n(a.size()) &#123;&#125;

    void Gauss() &#123;
        k &#x3D; 0;
        for (int i &#x3D; 62; i &gt;&#x3D; 0; i--) &#123;
            for (int j &#x3D; k; j &lt; n; j++) &#123;
                if (a[j] &gt;&gt; i &amp; 1) &#123;
                    swap(a[j], a[k]);
                    break;
                &#125;
            &#125;
            if (!(a[k] &gt;&gt; i &amp; 1))   continue;

            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (j &#x3D;&#x3D; k) continue;
                if (a[j] &gt;&gt; i &amp; 1)  a[j] ^&#x3D; a[k];
            &#125;
            k++;
            if (k &#x3D;&#x3D; n) break;
        &#125;
    &#125;

    T get_max() &#123;
        T res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; i++) res ^&#x3D; a[i];
        return res;
    &#125;

    T get_min() &#123;
        if (k &lt; n)  return 0;
        else    return a[k - 1];
    &#125;

    T get_kth(T m) &#123; &#x2F;&#x2F; 求第 m 小
        if (k &lt; n)  m--;
        if ((1ll &lt;&lt; k) - 1 &lt; m) return -1;
        T res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; i++)
            if (m &gt;&gt; i &amp; 1)
                res ^&#x3D; a[k - i - 1];
        return res;
    &#125;
&#125;;</code></pre>

<ul>
<li><strong>贪心版（在线）</strong></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
struct Linear_basis
&#123;
    bool flag;&#x2F;&#x2F;判断 0 的存在
    vector&lt;T&gt; d;

    Linear_basis(): flag(false) &#123;
        d.resize(63);
    &#125;
    bool add(T x) &#123; &#x2F;&#x2F; 每次插入一个数
        for(int i &#x3D; 62; ~i;i--)
            if(x &gt;&gt; i &amp; 1)
            &#123;
                if(!d[i])    return d[i] &#x3D; x,true;
                x ^&#x3D; d[i];
            &#125;
        flag &#x3D; true;
        return false;
    &#125;;

    T get_max() &#123; &#x2F;&#x2F;选取任意个数异或的最大值
        T res &#x3D; 0;
        for(int i &#x3D; 62; ~i;i--)
        &#123;
            res &#x3D; max(res,res ^ d[i]);
        &#125;
        return res;
    &#125;;

    T get_min() &#123; &#x2F;&#x2F;选取任意个数异或的最小值
        if(flag)    return 0;
        for(int i &#x3D; 0; i &lt;&#x3D; 62;i++)
            if(d[i])    return d[i];
        return -1;
    &#125;;
&#125;;</code></pre>

<p><mark>模板题 $1$ 代码：</mark></p>
<ul>
<li><strong>高斯消元版</strong></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

template&lt;typename T&gt;
struct Linear_basis
&#123;
    int n, k;
    vector&lt;T&gt; a;

    Linear_basis(const vector&lt;T&gt; &amp;a): a(a), n(a.size()) &#123;&#125;

    void Gauss() &#123;
        k &#x3D; 0;
        for (int i &#x3D; 62; i &gt;&#x3D; 0; i--) &#123;
            for (int j &#x3D; k; j &lt; n; j++) &#123;
                if (a[j] &gt;&gt; i &amp; 1) &#123;
                    swap(a[j], a[k]);
                    break;
                &#125;
            &#125;
            if (!(a[k] &gt;&gt; i &amp; 1))   continue;

            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (j &#x3D;&#x3D; k) continue;
                if (a[j] &gt;&gt; i &amp; 1)  a[j] ^&#x3D; a[k];
            &#125;
            k++;
            if (k &#x3D;&#x3D; n) break;
        &#125;
    &#125;

    T get_max() &#123;
        T res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; i++) res ^&#x3D; a[i];
        return res;
    &#125;

    T get_min() &#123;
        if (k &lt; n)  return 0;
        else    return a[k - 1];
    &#125;
&#125;;


int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; a(n);
    for (int i &#x3D; 0; i &lt; n; i++)    cin &gt;&gt; a[i];

    Linear_basis&lt;ll&gt; lb(a);
    lb.Gauss();
    cout &lt;&lt; lb.get_max();
    return 0;
&#125;</code></pre>

<ul>
<li><strong>贪心版</strong></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; d(63);
    auto add &#x3D; [&amp;](ll x) -&gt; void&#x2F;&#x2F;每次插入一个数
    &#123;
        for(int i &#x3D; 62; ~i;i--)
            if(x &gt;&gt; i &amp; 1)
            &#123;
                if(!d[i])    return d[i] &#x3D; x,void();
                x ^&#x3D; d[i];
            &#125;
    &#125;;

    auto get_max &#x3D; [&amp;]() -&gt; ll&#x2F;&#x2F;选取任意个数异或的最大值
    &#123;
        ll res &#x3D; 0;
        for(int i &#x3D; 62; ~i;i--)
        &#123;
            res &#x3D; max(res,res ^ d[i]);
        &#125;
        return res;
    &#125;;

    vector&lt;ll&gt; a(n + 1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i],add(a[i]);
    
    cout &lt;&lt; get_max() &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>模板题 $2$ 代码：</mark></p>
<blockquote>
<p><strong>结论：</strong>第 $k$ 大异或和就是选 $2^t - k$ 的二进制对应的那些行。</p>
<p>比如：最大异或和就是全选（以 $4$ 位为例）：$1111$</p>
<p>第二大异或和就是选前三行：$1110$</p>
<p>第三大异或和就是选第 $1,2,4$ 行：$1101$</p>
<p>故选：$2^t - k$</p>
</blockquote>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

template&lt;typename T&gt;
struct Linear_basis
&#123;
    int n, k;
    vector&lt;T&gt; a;

    Linear_basis(const vector&lt;T&gt; &amp;a): a(a), n(a.size()) &#123;&#125;

    void Gauss() &#123;
        k &#x3D; 0;
        for (int i &#x3D; 62; i &gt;&#x3D; 0; i--) &#123;
            for (int j &#x3D; k; j &lt; n; j++) &#123;
                if (a[j] &gt;&gt; i &amp; 1) &#123;
                    swap(a[j], a[k]);
                    break;
                &#125;
            &#125;
            if (!(a[k] &gt;&gt; i &amp; 1))   continue;

            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (j &#x3D;&#x3D; k) continue;
                if (a[j] &gt;&gt; i &amp; 1)  a[j] ^&#x3D; a[k];
            &#125;
            k++;
            if (k &#x3D;&#x3D; n) break;
        &#125;
    &#125;

    T get_max() &#123;
        T res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; i++) res ^&#x3D; a[i];
        return res;
    &#125;

    T get_min() &#123;
        if (k &lt; n)  return 0;
        else    return a[k - 1];
    &#125;

    T get_kth(T m) &#123; &#x2F;&#x2F; 求第 m 小
        if (k &lt; n)  m--;
        if ((1ll &lt;&lt; k) - 1 &lt; m) return -1;
        T res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; i++)
            if (m &gt;&gt; i &amp; 1)
                res ^&#x3D; a[k - i - 1];
        return res;
    &#125;
&#125;;


int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int T;
    cin &gt;&gt; T;

    for (int _ &#x3D; 1; _ &lt;&#x3D; T; _++) 
    &#123;
        int n;
        cin &gt;&gt; n;

        vector&lt;ll&gt; a(n);
        for (int i &#x3D; 0; i &lt; n; i++)    cin &gt;&gt; a[i];

        Linear_basis&lt;ll&gt; lb(a);
        lb.Gauss();
        
        int q;
        cin &gt;&gt; q;

        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; _ &lt;&lt; &quot;:\n&quot;;
        while (q--)
        &#123;
            ll k;
            cin &gt;&gt; k;
            cout &lt;&lt; lb.get_kth(k) &lt;&lt; &quot;\n&quot;;
        &#125;
        
    &#125;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题1（求最大异或和）：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3167/">线性基</a>    </p>
<p><strong>模板题2（求第 $k$ 大异或和）：</strong> <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/212/">异或运算</a></p>
<p><strong>$2023CCPC$ 桂林站银牌题：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/gym/482805/problem/C">C. Master of Both IV</a></p>
<p><mark>$2023CCPC$ 桂林站银牌题讲解：</mark></p>
<blockquote>
<p><strong>题意：</strong>给一个可重集，求有多少子集满足每个元素都可以被异或和整除。</p>
<p><strong>思路：</strong> </p>
<p>设： $lcm(S) &#x3D; f, xor(S) &#x3D; g$</p>
<p>则有：$f \ge max{a}, g \lt 2 × max{a}$，则所有可能的情况只有<strong>两种</strong>：即 $g &#x3D; 0, g &#x3D; max{a}$</p>
<ul>
<li>$g &#x3D; 0$ 的情况等价于询问一个集合中有多少（非空）子集异或和为 $0$，设这个集合异或线性基的秩为 $r$，则答案为 $2^{n - r} - 1$；</li>
<li>$g &#x3D; max{a}$ 时，枚举每个数 $x$，然后将所有出现过的 $x$ 的因子 $factor$ 加入到线性基中，如果不能成功插入，则说明线性基中有若干个数可以表示这个因子 $factor$，对答案贡献了 $cnt[factor]$ 个；如果新加入的数能成功插入，则对答案的贡献应该是与该数相同的剩余的个数，即 $cnt[factor] - 1$。</li>
</ul>
<p><strong>实现细节：</strong>获取每个数的约数时，（新学）用到了埃式筛法优化获取质数（预处理）；在线做法，用到了贪心线性基的模板。</p>
<p><strong>时间复杂度：</strong>$O(Nlog^2N)$</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

template&lt;typename T&gt;
struct Linear_basis
&#123;
    bool flag;&#x2F;&#x2F;判断 0 的存在
    vector&lt;T&gt; d;

    Linear_basis(): flag(false) &#123;
        d.resize(63);
    &#125;
    bool add(T x) &#123; &#x2F;&#x2F; 每次插入一个数
        for(int i &#x3D; 62; ~i;i--)
            if(x &gt;&gt; i &amp; 1)
            &#123;
                if(!d[i])    return d[i] &#x3D; x,true;
                x ^&#x3D; d[i];
            &#125;
        flag &#x3D; true;
        return false;
    &#125;;

    T get_max() &#123; &#x2F;&#x2F;选取任意个数异或的最大值
        T res &#x3D; 0;
        for(int i &#x3D; 62; ~i;i--)
        &#123;
            res &#x3D; max(res,res ^ d[i]);
        &#125;
        return res;
    &#125;;

    T get_min() &#123; &#x2F;&#x2F;选取任意个数异或的最小值
        if(flag)    return 0;
        for(int i &#x3D; 0; i &lt;&#x3D; 62;i++)
            if(d[i])    return d[i];
        return -1;
    &#125;;
&#125;;

const int mod &#x3D; 998244353;

ll fpow(ll a,ll b)
&#123;
   ll res &#x3D; 1;
   a %&#x3D; mod;
   while(b)
   &#123;
       if(b &amp; 1)   res &#x3D; res * a % mod;
       a &#x3D; a * a % mod;
       b &gt;&gt;&#x3D; 1;
   &#125;
   return res;
&#125;

const int N &#x3D; 2e5 + 10;
vector&lt;int&gt; factor[N];
void get_divivors(int n)
&#123;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    	for (int j &#x3D; i; j &lt;&#x3D; n; j +&#x3D; i) 
            factor[j].emplace_back(i);
&#125;

void solve()
&#123;
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; a(n + 1);
    Linear_basis&lt;ll&gt; lb;
    int k &#x3D; 0;
    map&lt;int, int&gt; cnt;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    
    &#123;
        cin &gt;&gt; a[i];
        if (!lb.add(a[i]))  k++;

        cnt[a[i]]++;
    &#125;
    
    ll res &#x3D; fpow(2, k) - 1;
    for (auto [x, y] : cnt)
    &#123;
        Linear_basis&lt;ll&gt; tlb;
        int tk &#x3D; 0;
        for (auto t : factor[x])
        &#123;
            if (cnt.count(t))    
            &#123;
                if (!tlb.add(t))    tk +&#x3D; cnt[t];
                else    tk +&#x3D; cnt[t] - 1;
            &#125;
        &#125;
        res &#x3D; (res + fpow(2, tk)) % mod;
    &#125;

    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    get_divivors(2e5);

    int t;
    cin &gt;&gt; t;

    while (t--)
    &#123;
        solve();
    &#125;
    
    return 0;
&#125;</code></pre>



<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p><mark>线性筛法求莫比乌斯函数：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int cnt,primes[N],mu[N],sum[N];
bool st[N];

void init()
&#123;
    mu[1] &#x3D; 1;
    for(int i &#x3D; 2;i &lt; N;i++)
    &#123;
        if(!st[i])  primes[cnt++] &#x3D; i,mu[i] &#x3D; -1;
        for(int j &#x3D; 0;primes[j] * i &lt; N;j++)
        &#123;
            st[primes[j] * i] &#x3D; true;
            if(i % primes[j] &#x3D;&#x3D; 0)  break;
            mu[primes[j] * i] &#x3D; -mu[i];   
        &#125;
    &#125;
    for(int i &#x3D; 1;i &lt; N;i++)    sum[i] &#x3D; sum[i - 1] + mu[i];&#x2F;&#x2F;莫比乌斯前缀和
&#125;</code></pre>

<p><mark>推荐题单：</mark><br><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2704/">problem b</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1360/">约数个数和</a></p>
<h2 id="Pollard-rho"><a href="#Pollard-rho" class="headerlink" title="Pollard rho"></a>Pollard rho</h2><blockquote>
<p><strong>Pollard-Rho算法</strong>是John Pollard发明的一种能快速找到大整数的一个非1、非自身的因子的算法。</p>
<p>非平凡因数：除了 $1$ 和本身以外的因数。</p>
<p><strong>时间复杂度：</strong>$O(n^{\frac{1}{4}})$</p>
</blockquote>
<p><mark>封装模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">struct Pollard_Rho
&#123;
	ll mul(ll a, ll b, ll mod)&#123;
		ll r &#x3D; a * b - mod * (ll)(1.L &#x2F; mod * a * b);
		return r - mod * (r &gt;&#x3D; mod) + mod * (r &lt; 0);
	&#125;
	ll add(ll a, ll b, ll mod) &#123;
		a +&#x3D; b;
		return a &gt;&#x3D; mod ? a - mod : a;
	&#125;
	ll sub(ll a, ll b, ll mod) &#123;
		a -&#x3D; b;
		return a &lt; 0 ? a + mod : a;
	&#125;
	ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a; &#125;
	ll qpow(ll a, ll b, ll mod) &#123;
		ll res &#x3D; 1;
		for (; b; b &gt;&gt;&#x3D; 1, a &#x3D; mul(a, a, mod))
			if (b &amp; 1) res &#x3D; mul(res, a, mod);
		return res;
	&#125;
	&#x2F;&#x2F; 素性测试
	bool miller_rabin(ll n) &#123;
		if (n &lt;&#x3D; 1) return false;
		vector&lt;ll&gt; base &#x3D; &#123;2, 3, 5, 7, 11, 13, 17, 19, 23&#125;;
		for (ll p : base) &#123;
			if (n &#x3D;&#x3D; p) return true;
			if (n % p &#x3D;&#x3D; 0) return false;
		&#125;
		ll m &#x3D; (n - 1) &gt;&gt; __builtin_ctz(n - 1); &#x2F;&#x2F; 二进制表示末尾0的个数
		for (ll p : base) &#123;
			ll t &#x3D; m, a &#x3D; qpow(p, m, n);
			while (t !&#x3D; n - 1 &amp;&amp; a !&#x3D; 1 &amp;&amp; a !&#x3D; n - 1)
				a &#x3D; mul(a, a, n), t *&#x3D; 2;
			if (a !&#x3D; n - 1 &amp;&amp; t % 2 &#x3D;&#x3D; 0) return false;
		&#125;
		return true;
	&#125;
	&#x2F;&#x2F; 获取n的一个非平凡因子(不一定是质因子)
	ll pollard_rho(ll n) &#123;
		if (n % 2 &#x3D;&#x3D; 0) return 2;
		auto f &#x3D; [&amp;](ll x) &#123; return add(mul(x, x, n), 1, n); &#125;;
		ll x &#x3D; 0, y &#x3D; 0, tot &#x3D; 0, p &#x3D; 1, q, g;
		for (ll i &#x3D; 0; (i &amp; 0xff) || (g &#x3D; gcd(p, n)) &#x3D;&#x3D; 1; i++, x &#x3D; f(x), y &#x3D; f(f(y))) &#123;
			if (x &#x3D;&#x3D; y) x &#x3D; tot++, y &#x3D; f(x);
			q &#x3D; mul(p, sub(x, y, n), n);
			if (q) p &#x3D; q;
		&#125;
		return g;
	&#125;
	&#x2F;&#x2F; 返回n的所有质因子(不按顺序, 每个质因子在返回列表中出现的次数等于指数)
	vector&lt;ll&gt; get_prime_factors(ll n) &#123;
		if (n &#x3D;&#x3D; 1) return &#123;&#125;;
		if (miller_rabin(n)) return &#123;n&#125;;
		ll d &#x3D; pollard_rho(n);
		auto v1 &#x3D; get_prime_factors(n &#x2F; d);
		auto v2 &#x3D; get_prime_factors(d);
		for(auto a: v2) v1.push_back(a);
		return v1;
	&#125;
&#125;;</code></pre>

<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 998244353;

struct Pollard_Rho
&#123;
	ll mul(ll a, ll b, ll mod)&#123;
		ll r &#x3D; a * b - mod * (ll)(1.L &#x2F; mod * a * b);
		return r - mod * (r &gt;&#x3D; mod) + mod * (r &lt; 0);
	&#125;
	ll add(ll a, ll b, ll mod) &#123;
		a +&#x3D; b;
		return a &gt;&#x3D; mod ? a - mod : a;
	&#125;
	ll sub(ll a, ll b, ll mod) &#123;
		a -&#x3D; b;
		return a &lt; 0 ? a + mod : a;
	&#125;
	ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a; &#125;
	ll qpow(ll a, ll b, ll mod) &#123;
		ll res &#x3D; 1;
		for (; b; b &gt;&gt;&#x3D; 1, a &#x3D; mul(a, a, mod))
			if (b &amp; 1) res &#x3D; mul(res, a, mod);
		return res;
	&#125;
	&#x2F;&#x2F; 素性测试
	bool miller_rabin(ll n) &#123;
		if (n &lt;&#x3D; 1) return false;
		vector&lt;ll&gt; base &#x3D; &#123;2, 3, 5, 7, 11, 13, 17, 19, 23&#125;;
		for (ll p : base) &#123;
			if (n &#x3D;&#x3D; p) return true;
			if (n % p &#x3D;&#x3D; 0) return false;
		&#125;
		ll m &#x3D; (n - 1) &gt;&gt; __builtin_ctz(n - 1); &#x2F;&#x2F; 二进制表示末尾0的个数
		for (ll p : base) &#123;
			ll t &#x3D; m, a &#x3D; qpow(p, m, n);
			while (t !&#x3D; n - 1 &amp;&amp; a !&#x3D; 1 &amp;&amp; a !&#x3D; n - 1)
				a &#x3D; mul(a, a, n), t *&#x3D; 2;
			if (a !&#x3D; n - 1 &amp;&amp; t % 2 &#x3D;&#x3D; 0) return false;
		&#125;
		return true;
	&#125;
	&#x2F;&#x2F; 获取n的一个非平凡因子(不一定是质因子)
	ll pollard_rho(ll n) &#123;
		if (n % 2 &#x3D;&#x3D; 0) return 2;
		auto f &#x3D; [&amp;](ll x) &#123; return add(mul(x, x, n), 1, n); &#125;;
		ll x &#x3D; 0, y &#x3D; 0, tot &#x3D; 0, p &#x3D; 1, q, g;
		for (ll i &#x3D; 0; (i &amp; 0xff) || (g &#x3D; gcd(p, n)) &#x3D;&#x3D; 1; i++, x &#x3D; f(x), y &#x3D; f(f(y))) &#123;
			if (x &#x3D;&#x3D; y) x &#x3D; tot++, y &#x3D; f(x);
			q &#x3D; mul(p, sub(x, y, n), n);
			if (q) p &#x3D; q;
		&#125;
		return g;
	&#125;
	&#x2F;&#x2F; 返回n的所有质因子(不按顺序, 每个质因子在返回列表中出现的次数等于指数)
	vector&lt;ll&gt; get_prime_factors(ll n) &#123;
		if (n &#x3D;&#x3D; 1) return &#123;&#125;;
		if (miller_rabin(n)) return &#123;n&#125;;
		ll d &#x3D; pollard_rho(n);
		auto v1 &#x3D; get_prime_factors(n &#x2F; d);
		auto v2 &#x3D; get_prime_factors(d);
		for(auto a: v2) v1.push_back(a);
		return v1;
	&#125;
&#125;;

void solve()
&#123;
	ll n;
	cin &gt;&gt; n;

	Pollard_Rho rho;
	auto res &#x3D; rho.get_prime_factors(n);
	if(res.size() &#x3D;&#x3D; 1)	cout &lt;&lt; &quot;Prime\n&quot;;
	else	cout &lt;&lt; *max_element(res.begin(),res.end()) &lt;&lt; &quot;\n&quot;;
&#125;

int main() 
&#123;
	cin.tie(nullptr)-&gt;sync_with_stdio(false);

	int t;
	cin &gt;&gt; t;

	while(t--)	solve();

	return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4718">【模板】Pollard rho 算法</a></p>
<p><strong>测试模板速度：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1033/problem/D">D. Divisors</a></p>
<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><h3 id="BSGS-1"><a href="#BSGS-1" class="headerlink" title="BSGS"></a>BSGS</h3><blockquote>
<p>求满足 $a^x \equiv b(mod\ p)$ 的最小非负整数 $x$，$a$ 与 $p$ 互质。</p>
</blockquote>
<p><strong>解法：</strong></p>
<p>$x \in [0,φ(p) - 1]$，总共有 $p$ 个，分成 $k$ 块，每块有 $\sqrt{p} + 1$ 个，取遍里面的情况共有：$t &#x3D; xk - y, x\in [1,k],y\in[0,k-1]$，因此有：$a^t &#x3D; a^{xk-y} \equiv b(mod\ p)$，即：$a^{kx} \equiv ba^y(mod \ p)$。</p>
<p>因此枚举 $y$ 取遍的情况，用哈希值存取，相同的结果用较大的 $y$ 值代替，从而查询同余情况。</p>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

int BSGS(int a, int b ,int p)
&#123;
    if (1 % p &#x3D;&#x3D; b % p) return 0;
    int k &#x3D; sqrt(p) + 1;
    unordered_map&lt;int, int&gt; hash;
    for (int i &#x3D; 0, j &#x3D; b % p; i &lt; k; i++)
    &#123;
        hash[j] &#x3D; i;
        j &#x3D; (ll)j * a % p;
    &#125;
    int ak &#x3D; 1;
    for (int i &#x3D; 0; i &lt; k; i++) ak &#x3D; (ll)ak * a % p;

    for (int i &#x3D; 1, j &#x3D; ak; i &lt;&#x3D; k; i++)
    &#123;
        if (hash.count(j))  return (ll)i * k - hash[j];
        j &#x3D; (ll)j * ak % p;
    &#125;
    return -1;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int a, p, b;
    while (cin &gt;&gt; a &gt;&gt; p &gt;&gt; b, a || p || b)
    &#123;
        int res &#x3D; BSGS(a, b, p);
        if(res &#x3D;&#x3D; -1)   cout &lt;&lt; &quot;No Solution\n&quot;;
        else    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    &#125;
    
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3127/">BSGS</a></p>
<h3 id="扩展BSGS"><a href="#扩展BSGS" class="headerlink" title="扩展BSGS"></a>扩展BSGS</h3><blockquote>
<p>求满足 $a^x \equiv b(mod\ p)$ 的最小非负整数 $x$，$a$ 与 $p$ 不一定互质。</p>
</blockquote>
<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3128/">扩展BSGS</a></p>
<h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><blockquote>
<p>$A(x) &#x3D; a_0 + a_1x + a_2x^2 + \cdots + a_nx^n$</p>
<p>$B(x) &#x3D; b_0 + b_1x + b_2x^2 + \cdots + b_nx^n$</p>
<p>可以求出多项式乘积（卷积）：$A(x)B(x)$</p>
<p><strong>时间复杂度：</strong>$O(nlogn)$</p>
</blockquote>
<p><mark>多项式乘法模板代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

const int N &#x3D; 3e5 + 10;
const double PI &#x3D; acos(-1);

int n,m;
struct Complex
&#123;
    double x,y;
    Complex operator+ (const Complex&amp; t) const
    &#123;
        return &#123;x + t.x,y + t.y&#125;;
    &#125;
    Complex operator- (const Complex&amp; t) const
    &#123;
        return &#123;x - t.x,y - t.y&#125;;
    &#125;
    Complex operator* (const Complex&amp; t) const
    &#123;
        return &#123;x * t.x - y * t.y,x * t.y + y * t.x&#125;;
    &#125;
&#125;a[N],b[N];
int rev[N],bit,tot;

void fft(Complex a[],int inv)
&#123;
    for(int i &#x3D; 0;i &lt; tot;i++)
        if(i &lt; rev[i])
            swap(a[i],a[rev[i]]);
    for(int mid &#x3D; 1;mid &lt; tot;mid &lt;&lt;&#x3D; 1)
    &#123;
        auto w1 &#x3D; Complex(&#123;cos(PI &#x2F; mid),inv * sin(PI &#x2F; mid)&#125;);
        for(int i &#x3D; 0;i &lt; tot;i +&#x3D; mid * 2)
        &#123;
            auto wk &#x3D; Complex(&#123;1,0&#125;);
            for(int j &#x3D; 0;j &lt; mid;j++,wk &#x3D; wk * w1)
            &#123;
                auto x &#x3D; a[i + j],y &#x3D; wk * a[i + j + mid];
                a[i + j] &#x3D; x + y,a[i + j + mid] &#x3D; x - y;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);
    cin &gt;&gt; n &gt;&gt; m;
    for(int i &#x3D; 0;i &lt;&#x3D; n;i++)   cin &gt;&gt; a[i].x;
    for(int i &#x3D; 0;i &lt;&#x3D; m;i++)   cin &gt;&gt; b[i].x;
    while((1 &lt;&lt; bit) &lt; n + m + 1)   bit++;
    tot &#x3D; 1 &lt;&lt; bit;
    for(int i &#x3D; 0;i &lt; tot;i++)
        rev[i] &#x3D; (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (bit - 1));
    fft(a,1),fft(b,1);
    for(int i &#x3D; 0;i &lt; tot;i++)  a[i] &#x3D; a[i] * b[i];
    fft(a,-1);
    for(int i &#x3D; 0;i &lt;&#x3D; n + m;i++)
        cout &lt;&lt; (int)(a[i].x &#x2F; tot + 0.5) &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n + m];
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3125/">多项式乘法</a>   <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3126/">高精度乘法II</a></p>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><blockquote>
<p>题意描述：一堆物品，其中每一个的物品数量有不同的限制，求物品的搭配数？</p>
</blockquote>
<p><strong>模板题解析：</strong></p>
<p>​		将一个大问题划分为一定数量的子问题，然后写出它们的生成函数：</p>
<ul>
<li>承德汉堡：偶数个。 $f_1(x) &#x3D; 1 + x^2 + x^4 + \cdots &#x3D; \frac{1}{1 - x^2}$</li>
<li>可乐：$0$ 个或 $1$ 个。 $f_2(x) &#x3D; 1 + x &#x3D; \frac{1 - x^2}{1 - x}$</li>
<li>鸡腿：$0$ 个，$1$ 个或 $2$ 个。 $f_3(x) &#x3D; 1 + x + x^2 &#x3D; \frac{1 - x^3}{1 - x}$</li>
<li>蜜桃多：奇数个。 $f_4(x) &#x3D; x + x^3 + x^5 + \cdots &#x3D; \frac{x}{1 - x^2}$</li>
<li>鸡块：$4$ 的倍数个。 $f_5(x) &#x3D; 1 + x^4 + x^8 + \cdots &#x3D; \frac{1}{1 - x^4}$</li>
<li>包子：$0$ 个、$1$个、$2$ 个或 $3$ 个。 $f_6(x) &#x3D; 1 + x + x^2 + x^3 &#x3D; \frac{1 - x^4}{1 - x}$</li>
<li>土豆片炒肉：不超过 $1$ 个。 $f_7(x) &#x3D; 1 + x &#x3D; \frac{1 - x^2}{1 - x}$ </li>
<li>面包：$3$ 的倍数。 $f_8(x) &#x3D; 1 + x^3 + x^6 + \cdots &#x3D; \frac{1}{1 - x^3}$</li>
</ul>
<p>由上面的生成函数可以得到：</p>
<p>$F(x) &#x3D; f_1(x)f_2(x)\cdots f_8(x) &#x3D; \frac{x}{(1-x)^4} &#x3D; x × (\sum_{n&#x3D;0}^{\infty}C_{n + 4 - 1}^{4 - 1} × x^n) &#x3D; \sum_{n&#x3D;0}^{\infty}C_{n+4-1}^{4-1} × x^{n+1}$</p>
<p>因此，$x^n$ 的系数为：$C_{n - 1 + 3}^{3} &#x3D; C_{n+2}^{3} &#x3D; \frac{n×(n+1)×(n+2)}{6}$，故该数即为方案数。</p>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int N &#x3D; 510,P &#x3D; 10007;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    string s;
    cin &gt;&gt; s;

    ll n &#x3D; 0;
    for(auto c : s) n &#x3D; (n * 10 + c - &#39;0&#39;) % P;

    cout &lt;&lt; n * (n + 1) * (n + 2) &#x2F; 6 % P &lt;&lt; &quot;\n&quot;;
    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/3135/">食物</a></p>
<h2 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h2><h3 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3><blockquote>
<p>$\left[<br>    \begin{matrix}<br>    n\<br>    k<br>    \end{matrix}<br>    \right]$ 表示将 $n$ 个两两不同的元素，划分为 $k$ 个非空圆排列的方案数。</p>
<p>$DP$ 递推：$\begin{equation}	<br>\left[<br>    \begin{matrix}<br>    n\<br>k<br>    \end{matrix}<br>    \right]<br>\end{equation}$ &#x3D; $\begin{equation}	<br>\left[<br>    \begin{matrix}<br>    n - 1\<br>k-1<br>    \end{matrix}<br>    \right]<br>\end{equation}$ + $(n - 1) × \begin{equation}	<br>\left[<br>    \begin{matrix}<br>    n - 1\<br>k<br>    \end{matrix}<br>    \right]<br>\end{equation}$</p>
<p>分析：定义 $f[i][j]$ 为前 $i$ 个数，分成 $k$ 个非空圆排列的方案数。则划分为两个集合：第 $i$ 个数放在了新的圆排列中（即 $f[i - 1][j - 1]$）与第 $i$ 个数放在原来的圆排列中（即 $(i - 1)f[i - 1][j]$）。</p>
<p><strong>时间复杂度：</strong>$O(n^2)$</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 1e9 + 7;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n,k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;vector&lt;ll&gt;&gt; f(n + 1,vector&lt;ll&gt;(k + 1));
    f[0][0] &#x3D; 1;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 1; j &lt;&#x3D; k; j++)
        &#123;
            f[i][j] &#x3D; (f[i - 1][j - 1] + (i - 1) * f[i - 1][j]) % mod;
        &#125;
    &#125;
    cout &lt;&lt; f[n][k] &lt;&lt; &#39;\n&#39;;

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3168/">第一类斯特林数</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3023/">建筑师</a></p>
<h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><blockquote>
<p>$\left{<br>    \begin{matrix}<br>    n\<br>    k<br>    \end{matrix}<br>    \right}$ 表示将 $1$ ~ $n$ 划分成 $k$ 个子集的方案数。</p>
<p>$DP$ 递推：$\left{<br>    \begin{matrix}<br>    n\<br>    k<br>    \end{matrix}<br>    \right}$ &#x3D; $\left{<br>    \begin{matrix}<br>    n - 1\<br>    k - 1<br>    \end{matrix}<br>    \right}$ + $k\left{<br>    \begin{matrix}<br>    n - 1\<br>    k<br>    \end{matrix}<br>    \right}$</p>
<p>分析：定义 $f[i][j]$ 为前 $i$ 个数，分成 $k$ 个子集的方案数。则可以分成两个集合：</p>
<ul>
<li>$n$ 单独一个集合（$f[i - 1][j - 1]$）</li>
<li>$n$ 放入之前的集合（$j×f[i - 1][j]$）</li>
</ul>
<p>时间复杂度：$O(n^2)$</p>
</blockquote>
<p><mark>模板题代码：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;

using namespace std;

typedef long long ll;

const int mod &#x3D; 1e9 + 7;

int main()
&#123;
    cin.tie(nullptr)-&gt;sync_with_stdio(false);

    int n,k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;vector&lt;ll&gt;&gt; f(n + 1,vector&lt;ll&gt;(k + 1));
    f[0][0] &#x3D; 1;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        for (int j &#x3D; 1; j &lt;&#x3D; k; j++)
        &#123;
            f[i][j] &#x3D; (f[i - 1][j - 1] + j * f[i - 1][j]) % mod;
        &#125;
    &#125;
    cout &lt;&lt; f[n][k] &lt;&lt; &#39;\n&#39;;

    return 0;
&#125;</code></pre>

<p><mark>推荐题单：</mark></p>
<p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/3169/">第二类斯特林数</a></p>
<h2 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h2><h3 id="康托展开-1"><a href="#康托展开-1" class="headerlink" title="康托展开"></a>康托展开</h3><p>  把一个集合产生的全排列按照字典序排序，第X个排列的计算公式如下：</p>
<blockquote>
    X = a[n] * (n - 1)! + a[n - 1] * (n - 2)! + ... + a[2] * 1! + a[1] * 0!
</blockquote>


<p>其中，a[i]表示原数的第i位在当前未出现的元素中排在第几个（从0开始）。</p>
<p><mark>代码模板：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">ll res &#x3D; 1;&#x2F;&#x2F;因为算法是从0开始的，故按排名的话需要先初始化为1
	for(int i &#x3D; n;i &gt;&#x3D; 1;i--)
    &#123;&#x2F;&#x2F;这里用的是树状数组
        res +&#x3D;  query(a[i]) * fact[n - i];
        add(a[i],1);
    &#125;</code></pre>



<h3 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><p>  由于没能找到比较好的博客去介绍逆康托的相关使用，下面粗略的给出求解的一种思路和朴素的算法（<del>不是</del>）。</p>
<p><strong>一、思路？</strong></p>
<p>如果4的全排列中排名第6的排列是？</p>
<p>首先初始化：6 – &#x3D; 5</p>
<p>其次，5 &#x2F; 3！ &#x3D;  0 余 5 说明第一位前面没有比自己小的数，故第一位是1</p>
<p>然后取出上次计算得到的余数，令 5 &#x2F; 2！&#x3D;  2 余1，说明第二位前面有两个数比自己小，故第二位是4</p>
<p>继续：1 &#x2F; 1！&#x3D;  1，余数为0，说明第三位前面有1个比自己小的数，故第三位是3</p>
<p>最后只剩下一个数了，即第四位是2</p>
<p>综上所述，排名第6的排列是：1432</p>
<p><strong>二、朴素！</strong></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">ll x;
std::cin &gt;&gt; x;
x--;&#x2F;&#x2F;需要先减1初始化

std::vector&lt;int&gt; num(n + 1);
for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   num[i] &#x3D; i;

std::vector&lt;int&gt; res(n + 1);
for(int i &#x3D; n,r &#x3D; 0;i &gt;&#x3D; 1;i--)
&#123;
    int t &#x3D; x &#x2F; fact[i - 1];&#x2F;&#x2F;前面有t个比自己小的数
    x %&#x3D; fact[i - 1];
    res[n - i + 1] &#x3D; num[t + 1];&#x2F;&#x2F;说明当前的数排名第t + 1
    num.erase(num.begin() + t + 1);&#x2F;&#x2F;将该数从num中删去
&#125;
for(int i &#x3D; 1;i &lt;&#x3D; n;i++)   std::cout &lt;&lt; res[i] &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n];</code></pre>

<p>综合<strong>康托展开</strong>和<strong>逆康托展开</strong>的例题奉上：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3014">[USACO11FEB]Cow Line S</a></p>
<h2 id="速推公式"><a href="#速推公式" class="headerlink" title="速推公式"></a>速推公式</h2><blockquote>
<p>简化要推的公式：</p>
<p>初值为 $26$，之后每次递增 $11,13,15,17\cdots$，即 $26,37,50\dots$。</p>
<p>针对 $11,13,15\cdots$，有 $a_n &#x3D; 11 + 2(n - 1),S_n &#x3D; \frac{11 + 11 + 2n - 2}{2} × n &#x3D; n^2 + 10n$；</p>
<p>因此，带上初值 $26$ 之后：$S &#x3D; 26 + n^2 + 10n$，在 $n &#x3D; 0$ 时，为26； $n &#x3D; 1$ 时，为37；故最初给的 $n$ 减去 $4$ 再带入公式即可。</p>
</blockquote>
<p><mark>推荐题单：</mark></p>
<p><strong>模板题（easy）：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1822/problem/C">C. Bun Lover</a></p>
<p><strong>一个找规律的网站：</strong><a target="_blank" rel="noopener" href="https://oeis.org/">OEIS</a></p>
<h2 id="秦九韶算法"><a href="#秦九韶算法" class="headerlink" title="秦九韶算法"></a>秦九韶算法</h2><p><mark>将 $b$ 进制的数转化成十进制：</mark></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">int get(string s, int b)  &#x2F;&#x2F; 将b进制的数转化成十进制
&#123;
    int res &#x3D; 0;
    &#x2F;&#x2F; 秦九韶算法
    for (auto c: s)
        res &#x3D; res * b + c - &#39;0&#39;;
    return res;
&#125;</code></pre>



<h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><h3 id="模数范围"><a href="#模数范围" class="headerlink" title="模数范围"></a>模数范围</h3><blockquote>
    一个数n，如果对mod(1 &le; mod &le; n)取模的话，得到的模数x范围为：[0，(n - 1) / 2]。</blockquote>



<blockquote>
      相反，如果想要得到模数为x的数，原数n必须大于等于2 * x + 1。
</blockquote>


<h3 id="int-范围最多的约数个数"><a href="#int-范围最多的约数个数" class="headerlink" title="int 范围最多的约数个数"></a>int 范围最多的约数个数</h3><blockquote>
<p>$int$ 范围的约数最多不超过：$1600$，例子：$1745944200$，其有 $1536$ 个约数。</p>
</blockquote>
<p><strong>推荐题单：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1617/problem/C">C. Paprika and Permutation</a></p>
<h3 id="矩阵旋转坐标变换"><a href="#矩阵旋转坐标变换" class="headerlink" title="矩阵旋转坐标变换"></a>矩阵旋转坐标变换</h3><blockquote>
    一个n*n的矩阵，顺时针旋转 0，90，180，270度的坐标变换公式：<br>
    0&deg;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;(x,y)<br>
    90&deg;:&nbsp;&nbsp;&nbsp;(y,n - x + 1)<br>
    180&deg;: (n - x + 1,n - y + 1)<br>
    270&deg;: (n - y + 1,x)<br>
</blockquote>
**推荐题目：**[E. Mirror Grid](https://codeforces.com/contest/1703/problem/E)



<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>  <strong>定义：</strong>设（a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>）是{1,2,…,n}的一个全排列，若对任意的i∈{1,2,…,n}都有a<sub>i</sub>  &ne; i，则称（a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>）是{1,2,…,n}的错位排列。</p>
<p><mark>错排公式：</mark></p>
<p>f [ 0 ] &#x3D; 1 , f [ 1 ] &#x3D; 0 , f [ 2 ] &#x3D; 1</p>
<p>f[ n ] &#x3D; ( n − 1 ) ∗ ( f [ n − 1 ] + f [ n − 2 ] )</p>
<p><strong>例题推荐：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4071">排列计数</a></p>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><h3 id="模运算："><a href="#模运算：" class="headerlink" title="模运算："></a>模运算：</h3><p><mark>复习下模运算的基本规则：</mark></p>
<ul>
<li>(a + b) % p &#x3D; (a % p + b % p) % p</li>
<li>(a – b) % p &#x3D; (a % p – b % p) % p</li>
<li>(a * b) % p &#x3D; (a % p * b % p) % p</li>
<li>($a^b$) % p &#x3D; ((a % p)$^b$) % p</li>
</ul>
<h3 id="n-×-n-的矩阵顺时针-逆时针旋转90°后的位置："><a href="#n-×-n-的矩阵顺时针-逆时针旋转90°后的位置：" class="headerlink" title="$n$ × $n$ 的矩阵顺时针 &#x2F; 逆时针旋转90°后的位置："></a>$n$ × $n$ 的矩阵顺时针 &#x2F; 逆时针旋转90°后的位置：</h3><p>假定下标从 $(1,1)$ 开始，则：</p>
<ul>
<li>顺时针 $90°$：$(i,j) -&gt; (j, n - i + 1)$</li>
<li>逆时针 $90°$：$(i,j) -&gt; (n - j + 1,i)$</li>
</ul>
<p>拓展，若求顺时针旋转 $180°$，则将一个点先顺时针$90°$，得到的点再顺时针 $90°$即可，即：</p>
<p>$(i,j) -&gt; (j,n - i + 1) -&gt; (n - i + 1, n - j + 1)$</p>
<p>其余类推即可。</p>
<p><strong>给出这类题目的题型：</strong><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1881/problem/C">C. Perfect Square</a></p>
<h3 id="向上取整转换为向下取整："><a href="#向上取整转换为向下取整：" class="headerlink" title="向上取整转换为向下取整："></a>向上取整转换为向下取整：</h3><p>$\lceil \frac{L}{P} \rceil$  &#x3D;  $\lfloor \frac{L + P - 1}{P} \rfloor $</p>
<ul>
<li>这个公式对于：$\lceil\frac{-2}{2}\rceil &#x3D; -1$ 会出现问题，因为 $\lfloor\frac{-2 + 2 - 1}{2}\rfloor &#x3D; 0$，因此这个公式对于都是正数是成立，为了确保通用性，建议还是用函数来代替：<ul>
<li>向上取整函数：<code>ceil()</code></li>
<li>向下取整函数：<code>floor()</code></li>
<li>四舍五入函数：<code>round()</code></li>
</ul>
</li>
</ul>
<h3 id="线性回归方程"><a href="#线性回归方程" class="headerlink" title="线性回归方程"></a>线性回归方程</h3><p>线性回归：假设有一堆点（$x_i,y_i$），求一条直线 $y^{‘} &#x3D; Ax + B$ 使得 $\sum_{i&#x3D;1}^{n}(y_{i} - y_{‘}(x_i))^{2}$ 最小。</p>
<p>令$\overline{x}$ &#x3D; $\frac{\sum_{i &#x3D; 1}^{n}x_i}{n}$，令$\overline{y}$ &#x3D; $\frac{\sum_{i &#x3D; 1}^{n}y_i}{n}$，则：<br>$$<br>A &#x3D;\frac{\sum_{i&#x3D;1}^{n}(x_i-\overline{x})(y_i-\overline{y})}{\sum_{i&#x3D;1}^{n}(x_i-\overline{x})^2} &#x3D; \frac{\sum_{i&#x3D;1}^{n}x_iy_i-n\overline{x}\overline{y}}{\sum_{i&#x3D;1}^{n}x_i^2-n(\overline{x})^2}\<br>B &#x3D; \overline{y} - A\overline{x}\<br>$$</p>
<h3 id="连续区间的和-异或和公式："><a href="#连续区间的和-异或和公式：" class="headerlink" title="连续区间的和 &#x2F; 异或和公式："></a>连续区间的和 &#x2F; 异或和公式：</h3><blockquote>
<p>区间[l,r]的所有数之和：$ sum[r] - sum[l - 1]$</p>
</blockquote>
<blockquote>
<p>区间[l,r]的所有数异或：$sxor[r]$ ^ $sxor[l - 1]$</p>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">重生带我走</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://318471543.github.io/2024/10/08/%E6%95%B0%E8%AE%BA/">https://318471543.github.io/2024/10/08/%E6%95%B0%E8%AE%BA/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">重生带我走</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E8%AE%BA/">
                                    <span class="chip bg-color">数论</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/10/08/%E6%9D%82%E9%A2%98%E9%A2%98%E5%8D%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="杂题题单">
                        
                        <span class="card-title">杂题题单</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9D%82%E9%A2%98%E9%A2%98%E5%8D%95/">
                        <span class="chip bg-color">杂题题单</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="数据结构">
                        
                        <span class="card-title">数据结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-10-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            重生带我走
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">数据结构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">重生带我走</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/318471543" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:318471543@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=318471543" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 318471543" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/5545924159" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5545924159" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/shen-mu-yi-35" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/shen-mu-yi-35" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
